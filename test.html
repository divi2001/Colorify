<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>COLORIFY</title>
    <!-- Add Bootstrap CSS -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <!-- Add Bootstrap Icons -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@simonwep/pickr/dist/themes/nano.min.css"
    />
    <script src="https://cdn.jsdelivr.net/npm/@simonwep/pickr"></script>
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/color-thief/2.3.0/color-thief.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <style>
      .harmony-container {
          position: relative;
          display: inline-block;
      }
      
      .btn-success3 {
          background-color: #28a745;
          color: white;
          border: none;
          padding: 8px 16px;
          border-radius: 4px;
          cursor: pointer;
          display: flex;
          align-items: center;
          gap: 8px;
      }
      
      .harmony-menu {
          position: absolute;
          bottom: 100%;
          left: 0;
          background-color: white;
          border: 1px solid #ddd;
          border-radius: 4px;
          box-shadow: 0 2px 10px rgba(0,0,0,0.1);
          width: 200px;
          z-index: 1000;
          margin-bottom: 5px;
      }
      
      .menu-item {
          padding: 10px 15px;
          cursor: pointer;
          transition: background-color 0.2s;
      }
      
      .menu-item:hover {
          background-color: #f8f9fa;
      }
      
      .menu-item.active {
          background-color: #e9ecef;
      }
      
      .menu-item:first-child {
          border-top-left-radius: 4px;
          border-top-right-radius: 4px;
      }
      
      .menu-item:last-child {
          border-bottom-left-radius: 4px;
          border-bottom-right-radius: 4px;
      }
      </style>
    <style>
      body {
        height: 100vh;
        display: flex;
        flex-direction: column;
      }

      main {
        flex-grow: 1;
        display: flex;
        flex-direction: row;
      }
      header {
        background: #fff !important;
        border-radius: 20px;
        margin-bottom:15px;
        width: 100%;
      }

      .content {
        flex-grow: 1;
        padding: 20px;
        overflow-y: auto;
        transition: all 0.3s;
        background: #fff;
        border-radius: 1%;
      }

      .footer {
        background-color: #343a40;
        color: white;
        text-align: center;
        padding: 10px;
      }

      .sidebar {
        background-color: #f8f9fa;
        overflow-y: auto;
        transition: all 0.3s;
        position: relative;
      }
      
      .sidebar .nav-btn{
        position: absolute;
        right: 7px;
      }
      .collapsed {
        flex: 0 0 46px !important;
      }

      .sidebar ul {
        padding: 0;
        list-style-type: none;
      }

      .sidebar ul li a {
        display: block;
        padding: 10px;
        text-decoration: none;
        color: black;
      }
      .header-logo {
        font-size: 1.5rem;
      }

      .header-profile-pic {
        width: 40px;
        height: 40px;
        border-radius: 50%;
      }
      #leftMostColumn {
        background: #fff;
        margin-right: 10px;
        border-radius: 20px;
      }
      #rightSidebar {
        background: #fff;
        margin-right: 10px;
        margin-left: 10px;
        border-radius: 20px;
      }
      #secondaryColumn {
        background: #fff;
        margin-right: 10px;
        border-radius: 20px;
        height: 100vh;
      }
      .upload-btn{
        color: white;
        border: none;
      }
      .bg-linear-blue{
        background: linear-gradient(to right, #7a85eb , #3C4CD1);
      }
    </style>

    {% comment %} pop up css  {% endcomment %}
    <style>
      .popup {
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background-color: white;
          padding: 20px;
          border-radius: 8px;
          box-shadow: 0 2px 10px rgba(0,0,0,0.2);
          z-index: 1000;
          animation: fadeIn 0.3s ease-out;
      }
      
      .popup-overlay {
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background-color: rgba(0,0,0,0.5);
          z-index: 999;
      }
      
      @keyframes fadeIn {
          from { opacity: 0; transform: translate(-50%, -60%); }
          to { opacity: 1; transform: translate(-50%, -50%); }
      }
      
      .close-btn {
          position: absolute;
          top: 10px;
          right: 10px;
          cursor: pointer;
          border: none;
          background: none;
          font-size: 18px;
      }
      </style>
    <style>
      body {
        font-family: "Arial", sans-serif;
        background-color: #f8f9fa;
        margin: 0;
        padding:15px;
      }
      h1 {
        text-align: center;
        color: #333;
        margin-bottom: 30px;
      }
      .scrollable-container {
        width: calc(100% - 220px);
        height: 84vh;
        overflow: auto;
        border: 1px solid #ddd;
        position: relative;
        margin-right: 220px;
      }
      .zoom-wrapper {
        transform-origin: top left;
        transition: transform 0.3s;
      }
      .canvas-container {
        position: relative;
        overflow: hidden;

        width: {{width}}px;
        height: {{height}}px;
      }
      .layer {
        position: absolute;
        background: transparent;
        pointer-events: none;
      }

      .toolbar h2 {
        font-size: 18px;
        text-align: center;
        margin-bottom: 15px;
      }

      .zoom-controls,
      .layer-toggles {
        //margin-bottom: 20px;
      }
      .zoom-slider {
        width: 100%;
      }
      .layer-toggle-item {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
      }
      .thumbnail {
        width: 30px;
        height: 30px;
        margin-right: 10px;
        border-radius: 4px;
        border: 1px solid #ddd;
        cursor: pointer;
      }
      .layer-name {
        font-size: 14px;
        flex-grow: 1;
      }
      .color-swatch {
        width: 99px;
        height: 30px;
        //display: inline-block;



      }


      .cp_light {
        position: absolute;
        background-color: #ffffff;
        border: 1px solid #ddd;
        box-shadow: 0px 4px 12px rgba(0, 0, 0, 0.15);
        width: 200px;
        z-index: 1500;
        border-radius: 8px;
        display: none; /* Initially hidden */
        padding: 10px;
        overflow-y: auto;
        max-height: 200px;
      }

      .cp_light .option {
        padding: 8px;
        cursor: pointer;
        font-size: 14px;
        color: #333;
      }

      .cp_light .option:hover {
        background-color: #f0f0f0;
      }
      .cp_light {
        position: absolute;
        background-color: #ffffff;
        border: 1px solid #ddd;
        box-shadow: 0px 4px 12px rgba(0, 0, 0, 0.15);
        width: 200px;
        z-index: 1500;
        border-radius: 8px;
        display: none;
        padding: 10px;
        overflow-y: auto;
      }

      .scrollable {
          max-height: 330px;
          overflow-y: auto;
      }

      .enab, .disab {
          padding: 8px;
          font-size: 14px;
          color: #333;
          cursor: pointer;
          display: flex;
          justify-content: space-between;
      }

      .disab {
          color: #aaa;
          cursor: not-allowed;
      }

      .enab:hover {
          background-color: #f0f0f0;
      }

      .context-panel hr {
          margin: 8px 0;
          border-color: #ddd;
      }
      /* Add a small arrow on the left side of the context menu */
      .cp_light::before {
        content: "";
        position: absolute;
        left: -10px;
        top: 10px;
        width: 0;
        height: 0;
        border-top: 10px solid transparent;
        border-bottom: 10px solid transparent;
        border-right: 10px solid #ffffff; /* Match the context menu background color */
      }
      .pickr-container {
        display: flex;
        {% comment %} gap: 10px; /* Space between buttons */ {% endcomment %}
        align-items: center; /* Center vertically if the buttons have different heights */
      }

      .pcr-button {
          width: 40px;
          height:38px;
          border: none;
          cursor: pointer;
      }
      #colorPickerModal .modal-dialog {
        position: fixed;
        bottom: 0;
        left: 50%;
        transform: translateX(-50%);
        width: 100%;
        max-width: 600px; /* Adjust as needed */
        margin: 0;
      }

      #colorPickerModal .modal-content {
          border-radius: 10px 10px 0 0; /* Rounded corners at the top */
          box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.3);
      }
      .modal-backdrop {
        display: none !important;
      }

      #colorPickerModal {
        pointer-events: auto;
      }

      .modal.fade.show {
          background: transparent;
          pointer-events: none; /* Allow clicks through the modal */
      }

      .modal-dialog {
          pointer-events: auto; /* Only the modal dialog should capture clicks */
      }
      #colorPickerModal {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        max-height: 50%;
        pointer-events: auto;
        z-index: 1050; /* Ensure it appears above other content */
      }

      #loading-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: #fff;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
      }

      .spinner {
          width: 50px;
          height: 50px;
          border: 5px solid rgba(0, 0, 0, 0.1);
          border-top-color: #000;
          border-radius: 50%;
          animation: spin 1s linear infinite;
      }
      .visualizer_toolbar {
        position: fixed;
        bottom: 0;
        background: white;
        left: 0;
        z-index: 101;
        padding: 24px;
        width: 100%;
        box-shadow: rgba(0, 0, 0, 0.075) 0 -1px;
        display: flex;
        justify-content: space-between;
      }
      #visualizer_palette {
        width: 350px;
      }
      .palette-selector {
        height: 46px;
        position: relative;
      }
      .palette-selector.has-btns .palette-selector_colors {
        width: calc(100% - 35px);
      }
      .palette-selector_colors {
        height: 46px;
        width: 100%;
        border-radius: 10px;
        overflow: hidden;
        display: flex;
        position: relative;
      }
      .palette-selector_colors div.is-visible {
        display: block;
      }
      .palette-selector_colors div {
        box-shadow: 1px 0;
        cursor: pointer;
        height: 100%;
        position: relative;
        overflow: hidden;
        float: left;
        display: none;
        flex-grow: 1;
      }
      .palette-selector.has-btns .palette-selector_buttons {
        display: block;
      }
      .palette-selector_buttons {
        position: absolute;
        right: 0;
        top: 0;
        width: 23px;
        text-align: center;
        display: none;
      }
      .palette-selector.has-btns .palette-selector_colors {
        width: calc(100% - 35px);
      }
      @keyframes spin {
          to {
              transform: rotate(360deg);
          }
      }

      .palette-wrapper {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .scroll-container {
          width: 80%; /* Adjust this width as needed */
          overflow-x: auto;
          white-space: nowrap;
          position: relative;
          {% comment %} border-radius:11px; {% endcomment %}
      }

      .color-pickers {
          display: flex;
          gap: 10px;
          padding: 10px;
      }

      .pickr {
          flex: 0 0 auto; /* Prevents shrinking */
      }

      .scroll-btn {
          border:1px solid;
          color: #000;
          border: none;
          padding: 10px;
          cursor: pointer;
          border-radius: 5px;
          font-size: 18px;
      }

      .scroll-btn:hover {
          background-color: #0056b3;
      }

      .pickr .pcr-button{
        height:2em!important;
        margin: 0 .3em 0 .3em !important;

      }


      /* Left Sidebar */
      #leftSidebar {
        position: fixed;
        top: 0;
        left: 0;
        width: 250px;
        height: 100vh;
        background-color: #f5f5f5;
        box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1);
        padding: 20px;
        overflow-y: auto;
        z-index: 1000;
      }

      /* Main Content */
      .scrollable-container {
        margin-left: 250px;
        margin-right: 250px;
        overflow: auto;
        flex: 1;
        position: relative;
      }
      /* Toggle Button */
      .toggle-btn {
        position: absolute;
        top: 10px;
        left: 10px;
        background-color: #007bff;
        color: #fff;
        border: none;
        border-radius: 4px;
        padding: 5px;
        cursor: pointer;
      }
      /* Collapsed State */
      .collapsed {
        width: 40px;
      }


      .collapsed .sidebar-content {
        opacity: 0;
        pointer-events: none;
      }

      #leftSidebar {
        left: 0;
      }

      /* Color Palette Styles */
      .color-palette {
        display: flex;
        flex-wrap: wrap;
        margin-top: 10px;
        overflow-x: auto;
      }


      #loader {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 9999;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .spinner {
        width: 50px;
        height: 50px;
        border: 5px solid #f3f3f3;
        border-top: 5px solid #3498db;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .color-palette {
        display: grid;
        grid-template-columns: repeat(2, 1fr); /* Two columns */
        //gap: 10px; /* Space between swatches */
      }

      .color-swatch {
          width: 125px; /* Full width within the grid cell */
          height: 25px; /* Fixed height for uniformity */
          //border-radius: 5px; /* Rounded corners */
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Optional shadow */
          cursor: pointer;
          transition: transform 0.2s ease;
      }

      .color-swatch:hover {
          transform: scale(1.05); /* Enlarge slightly on hover */
      }
    </style>
    
  <style>
 .image-adjustments {
    position: relative;
}

.adjustment-panel {
    position: fixed;  /* Changed to fixed positioning */
    left: 60px;      /* Offset from left to not overlap with the button */
    bottom: 20px;    /* Position from bottom */
    background: white;
    padding: 15px;
    border-radius: 8px;
    box-shadow: 0 0 10px rgba(0,0,0,0.1);
    min-width: 250px;
    max-height: 80vh; /* Limit height to 80% of viewport height */
    overflow-y: auto; /* Add scrolling if content is too long */
    z-index: 1000;
}

.layer-adjustments {
    margin-bottom: 20px;
    padding: 10px;
    border: 1px solid #ddd;
    border-radius: 5px;
    background-color: #f9f9f9;
}

.layer-adjustments h4 {
    margin-bottom: 10px;
    font-size: 14px;
    color: #333;
}

.slider-group {
    margin-bottom: 10px;
}

.slider-group label {
    display: block;
    margin-bottom: 5px;
    font-size: 12px;
    color: #666;
}

.slider-group input {
    width: 100%;
}

/* Add some hover effects */
.layer-adjustments:hover {
    border-color: #999;
    transition: border-color 0.2s ease;
}

.color-button-wrapper {
    position: relative;
    display: inline-block;
}

.lock-overlay {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(255, 255, 255, 0.8);
    border-radius: 50%;
    padding: 4px;
    cursor: pointer;
    opacity: 0;
    transition: opacity 0.2s;
}


.color-button-wrapper:hover .lock-overlay {
    opacity: 1;
}

.lock-overlay svg {
    display: block;
}

.mostLeftUl li a {
  position: relative;
  transition: all 0.3s ease;
  padding: 10px;
  display: block;
  text-decoration: none;
  color: #333;
}

.mostLeftUl li a.active {
  background-color: rgba(0, 123, 255, 0.1);
  color: #007bff;
}

.mostLeftUl li a:hover {
  background-color: rgba(0, 123, 255, 0.05);
}

.mostLeftUl li a.active::before {
  content: '';
  position: absolute;
  left: 0;
  top: 0;
  height: 100%;
  width: 3px;
  background-color: #007bff;
}
.inspiration-placeholder {
  padding: 20px;
  text-align: center;
  border: 2px dashed #dee2e6;
  border-radius: 8px;
  margin-top: 20px;
}

.inspiration-placeholder p {
  margin: 0;
  color: #6c757d;
  font-size: 14px;
}

.sidebar-content {
  display: none;
}

#inspirationContent {
  display: block;
}
.pdf-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);  /* Two columns */
  gap:10px;
  max-width: 1200px;  /* Maximum width for the container */
  margin: 0 auto;     /* Center the grid */
}

.pdf-item {
  height: 170px;
  border: 1px solid #ddd;
  border-radius: 8px;
  overflow: hidden;
  transition: transform 0.2s;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.pdf-preview {
  height: 100%;
  position: relative;
  cursor: pointer;
}

.pdf-preview img {
  width: 100%;
  height: 150px;
  object-fit: cover;
}

.pdf-info {
  padding: 10px;
  background: rgba(0, 0, 0, 0.7);
  color: white;
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
}

.pdf-actions {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.pdf-likes {
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 5px;
}

.download-btn {
  padding: 2px 8px;
  font-size: 12px;
}
.visualizer_buttons_left{
  display:flex!important;
  align-items: center;
  gap: 10px;
}
/* Responsive behavior for smaller screens */
@media (max-width: 768px) {
  .pdf-grid {
      grid-template-columns: 1fr;  /* Single column on mobile */
  }
}


    </style>
    <style>
      .effects-grid {
          display: grid;
          grid-template-columns: repeat(2, 1fr);
          gap: 15px;
          padding: 15px;
      }
      
      .effect-item {
          border: 1px solid #ddd;
          border-radius: 8px;
          overflow: hidden;
          cursor: pointer;
          transition: transform 0.2s;
      }
      
      .effect-item:hover {
          transform: scale(1.05);
      }
      
      .effect-preview {
          position: relative;
      }
      
      .effect-preview img {
          width: 100%;
          height: 120px;
          object-fit: cover;
      }
      
      .effect-name {
          position: absolute;
          bottom: 0;
          left: 0;
          right: 0;
          background: rgba(0, 0, 0, 0.7);
          color: white;
          padding: 5px;
          text-align: center;
      }
      
      /* Effect-specific styles */
      .effect-item[data-effect="grayscale"] img {
          filter: grayscale(100%);
      }
      
      .effect-item[data-effect="sepia"] img {
          filter: sepia(100%);
      }
      
      .effect-item[data-effect="invert"] img {
          filter: invert(100%);
      }
      
      .effect-item[data-effect="brightness"] img {
          filter: brightness(150%);
      }

      /* Add this to your existing CSS */
.right-sidebar-specific {
  position: relative;
  background: #fff;
  margin-right: 10px;
  margin-left: 10px;
  border-radius: 20px;
  width: 250px;
  min-width: 250px; /* Add this to prevent collapse */
  transition: all 0.3s ease;
  display: flex !important;
  flex-direction: column;
  flex-shrink: 0; /* Add this to prevent shrinking */
}

.right-sidebar-specific .sidebar-content {
  padding: 20px;
  opacity: 1;
  transition: opacity 0.3s ease;
  display: block !important;
}

.right-sidebar-specific.collapsed {
  width: 46px;
  min-width: 46px;
}

.right-sidebar-specific.collapsed .sidebar-content {
  opacity: 0;
  pointer-events: none;
}

/* Layer toggle specific styles */
.right-sidebar-specific .layer-toggles {
  margin-top: 20px;
  opacity: 1;
  transition: opacity 0.3s ease;
  display: block !important;
}

.right-sidebar-specific .layer-toggle-item {
  display: flex;
  align-items: center;
  margin-bottom: 10px;
  padding: 8px;
  background: #f8f9fa;
  border-radius: 8px;
}


.favorite-btn .bi-heart-fill {
  color: red;
}

.favorite-btn .fav-count {
  font-size: 0.8em;
  margin-left: 4px;
}

.color-palette {
  min-height: 150px;
}
      </style>
      
    
  </head>
  <body>
    <div id="loading-screen">
      <div class="spinner"></div>
    </div>
    <!-- Header -->
    <header
      class="text-dark p-2 px-3 d-flex align-items-center justify-content-between ms-auto me-auto"
    >
      <!-- Left: Icon -->
      <div class="header-logo">
        <i class="bi bi-palette"></i>
      </div>

      <!-- Center: Search Bar -->
      {% comment %}
      <div class="flex-grow-1 mx-3">
        <input type="text" class="form-control" placeholder="Search" />
      </div>
      {% endcomment %}

      <!-- Right: Profile Picture with Dropdown -->
      <div class="dropdown">
        <a
          href="#"
          class="d-flex align-items-center text-dark text-decoration-none"
          id="profileDropdown"
          data-bs-toggle="dropdown"
          aria-expanded="false"
        >
          <i class="bi bi-person-bounding-box"></i>
          <span class="ms-2">{{ user.username }}</span>
          <i class="bi bi-caret-down-fill ms-1"></i>
        </a>
        <ul
          class="dropdown-menu dropdown-menu-end text-small shadow"
          aria-labelledby="profileDropdown"
        >
          <li><a class="dropdown-item" href="#">Profile</a></li>
          <li><a class="dropdown-item" href="#">Settings</a></li>
          <li><hr class="dropdown-divider" /></li>
          <li><a class="dropdown-item" href="#">Logout</a></li>
        </ul>
      </div>
    </header>


    <!-- Main Content Area  -->
    <main class="d-flex">
      <!-- Left Sidebar -->
      <div
        id="leftMostColumn"
        class="sidebar d-flex flex-column"
        style="flex: 0 0 150px"
      >
        <button
          class="btn btn-primary btn-sm m-2 d-flex align-items-center"
          onclick="toggleSidebar('leftMostColumn', this)"
        >
          <i class="bi bi-caret-left-fill ms-auto"></i>
        </button>
        <ul class="mostLeftUl">
          <li>
            <a href="#" id="inspirationButton">
              <i class="bi bi-brightness-alt-high me-2 mx-1"></i>
              <span class="textSpan">Inspiration</span>
            </a>
          </li>
          <li>
            <a href="#" id="trendingButton">
              <i class="bi bi-graph-up-arrow mx-1"></i>
              <span class="textSpan">Trending</span>
            </a>
          </li>
          <li>
            <a href="#" id="effectsButton">
              <i class="bi bi-magic mx-1"></i>
              <span class="textSpan">Effects</span>
            </a>
          </li>
          <li>
            <a href="#" id="favoriteButton">
              <i class="bi bi-star mx-1"></i>
              <span class="textSpan">Favourite</span>
            </a>
          </li>
          <li>
            <a href="#" id="baseColorButton">
              <i class="bi bi-palette mx-1"></i>
              <span class="textSpan">Base Color</span>
            </a>
          </li>
          <li>
            <a href="#" id="ssCollectionButton">
              <i class="bi bi-collection mx-1"></i>
              <span class="textSpan">SS Collection</span>
            </a>
          </li>
          <li>
            <a href="#" id="awCollectionButton">
              <i class="bi bi-collection mx-1"></i>
              <span class="textSpan">AW Collection</span>
            </a>
          </li>
        </ul>
      </div>


        <div id="secondaryColumn" class="sidebar d-flex flex-column" style="flex: 0 0 310px">
          <button class="btn-sm m-2 d-flex align-items-center nav-btn" onclick="toggleSidebar('secondaryColumn', this)" style="border: none; background: #fff">
              <i class="bi bi-caret-left-fill ms-auto"></i>
          </button>
          
          <!-- Trending Content -->
     
         <div class="sidebar-content" id="trendingContent" style="display: none;">
          <h4 class="ms-auto me-auto">Trending Palette</h4>
          <hr />
          <div class="layer-toggles d-flex gap-3 justify-content-center flex-wrap">
            {% if layers|length == 1 %}
            {% for i in "0123456789" %}
                <div class="layer-toggle-item d-flex flex-column gap-2">
                    <div id="trending_colorPalette_{{ forloop.counter0 }}" class="color-palette d-flex flex-column"></div>
                    <div class="d-flex align-items-center justify-content-between w-100">
                        <button id="shufflePalette_{{ forloop.counter0 }}" class="btn btn-sm btn-primary">
                            <i class="bi bi-shuffle"></i>
                        </button>
                        <button type="button" 
                                id="trending_fav_btn_{{ forloop.counter0 }}" 
                                class="btn favorite-btn"
                                data-palette-type="TR"
                                data-colors-id="{{ forloop.counter0 }}"
                                onclick="toggleFavorite(this, 'trending')">
                            <i class="bi bi-heart"></i>
                            <span class="fav-count">0</span>
                        </button>
                        <!-- Fix: Ensure button ID matches what our JS will look for -->
                        <button type="button" id="applyButton_{{ forloop.counter0 }}" class="btn btn-success">
                            <i class="bi bi-magic"></i>
                        </button>
                    </div>
                </div>
            {% endfor %}
        {% else %}
        
                  {% for layer in layers %}
                      <div class="layer-toggle-item d-flex flex-column gap-2">
                          <div id="trending_colorPalette_{{ forloop.counter }}" class="color-palette d-flex flex-column"></div>
                          <div class="d-flex align-items-center justify-content-between w-100">
                              <button id="shufflePalette_{{ forloop.counter }}" class="btn btn-sm btn-primary">
                                  <i class="bi bi-shuffle"></i>
                              </button>
                              <button type="button" 
                                      id="trending_fav_btn_{{ forloop.counter }}" 
                                      class="btn favorite-btn"
                                      data-palette-type="TR"
                                      data-colors-id="{{ forloop.counter }}"
                                      onclick="toggleFavorite(this, 'trending')">
                                  <i class="bi bi-heart"></i>
                                  <span class="fav-count">0</span>
                              </button>
                              <button type="button" id="applyButton_{{ forloop.counter }}" class="btn btn-success">
                                  <i class="bi bi-magic"></i>
                              </button>
                          </div>
                      </div>
                  {% endfor %}
              {% endif %}
          </div>
      </div>
    
        <div class="sidebar-content m-4" id="inspirationContent">
          <h4 class="ms-auto me-auto">Inspirations</h4>
          <div class="inspiration-content">
              <div class="pdf-grid">

              </div>
          </div>
      </div>
      <div class="sidebar-content" id="effectsContent" style="display: none;">
        <h4 class="ms-auto me-auto">Effects</h4>
        <div class="effects-grid">
            <div class="effect-item" data-effect="grayscale">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Grayscale">
                    <div class="effect-name">Grayscale</div>
                </div>
            </div>
            <div class="effect-item" data-effect="sepia">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Sepia">
                    <div class="effect-name">Sepia</div>
                </div>
            </div>
            <div class="effect-item" data-effect="brightness">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Brightness">
                    <div class="effect-name">Brightness</div>
                </div>
            </div>
            <div class="effect-item" data-effect="contrast">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Contrast">
                    <div class="effect-name">Contrast</div>
                </div>
            </div>
            <div class="effect-item" data-effect="blur">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Blur">
                    <div class="effect-name">Blur</div>
                </div>
            </div>
            <div class="effect-item" data-effect="sharpen">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Sharpen">
                    <div class="effect-name">Sharpen</div>
                </div>
            </div>
            <div class="effect-item" data-effect="vintage">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Vintage">
                    <div class="effect-name">Vintage</div>
                </div>
            </div>
            <div class="effect-item" data-effect="colorize">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Colorize">
                    <div class="effect-name">Colorize</div>
                </div>
            </div>
            <div class="effect-item" data-effect="duotone">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Duotone">
                    <div class="effect-name">Duotone</div>
                </div>
            </div>
            <div class="effect-item" data-effect="noise">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Noise">
                    <div class="effect-name">Noise</div>
                </div>
            </div>
            <div class="effect-item" data-effect="vignette">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Vignette">
                    <div class="effect-name">Vignette</div>
                </div>
            </div>
            <div class="effect-item" data-effect="posterize">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Posterize">
                    <div class="effect-name">Posterize</div>
                </div>
            </div>
            <div class="effect-item" data-effect="saturation">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Saturation">
                    <div class="effect-name">Saturation</div>
                </div>
            </div>
        </div>
    </div>
     <!-- SS Collection Content -->
     <div class="sidebar-content" id="ssCollectionContent" style="display: none;">
      <h4 class="ms-auto me-auto">SS Collection</h4>
      <hr />
      <div class="layer-toggles d-flex gap-3 justify-content-center flex-wrap">
          {% if layers|length == 1 %}
              {% for i in "0123456789" %}
                  <div class="layer-toggle-item d-flex flex-column gap-2">
                      <div id="ss_colorPalette_{{ forloop.counter0 }}" class="color-palette d-flex flex-column"></div>
                      <div class="d-flex align-items-center justify-content-between w-100">
                          <button id="ss_shufflePalette_{{ forloop.counter0 }}" class="btn btn-sm btn-primary">
                              <i class="bi bi-shuffle"></i>
                          </button>
                          <button type="button" 
                                  id="ss_fav_btn_{{ forloop.counter0 }}" 
                                  class="btn favorite-btn"
                                  data-palette-type="SS"
                                  data-colors-id="{{ forloop.counter0 }}"
                                  onclick="toggleFavorite(this, 'ss')">
                              <i class="bi bi-heart"></i>
                              <span class="fav-count">0</span>
                          </button>
                          <button type="button" id="ss_applyButton_{{ forloop.counter }}" class="btn btn-success">
                              <i class="bi bi-magic"></i>
                          </button>
                      </div>
                  </div>
              {% endfor %}
          {% else %}
              {% for layer in layers %}
                  <div class="layer-toggle-item d-flex flex-column gap-2">
                      <div id="ss_colorPalette_{{ forloop.counter }}" class="color-palette d-flex flex-column"></div>
                      <div class="d-flex align-items-center justify-content-between w-100">
                          <button id="ss_shufflePalette_{{ forloop.counter }}" class="btn btn-sm btn-primary">
                              <i class="bi bi-shuffle"></i>
                          </button>
                          <button type="button" 
                                  id="ss_fav_btn_{{ forloop.counter }}" 
                                  class="btn favorite-btn"
                                  data-palette-type="SS"
                                  data-colors-id="{{ forloop.counter }}"
                                  onclick="toggleFavorite(this, 'ss')">
                              <i class="bi bi-heart"></i>
                              <span class="fav-count">0</span>
                          </button>
                          <button type="button" id="ss_applyButton_{{ forloop.counter }}" class="btn btn-success">
                              <i class="bi bi-magic"></i>
                          </button>
                      </div>
                  </div>
              {% endfor %}
          {% endif %}
      </div>
  </div>
  

<div class="sidebar-content" id="favCollectionContent" style="display: none;">
  <h4 class="ms-auto me-auto">Favourite Collection</h4>
  <hr />
  <div class="layer-toggles d-flex gap-3 justify-content-center flex-wrap">
      
    {% for layer in layers %}

    <div class="layer-toggle-item d-flex flex-column gap-2">
        <div id="fav_colorPalette_{{ forloop.counter }}" class="color-palette d-flex flex-column"></div>
        <div class="d-flex align-items-center justify-content-between w-100">
          <button id="fav_shufflePalette_{{ forloop.counter }}" class="btn btn-sm btn-primary">
            <i class="bi bi-shuffle"></i>
        </button>
        
        <button type="button" id="" class="btn">
          <i class="bi bi-heart"></i>
      </button>
        <button type="button" id="ss_applyButton_{{ forloop.counter }}" class="btn btn-success">
            <i class="bi bi-magic"></i>
        </button>
        </div>
    </div>
    {% endfor %}
</div>
</div>
<!-- Base Color Content -->
<div class="sidebar-content" id="baseColorContent" style="display: none;">
<h4 class="ms-auto me-auto">Base Colors</h4>
<div class="base-colors-grid">
  <!-- Color blocks will be generated here -->
</div>

<!-- Hidden palettes section - similar to trending/collections -->
<div class="base-palettes-section" style="display: none;">
  <hr/>
  <div class="layer-toggles d-flex gap-3 justify-content-center flex-wrap">
    {% for layer in layers %}
    <div class="layer-toggle-item d-flex flex-column gap-2">
      <div id="base_colorPalette_{{ forloop.counter }}" class="color-palette d-flex flex-column"></div>
      <div class="d-flex align-items-center justify-content-between w-100">
        <button id="base_shufflePalette_{{ forloop.counter }}" class="btn btn-sm btn-primary">
          <i class="bi bi-shuffle"></i>
        </button>
        <button type="button" class="btn">
          <i class="bi bi-heart"></i>
        </button>
        <button type="button" id="base_applyButton_{{ forloop.counter }}" class="btn btn-success">
          <i class="bi bi-magic"></i>
        </button>
      </div>
    </div>
    {% endfor %}
  </div>
</div>
</div>

<!-- AW Collection Content -->
<div class="sidebar-content" id="awCollectionContent" style="display: none;">
  <h4 class="ms-auto me-auto">AW Collection</h4>
  <hr />
  <div class="layer-toggles d-flex gap-3 justify-content-center flex-wrap">
      {% if layers|length == 1 %}
          {% for i in "0123456789" %}
              <div class="layer-toggle-item d-flex flex-column gap-2">
                  <div id="aw_colorPalette_{{ forloop.counter0 }}" class="color-palette d-flex flex-column"></div>
                  <div class="d-flex align-items-center justify-content-between w-100">
                      <button id="aw_shufflePalette_{{ forloop.counter0 }}" class="btn btn-sm btn-primary">
                          <i class="bi bi-shuffle"></i>
                      </button>
                      <button type="button" 
                              id="aw_fav_btn_{{ forloop.counter0 }}" 
                              class="btn favorite-btn"
                              data-palette-type="AW"
                              data-colors-id="{{ forloop.counter0 }}"
                              onclick="toggleFavorite(this, 'aw')">
                          <i class="bi bi-heart"></i>
                          <span class="fav-count">0</span>
                      </button>
                      <button type="button" id="aw_applyButton_{{ forloop.counter }}" class="btn btn-success">
                          <i class="bi bi-magic"></i>
                      </button>
                  </div>
              </div>
          {% endfor %}
      {% else %}
          {% for layer in layers %}
              <div class="layer-toggle-item d-flex flex-column gap-2">
                  <div id="aw_colorPalette_{{ forloop.counter }}" class="color-palette d-flex flex-column"></div>
                  <div class="d-flex align-items-center justify-content-between w-100">
                      <button id="aw_shufflePalette_{{ forloop.counter }}" class="btn btn-sm btn-primary">
                          <i class="bi bi-shuffle"></i>
                      </button>
                      <button type="button" 
                              id="aw_fav_btn_{{ forloop.counter }}" 
                              class="btn favorite-btn"
                              data-palette-type="AW"
                              data-colors-id="{{ forloop.counter }}"
                              onclick="toggleFavorite(this, 'aw')">
                          <i class="bi bi-heart"></i>
                          <span class="fav-count">0</span>
                      </button>
                      <button type="button" id="aw_applyButton_{{ forloop.counter }}" class="btn btn-success">
                          <i class="bi bi-magic"></i>
                      </button>
                  </div>
              </div>
          {% endfor %}
      {% endif %}
  </div>
</div>
</div>
  
      </div>


      <!-- Main Content -->
      <div id="mainContent" class="content">
        <div class="d-flex align-items-center justify-content-between">
          <h2 class="fs-4 fw-bold">Workspace</h2>
          <div class="zoom-controls">
            <label for="zoomSlider" class="me-2">Zoom:</label>
            <input
              type="range"
              id="zoomSlider"
              class="zoom-slider"
              min="5"
              max="150"
              value="5"
              step="1"
            />
          </div>
        </div>
        <hr />

        <div class="zoom-wrapper" id="zoomWrapper">
          <div class="canvas-container">
            {% for layer in layers %}
            <div
              class="layer"
              id="layer_{{ forloop.counter }}"
              style="top: {{ layer.layer_position_from_top }}px; left: {{ layer.layer_position_from_left }}px;"
            >
              <canvas 
                id="layer_canvas_{{ forloop.counter }}" 
                data-original-src="{{ layer.path }}"
              ></canvas>
            </div>
            {% endfor %}
          </div>
        </div>
      </div>

      <!-- Right Sidebar -->
      <div
        id="rightSidebar"
        class="sidebar1 d-flex flex-column toolbar scrollable-toolbar"
        style="flex: 0 0 250px"
      >
        <button
          class="btn-sm m-2 d-flex align-items-center"
          onclick="toggleSidebar('rightSidebar', this)"
          style="border: none; background: #fff"
        >
          <i class="bi bi-caret-right-fill ms-auto"></i>
        </button>
        <div class="sidebar-content1 m-4">
          <h4 class="ms-auto me-auto mb-3">Layers</h4>

          <div class="layer-toggles mt-4">
            {% for layer in layers %}
            <div class="layer-toggle-item">
              <img
                id="thumbnail_{{ forloop.counter }}"
                class="thumbnail"
                src=""
                alt="Layer Thumbnail"
              />
              <span class="layer-name">{{ layer.name }}</span>
              <input
                type="checkbox"
                id="toggleLayer{{ forloop.counter }}"
                checked
                onchange="toggleLayer({{ forloop.counter }})"
              />
            </div>
            {% endfor %}
          </div>
        </div>
      </div>
      <div id="contextMenu" class="cp_light">
        <div
          id="layerNameDisplay"
          style="font-weight: bold; margin-bottom: 5px"
        ></div>
        <div class="option" onclick="showLayerInfo()">Edit</div>
      </div>
      <!-- Color Picker Modal -->
      <div
        class="modal fade"
        id="colorPickerModal"
        tabindex="-1"
        role="dialog"
        aria-labelledby="colorPickerModalLabel"
        aria-hidden="true"
        data-backdrop="false"
      >
        <div class="modal-dialog" role="document">
          <div class="modal-content">
            <div class="modal-header">
              <h5 class="modal-title" id="colorPickerModalLabel">
                Select Layer Color
              </h5>
              <div style="text-align: center; margin-bottom: 20px">
                <label for="color-count-slider">Number of Colors: </label>
                <input
                  type="range"
                  id="color-count-slider"
                  min="1"
                  max="15"
                  value="15"
                  oninput="updateColorCountDisplay()"
                />
                <span id="color-count-display">15</span>
              </div>
            </div>
            <div class="modal-body">
              <div
                class="color-picker-container pickr-container"
                id="color-pickers"
              ></div>
              <button
                id="generatePallateColorsBtn"
                class="btn btn-warning mt-2"
                onclick="generatePallateColors()"
              >
                Generate New Colors
              </button>
            </div>
            <div class="modal-footer">
              <button
                type="button"
                class="btn btn-secondary"
                data-dismiss="modal"
                onclick="hideModal()"
              >
                Close
              </button>
            </div>
          </div>
        </div>
      </div>
    </main>

  <!-- Footer -->
<footer class="bg-light text-center py-2 mt-auto visualizer_toolbar d-flex align-items-center justify-content-center gap-4">
     
  <div id="visualizer_buttons_left ">
    <div class="d-flex align-items-center gap-2">
      <div class="upload-wrapper">
        <form id="uploadForm" method="post" enctype="multipart/form-data">
            {% csrf_token %}
            <input type="file" id="fileInput" name="tiff_file" accept=".tif" style="display: none;">
            <button type="button" class="btn btn-outline-dark upload-btn m-0 p-2 px-3 bg-linear-blue" onclick="document.getElementById('fileInput').click();">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-cloud-upload" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M4.406 1.342A5.53 5.53 0 0 1 8 0c2.69 0 4.923 2 5.166 4.579C14.758 4.804 16 6.137 16 7.773 16 9.569 14.502 11 12.687 11H10a.5.5 0 0 1 0-1h2.688C13.979 10 15 8.988 15 7.773c0-1.216-1.02-2.228-2.313-2.228h-.5v-.5C12.188 2.825 10.328 1 8 1a4.53 4.53 0 0 0-2.941 1.1c-.757.652-1.153 1.438-1.153 2.055v.448l-.445.049C2.064 4.805 1 5.952 1 7.318 1 8.785 2.23 10 3.781 10H6a.5.5 0 0 1 0 1H3.781C1.708 11 0 9.366 0 7.318c0-1.763 1.266-3.223 2.942-3.593.143-.863.698-1.723 1.464-2.383"/>
                    <path fill-rule="evenodd" d="M7.646 4.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 5.707V14.5a.5.5 0 0 1-1 0V5.707L5.354 7.854a.5.5 0 1 1-.708-.708z"/>
                </svg>
                Upload
            </button>
        </form>
    </div>

    
    <div class="image-adjustments">
      <button type="button" class="btn shadow-lg " id="adjustmentToggle">
        <svg width="19" height="19" viewBox="0 0 34 33" fill="none" xmlns="http://www.w3.org/2000/svg">
          <g clip-path="url(#clip0_384_2340)">
            <path
              d="M32.186 15.2545H13.3887C12.7572 12.7733 10.2339 11.2738 7.75261 11.9053C6.10713 12.3241 4.82225 13.609 4.40344 15.2545H1.90915C1.26599 15.2545 0.744629 15.7759 0.744629 16.419C0.744629 17.0622 1.26599 17.5835 1.90915 17.5835H4.40351C5.035 20.0647 7.55836 21.5641 10.0396 20.9326C11.6851 20.5138 12.97 19.2289 13.3888 17.5835H32.186C32.8291 17.5835 33.3505 17.0621 33.3505 16.4189C33.3505 15.7758 32.8291 15.2545 32.186 15.2545ZM8.89611 18.748C7.60987 18.748 6.56715 17.7053 6.56715 16.419C6.56715 15.1328 7.60987 14.09 8.89611 14.09C10.1824 14.09 11.2251 15.1328 11.2251 16.419C11.2251 17.7053 10.1824 18.748 8.89611 18.748Z"
              fill="#3C4CD1" />
            <path
              d="M32.1862 3.60947H28.5274C27.8959 1.12828 25.3726 -0.371188 22.8913 0.260301C21.2458 0.679109 19.9609 1.96399 19.5421 3.60947H1.90939C1.26623 3.60947 0.744873 4.13084 0.744873 4.77399C0.744873 5.41715 1.26623 5.93851 1.90939 5.93851H19.5421C20.1736 8.4197 22.697 9.91917 25.1782 9.28768C26.8237 8.86887 28.1086 7.58399 28.5274 5.93851H32.1862C32.8294 5.93851 33.3507 5.41715 33.3507 4.77399C33.3507 4.13084 32.8294 3.60947 32.1862 3.60947ZM24.0348 7.10296C22.7486 7.10296 21.7058 6.06023 21.7058 4.77399C21.7058 3.48775 22.7486 2.44502 24.0348 2.44502C25.3211 2.44502 26.3638 3.48775 26.3638 4.77399C26.3638 6.06023 25.3211 7.10296 24.0348 7.10296Z"
              fill="#3C4CD1" />
            <path
              d="M32.186 26.8993H26.1981C25.5667 24.4181 23.0433 22.9186 20.562 23.5501C18.9165 23.9689 17.6317 25.2538 17.2129 26.8993H1.90915C1.26599 26.8993 0.744629 27.4206 0.744629 28.0637C0.744629 28.7068 1.26599 29.2282 1.90915 29.2282H17.2129C17.8444 31.7094 20.3678 33.2089 22.849 32.5774C24.4945 32.1586 25.7794 30.8737 26.1982 29.2282H32.186C32.8291 29.2282 33.3505 28.7069 33.3505 28.0637C33.3505 27.4206 32.8291 26.8993 32.186 26.8993ZM21.7055 30.3928C20.4193 30.3928 19.3766 29.35 19.3766 28.0638C19.3766 26.7775 20.4193 25.7348 21.7055 25.7348C22.9918 25.7348 24.0345 26.7775 24.0345 28.0638C24.0345 29.35 22.9918 30.3928 21.7055 30.3928Z"
              fill="#3C4CD1" />
          </g>
          <defs>
            <clipPath id="clip0_384_2340">
              <rect width="32.6059" height="32.6059" fill="white" transform="translate(0.744873 0.115967)" />
            </clipPath>
          </defs>
        </svg>
      </button>
      <div id="adjustmentPanel" class="adjustment-panel" style="display: none;">
          <div class="sliders-container"></div>
      </div>
    </div>
    

   
    </div>
  </div>

  <div id="visualizer_palette" class="palette-wrapper">
      <!-- Left Scroll Button -->
      <button id="scroll-left" class="btn btn-outline-info"><</button>
      <div class="palette-selector has-btns is-sortable has-picker is-lockable is-sortable has-picker is-lockable scroll-container" style="height: 100%;" data-colors="10">
          <div class="color-picker-container mt-1 rounded-2" style="width: fit-content;overflow: hidden;" id="image-color-pickers"></div>
      </div>
      <button id="scroll-right" class="btn btn-outline-info">></button>
  </div>
  <button type="button" class="btn btn-success2 shadow-lg">
    <svg width="20" height="20" viewBox="0 0 33 33" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path
        d="M19.3118 12.7204C20.2116 11.807 21.2664 11.3242 22.3622 11.3242H26.2204L24.7538 12.7908C24.6119 12.9327 24.4993 13.1012 24.4225 13.2867C24.3457 13.4721 24.3061 13.6708 24.3061 13.8716C24.3061 14.0723 24.3457 14.271 24.4225 14.4565C24.4993 14.6419 24.6119 14.8104 24.7538 14.9523C25.0404 15.239 25.4292 15.4 25.8346 15.4C26.0353 15.4 26.234 15.3605 26.4195 15.2837C26.6049 15.2068 26.7734 15.0943 26.9153 14.9523L30.9911 10.8766C31.133 10.7347 31.2456 10.5662 31.3224 10.3807C31.3992 10.1953 31.4388 9.99654 31.4388 9.79583C31.4388 9.59511 31.3992 9.39635 31.3224 9.21091C31.2456 9.02547 31.133 8.85698 30.9911 8.71505L26.9153 4.63932C26.7734 4.49739 26.6049 4.38481 26.4195 4.308C26.234 4.23118 26.0353 4.19165 25.8346 4.19165C25.6338 4.19165 25.4351 4.23118 25.2497 4.308C25.0642 4.38481 24.8957 4.49739 24.7538 4.63932C24.6119 4.78125 24.4993 4.94974 24.4225 5.13518C24.3457 5.32062 24.3061 5.51937 24.3061 5.72009C24.3061 5.92081 24.3457 6.11956 24.4225 6.305C24.4993 6.49044 24.6119 6.65893 24.7538 6.80086L26.2204 8.26742H22.3622C20.0744 8.26742 17.9771 9.41812 16.468 11.3292C17.1472 12.3407 17.6686 13.4496 18.0142 14.6179C18.3375 13.9172 18.7761 13.2758 19.3118 12.7204Z"
        fill="#3C4CD1" />
      <path
        d="M12.3627 20.1175C11.4628 21.0308 10.408 21.5136 9.31225 21.5136H3.41829C3.01294 21.5136 2.62418 21.6746 2.33755 21.9613C2.05092 22.2479 1.88989 22.6367 1.88989 23.042C1.88989 23.4474 2.05092 23.8361 2.33755 24.1228C2.62418 24.4094 3.01294 24.5704 3.41829 24.5704H9.31225C11.6 24.5704 13.6974 23.4197 15.2065 21.5086C14.5272 20.4972 14.0058 19.3883 13.66 18.22C13.3368 18.9206 12.8983 19.562 12.3627 20.1175Z"
        fill="#3C4CD1" />
      <path
        d="M26.9156 17.8854C26.7737 17.7434 26.6052 17.6309 26.4197 17.554C26.2343 17.4772 26.0355 17.4377 25.8348 17.4377C25.6341 17.4377 25.4354 17.4772 25.2499 17.554C25.0645 17.6309 24.896 17.7434 24.7541 17.8854C24.6121 18.0273 24.4995 18.1958 24.4227 18.3812C24.3459 18.5667 24.3064 18.7654 24.3064 18.9661C24.3064 19.1669 24.3459 19.3656 24.4227 19.551C24.4995 19.7365 24.6121 19.905 24.7541 20.0469L26.2207 21.5135H22.3625C21.2667 21.5135 20.2119 21.0307 19.3121 20.1173C18.3449 19.1357 17.6439 17.7197 17.3383 16.1302C16.4479 11.5006 13.1475 8.26733 9.31225 8.26733H3.41829C3.01294 8.26733 2.62418 8.42836 2.33755 8.71499C2.05092 9.00162 1.88989 9.39038 1.88989 9.79573C1.88989 10.2011 2.05092 10.5898 2.33755 10.8765C2.62418 11.1631 3.01294 11.3241 3.41829 11.3241H9.31225C10.408 11.3241 11.4628 11.8069 12.3627 12.7203C13.3298 13.7019 14.0307 15.1179 14.3364 16.7074C15.2268 21.3369 18.5272 24.5703 22.3625 24.5703H26.2207L24.7541 26.0368C24.4674 26.3235 24.3064 26.7122 24.3064 27.1176C24.3064 27.523 24.4674 27.9117 24.7541 28.1984C25.0407 28.485 25.4295 28.646 25.8348 28.646C26.2402 28.646 26.629 28.485 26.9156 28.1984L30.9913 24.1226C31.1333 23.9807 31.2459 23.8122 31.3227 23.6268C31.3995 23.4413 31.439 23.2426 31.439 23.0419C31.439 22.8412 31.3995 22.6424 31.3227 22.457C31.2459 22.2715 31.1333 22.103 30.9913 21.9611L26.9156 17.8854Z"
        fill="#3C4CD1" />
    </svg>
</button>


<div class="harmony-container">
  <button type="button" class="btn shadow-lg" id="harmonyButton">
    <svg width="20" height="20" viewBox="0 0 34 33" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path
        d="M7.69539 17.8844C6.91996 17.8844 6.46696 17.0055 6.91804 16.3738L9.19939 13.18L7.93224 8.66352C7.73201 7.94992 8.38976 7.28364 9.11004 7.48571L13.6265 8.75287L16.8203 6.47152C17.4513 6.02094 18.3309 6.47266 18.3309 7.24887V11.3504L22.0167 14.0551C22.6998 14.5563 22.4375 15.6362 21.601 15.7687L20.2474 15.9831L31.9226 26.3235C33.5103 27.7129 33.5925 30.1613 32.1001 31.6535C30.6084 33.1454 28.1582 33.0626 26.7737 31.4803L16.4296 19.8007L16.2153 21.1543C16.0828 21.9906 15.0027 22.2532 14.5016 21.57L11.7969 17.8843H7.69539V17.8844ZM28.2078 30.2179C28.8759 30.9815 30.0421 31.0098 30.7492 30.3026C31.4508 29.6011 31.4362 28.4367 30.6601 27.7575L22.3717 20.4168L20.8633 21.9252L28.2078 30.2179ZM19.5943 20.4923L20.9388 19.1478L17.8028 16.3703L16.9517 16.5051L16.8168 17.3563L19.5943 20.4923ZM13.0509 16.3639L14.6866 18.5929C16.1333 9.45991 13.753 24.4867 15.1732 15.5207C15.238 15.112 15.5586 14.7914 15.9673 14.7267C16.6508 14.6184 18.4071 14.3402 19.0395 14.24L16.8105 12.6043C16.5652 12.4244 16.4204 12.1384 16.4204 11.8342V9.10505L14.3646 10.5736C14.129 10.7418 13.8299 10.7943 13.5512 10.716L10.2311 9.78445L11.1626 13.1046C11.2408 13.3833 11.1884 13.6823 11.0202 13.9179L9.5517 15.9737H12.2808C12.585 15.9738 12.871 16.1186 13.0509 16.3639Z"
        fill="#3C4CD1" />
      <path
        d="M4.5745 3.55524H4.00133V4.12841C4.00133 4.65598 3.57361 5.0837 3.04604 5.0837C2.51847 5.0837 2.09076 4.65598 2.09076 4.12841V3.55524H1.51759C0.990013 3.55524 0.5623 3.12753 0.5623 2.59995C0.5623 2.07238 0.990013 1.64467 1.51759 1.64467H2.09076V1.0715C2.09076 0.543924 2.51847 0.116211 3.04604 0.116211C3.57361 0.116211 4.00133 0.543924 4.00133 1.0715V1.64467H4.5745C5.10207 1.64467 5.52979 2.07238 5.52979 2.59995C5.52979 3.12753 5.10214 3.55524 4.5745 3.55524Z"
        fill="#3C4CD1" />
      <path
        d="M14.8284 4.638H14.2552V5.21117C14.2552 5.73875 13.8275 6.16646 13.2999 6.16646C12.7724 6.16646 12.3447 5.73875 12.3447 5.21117V4.638H11.7715C11.2439 4.638 10.8162 4.21029 10.8162 3.68272C10.8162 3.15514 11.2439 2.72743 11.7715 2.72743H12.3447V2.15426C12.3447 1.62669 12.7724 1.19897 13.2999 1.19897C13.8275 1.19897 14.2552 1.62669 14.2552 2.15426V2.72743H14.8284C15.356 2.72743 15.7837 3.15514 15.7837 3.68272C15.7837 4.21029 15.356 4.638 14.8284 4.638Z"
        fill="#3C4CD1" />
      <path
        d="M5.08409 14.3818C5.08409 14.9094 4.65638 15.3371 4.12881 15.3371C3.60123 15.3371 3.17352 14.9094 3.17352 14.3818V13.8087H2.60035C2.07278 13.8087 1.64506 13.3809 1.64506 12.8534C1.64506 12.3258 2.07278 11.8981 2.60035 11.8981H3.17352V11.3249C3.17352 10.7973 3.60123 10.3696 4.12881 10.3696C4.65638 10.3696 5.08409 10.7973 5.08409 11.3249V11.8981H5.65726C6.18484 11.8981 6.61255 12.3258 6.61255 12.8534C6.61255 13.3809 6.18484 13.8087 5.65726 13.8087H5.08409V14.3818Z"
        fill="#3C4CD1" />
      <path
        d="M1.51759 21.0687H2.09076V20.4956C2.09076 19.968 2.51847 19.5403 3.04604 19.5403C3.57361 19.5403 4.00133 19.968 4.00133 20.4956V21.0687H4.5745C5.10207 21.0687 5.52979 21.4965 5.52979 22.024C5.52979 22.5516 5.10207 22.9793 4.5745 22.9793H4.00133V23.5525C4.00133 24.0801 3.57361 24.5078 3.04604 24.5078C2.51847 24.5078 2.09076 24.0801 2.09076 23.5525V22.9793H1.51759C0.990013 22.9793 0.5623 22.5516 0.5623 22.024C0.5623 21.4965 0.990013 21.0687 1.51759 21.0687Z"
        fill="#3C4CD1" />
      <path
        d="M23.9988 3.55524H23.4256V4.12841C23.4256 4.65598 22.9979 5.0837 22.4704 5.0837C21.9428 5.0837 21.5151 4.65598 21.5151 4.12841V3.55524H20.9419C20.4143 3.55524 19.9866 3.12753 19.9866 2.59995C19.9866 2.07238 20.4143 1.64467 20.9419 1.64467H21.5151V1.0715C21.5151 0.543924 21.9428 0.116211 22.4704 0.116211C22.9979 0.116211 23.4256 0.543924 23.4256 1.0715V1.64467H23.9988C24.5264 1.64467 24.9541 2.07238 24.9541 2.59995C24.9541 3.12753 24.5265 3.55524 23.9988 3.55524Z"
        fill="#3C4CD1" />
      <path
        d="M27.53 7.569L23.9636 9.60694C23.5076 9.86761 22.9232 9.71164 22.6602 9.25151C22.3985 8.79342 22.5576 8.20993 23.0157 7.94812L26.5821 5.91017C27.04 5.64849 27.6236 5.80758 27.8855 6.2656C28.1472 6.72376 27.988 7.30725 27.53 7.569Z"
        fill="#3C4CD1" />
      <path
        d="M29.6047 13.2993C29.5196 13.2993 29.8828 13.3415 25.4091 12.7823C24.8855 12.7169 24.5142 12.2394 24.5797 11.7159C24.6451 11.1923 25.1227 10.8204 25.6461 10.8865L29.722 11.396C30.2455 11.4614 30.6169 11.9389 30.5513 12.4624C30.491 12.9456 30.0795 13.2993 29.6047 13.2993Z"
        fill="#3C4CD1" />
      <path
        d="M8.3946 22.5692C8.65641 22.1111 9.23996 21.9519 9.69799 22.2137C10.156 22.4755 10.3152 23.059 10.0534 23.5171L8.01548 27.0835C7.83913 27.3921 7.51682 27.5651 7.18521 27.5651C6.46435 27.5651 5.989 26.7791 6.35666 26.1356L8.3946 22.5692Z"
        fill="#3C4CD1" />
      <path
        d="M12.1622 24.133C12.6859 24.0673 13.1632 24.439 13.2286 24.9624L13.7381 29.0383C13.8092 29.6067 13.3665 30.1121 12.789 30.1121C12.3143 30.1121 11.9027 29.7585 11.8424 29.2752L11.3329 25.1993C11.2673 24.6759 11.6387 24.1984 12.1622 24.133Z"
        fill="#3C4CD1" />
    </svg>
      Generate
  </button>
  <div class="harmony-menu" id="harmonyMenu" style="display: none;">
      <div class="menu-item" data-harmony="Monochromatic">Monochromatic</div>
      <div class="menu-item" data-harmony="Analogous">Analogous</div>
      <div class="menu-item" data-harmony="Complementary">Complementary</div>
      <div class="menu-item" data-harmony="Split Complementary">Split Complementary</div>
      <div class="menu-item" data-harmony="Triadic">Triadic</div>
      <div class="menu-item" data-harmony="Tetradic">Tetradic</div>
      <div class="menu-item" data-harmony="Square">Square</div>
  </div>
</div>

<div class="harmony-menu" id="harmonyMenu" style="display: none;">
  <div class="menu-item" data-harmony="Monochromatic">Monochromatic</div>
  <div class="menu-item" data-harmony="Analogous">Analogous</div>
  <div class="menu-item" data-harmony="Complementary">Complementary</div>
  <div class="menu-item" data-harmony="Split Complementary">Split Complementary</div>
  <div class="menu-item" data-harmony="Triadic">Triadic</div>
  <div class="menu-item" data-harmony="Tetradic">Tetradic</div>
  <div class="menu-item" data-harmony="Square">Square</div>
</div>

  <div id="visualizer_buttons" class="rounded-2 d-flex bg-linear-blue">
      <button type="button" class="btn btn-success4">
        <svg width="22" height="22" viewBox="0 0 33 32" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path
            d="M23.2749 28.3968C22.9097 28.803 22.4518 29.115 21.9402 29.3062C21.4286 29.4974 20.8784 29.5623 20.3363 29.4952H6.07123C3.57168 29.4952 2.50497 28.4285 2.50497 25.929V6.90888C2.50497 4.40932 3.57168 3.34261 6.07123 3.34261H14.3925V6.90888C14.2994 7.71194 14.3892 8.52565 14.655 9.28915C14.9207 10.0526 15.3557 10.7462 15.9274 11.3178C16.499 11.8895 17.1925 12.3244 17.956 12.5902C18.7195 12.856 19.5332 12.9457 20.3363 12.8527H23.9026V16.4189C23.9026 16.7342 24.0278 17.0366 24.2507 17.2595C24.4737 17.4824 24.7761 17.6077 25.0913 17.6077C25.4066 17.6077 25.709 17.4824 25.9319 17.2595C26.1548 17.0366 26.2801 16.7342 26.2801 16.4189V11.6639C26.2802 11.5078 26.2495 11.3532 26.1896 11.2091C26.1298 11.0649 26.042 10.934 25.9314 10.8239L16.4213 1.3138C16.3112 1.20317 16.1803 1.11541 16.0361 1.05557C15.892 0.995725 15.7374 0.96498 15.5813 0.965102H6.07123C5.26818 0.872024 4.45446 0.961736 3.69097 1.22753C2.92748 1.49332 2.23397 1.92831 1.66231 2.49996C1.09066 3.07161 0.655674 3.76512 0.389882 4.52862C0.12409 5.29211 0.0343773 6.10582 0.127455 6.90888V25.929C0.0343773 26.732 0.12409 27.5457 0.389882 28.3092C0.655674 29.0727 1.09066 29.7662 1.66231 30.3379C2.23397 30.9095 2.92748 31.3445 3.69097 31.6103C4.45446 31.8761 5.26818 31.9658 6.07123 31.8728H20.3363C21.2537 31.9506 22.1762 31.8025 23.0231 31.4414C23.87 31.0802 24.6155 30.5171 25.1944 29.8012C25.3806 29.5466 25.4581 29.2285 25.4098 28.9169C25.3615 28.6052 25.1913 28.3255 24.9368 28.1393C24.6823 27.953 24.3642 27.8756 24.0525 27.9239C23.7408 27.9722 23.4611 28.1423 23.2749 28.3968ZM16.77 6.90888V5.02431L22.2209 10.4751H20.3363C17.8367 10.4751 16.77 9.40844 16.77 6.90888ZM32.2714 23.599L29.1014 26.769C28.8761 26.979 28.578 27.0933 28.27 27.0879C27.9621 27.0825 27.6682 26.9577 27.4504 26.7399C27.2326 26.5221 27.1079 26.2283 27.1024 25.9203C27.097 25.6123 27.2113 25.3143 27.4213 25.0889L28.5609 23.9477H17.1663C16.851 23.9477 16.5486 23.8225 16.3257 23.5995C16.1028 23.3766 15.9775 23.0742 15.9775 22.759C15.9775 22.4437 16.1028 22.1413 16.3257 21.9184C16.5486 21.6954 16.851 21.5702 17.1663 21.5702H28.5609L27.4213 20.429C27.2113 20.2036 27.097 19.9056 27.1024 19.5976C27.1079 19.2897 27.2326 18.9958 27.4504 18.778C27.6682 18.5602 27.9621 18.4355 28.27 18.43C28.578 18.4246 28.8761 18.5389 29.1014 18.7489L32.2714 21.9189C32.3809 22.0302 32.4681 22.1615 32.5282 22.3056C32.6179 22.5227 32.6415 22.7615 32.5958 22.992C32.5501 23.2224 32.4372 23.4326 32.2714 23.599Z"
            fill="white" />
        </svg>
      </button>

  </div>
</footer>

<style>
.upload-wrapper {
  position: relative;
  display: inline-block;
  line-height: 0;
}
#fileInput {
  display: none;
}
#uploadForm {
  margin: 0 !important;
  padding: 0 !important;
  display: inline-block;
  line-height: 0;
}
button {
  margin: 0 !important;
  line-height: 1;
}
</style>

<script>
document.getElementById('fileInput').onchange = function() {
  if (this.files.length > 0) {
      document.getElementById('uploadForm').submit();
  }
};
</script>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script>

      </script>
    <script>


      document.addEventListener('DOMContentLoaded', function() {
        const trendingButton = document.getElementById('trendingButton');
        const secondaryColumn = document.getElementById('secondaryColumn');
    
        // Initially hide the secondary column
        secondaryColumn.style.display = 'none';
    
        trendingButton.addEventListener('click', function(e) {
            e.preventDefault();
            
            // Toggle the secondary column
            if (secondaryColumn.style.display === 'none') {
                secondaryColumn.style.display = 'flex';
                // If the sidebar is collapsed, uncollapse it
                if (secondaryColumn.classList.contains('collapsed')) {
                    const toggleButton = secondaryColumn.querySelector('button');
                    toggleSidebar('secondaryColumn', toggleButton);
                }
            } else {
                secondaryColumn.style.display = 'none';
            }
        });
    });


      // Function to toggle sidebar collapsed state and change the icon
      function toggleSidebar(id, button) {
        const sidebar = document.getElementById(id);
        const icon = button.querySelector("i");
        const mostLeftUl = sidebar.querySelectorAll(
          ".mostLeftUl li a .textSpan"
        );
        mostLeftUl.forEach((span) => {
          if (span.style.display === "none") {
            span.style.display = "inline"; // Show the span
          } else {
            span.style.display = "none"; // Hide the span
          }
        });

        sidebar.classList.toggle("collapsed");

        // Update the icon based on the collapse state
        if (sidebar.classList.contains("collapsed")) {

          icon.classList.remove("bi-caret-left-fill", "bi-caret-right-fill");
          icon.classList.add("bi-caret-right-fill");
          //mostLeftUl.style.display = "none";
        } else {

          icon.classList.remove("bi-caret-left-fill", "bi-caret-right-fill");
          icon.classList.add("bi-caret-left-fill");
          //mostLeftUl.style.display = "inline";
        }
      }
      function hideModal(){
        $('#colorPickerModal').modal('hide');
      }

      document.addEventListener('DOMContentLoaded', function() {
        const secondaryColumn = document.getElementById('secondaryColumn');
        const navButtons = document.querySelectorAll('.mostLeftUl li a');
        const inspirationButton = document.getElementById('inspirationButton');
        const contents = {
            trendingContent: document.getElementById('trendingContent'),
            inspirationContent: document.getElementById('inspirationContent'),
            ssCollectionContent: document.getElementById('ssCollectionContent'),
            awCollectionContent: document.getElementById('awCollectionContent'),
            baseColorContent: document.getElementById('baseColorContent'),
            effectsContent: document.getElementById('effectsContent')
        };
    
        // Function to show content
        function showContent(contentId) {
            // Hide all content sections
            Object.values(contents).forEach(content => {
                if (content) content.style.display = 'none';
            });
            
            // Show the selected content
            const selectedContent = document.getElementById(contentId);
            if (selectedContent) selectedContent.style.display = 'block';
        }
    
        // Function to handle active state
        function setActiveButton(activeButton) {
            navButtons.forEach(button => {
                button.classList.remove('active');
            });
            activeButton.classList.add('active');
        }
    
        // Effect application logic
        const effectItems = document.querySelectorAll('.effect-item');
        effectItems.forEach(item => {
            item.addEventListener('click', function() {
                const effect = this.dataset.effect;
                applyEffectToLayers(effect);
            });
        });
    
        // Initialize base colors
        generateBaseColors();
    
        // Add click handlers for all navigation buttons
        navButtons.forEach(button => {
            button.addEventListener('click', function(e) {
                e.preventDefault();
                setActiveButton(this);
                
                // Handle different sections
                const contentMap = {
                    'trendingButton': 'trendingContent',
                    'inspirationButton': 'inspirationContent',
                    'effectsButton': 'effectsContent',
                    'ssCollectionButton': 'ssCollectionContent',
                    'awCollectionButton': 'awCollectionContent',
                    'baseColorButton': 'baseColorContent',
                    'favoriteButton':'favCollectionContent'
                };
    
                const contentId = contentMap[this.id];
                
                if (contentId) {
                    secondaryColumn.style.display = 'flex';
                    showContent(contentId);
                    
                    // Special handling for base color content
                    if (this.id === 'baseColorButton') {
                        const basePalettesSection = document.querySelector('.base-palettes-section');
                        if (basePalettesSection) {
                            basePalettesSection.style.display = selectedBaseColor ? 'block' : 'none';
                        }
                    }
                } else {
                    // Hide secondary column for other buttons (favorite, etc.)
                    secondaryColumn.style.display = 'none';
                }
                
                // If the sidebar is collapsed, uncollapse it
                if (secondaryColumn.classList.contains('collapsed')) {
                    const toggleButton = secondaryColumn.querySelector('button');
                    toggleSidebar('secondaryColumn', toggleButton);
                }
            });
        });
    
        // Set initial state
        window.onload = function() {
            // Show Inspiration content by default
            secondaryColumn.style.display = 'flex';
            showContent('inspirationContent');
            setActiveButton(inspirationButton);
        };
    });
    const layerStates = {
      editedImages: {},
      originalImages: {},
      currentStates: {}, // Add this to track current states
      history: {}, // Add this to track state history
      maxHistoryLength: 10, // Maximum number of states to keep in history
  
      saveEditedState: function(layerIndex) {
          const canvas = document.getElementById(`layer_canvas_${layerIndex}`);
          if (canvas) {
              const dataUrl = canvas.toDataURL();
              this.editedImages[layerIndex] = dataUrl;
              
              // Add to history
              if (!this.history[layerIndex]) {
                  this.history[layerIndex] = [];
              }
              
              this.history[layerIndex].push(dataUrl);
              
              // Keep history within size limit
              if (this.history[layerIndex].length > this.maxHistoryLength) {
                  this.history[layerIndex].shift();
              }
              
              // Update current state
              this.currentStates[layerIndex] = dataUrl;
          }
      },
  
      saveOriginalState: function(layerIndex) {
          const canvas = document.getElementById(`layer_canvas_${layerIndex}`);
          if (canvas) {
              const dataUrl = canvas.toDataURL();
              this.originalImages[layerIndex] = dataUrl;
              
              // Initialize history with original state
              this.history[layerIndex] = [dataUrl];
              this.currentStates[layerIndex] = dataUrl;
          }
      },
  
      getEditedState: function(layerIndex) {
          return this.editedImages[layerIndex];
      },
  
      getOriginalState: function(layerIndex) {
          return this.originalImages[layerIndex];
      },
  
      getCurrentState: function(layerIndex) {
          return this.currentStates[layerIndex] || this.originalImages[layerIndex];
      },
  
      hasEditedState: function(layerIndex) {
          return !!this.editedImages[layerIndex];
      },
  
      hasOriginalState: function(layerIndex) {
          return !!this.originalImages[layerIndex];
      },
  
      // New methods for state management
      undoLastChange: function(layerIndex) {
          if (this.history[layerIndex] && this.history[layerIndex].length > 1) {
              this.history[layerIndex].pop(); // Remove current state
              const previousState = this.history[layerIndex][this.history[layerIndex].length - 1];
              this.currentStates[layerIndex] = previousState;
              this.applyState(layerIndex, previousState);
              return true;
          }
          return false;
      },
  
      resetToOriginal: function(layerIndex) {
          if (this.hasOriginalState(layerIndex)) {
              this.history[layerIndex] = [this.originalImages[layerIndex]];
              this.currentStates[layerIndex] = this.originalImages[layerIndex];
              this.applyState(layerIndex, this.originalImages[layerIndex]);
              return true;
          }
          return false;
      },
  
      applyState: function(layerIndex, state) {
          const canvas = document.getElementById(`layer_canvas_${layerIndex}`);
          if (canvas && state) {
              const ctx = canvas.getContext('2d');
              const img = new Image();
              img.onload = function() {
                  ctx.clearRect(0, 0, canvas.width, canvas.height);
                  ctx.drawImage(img, 0, 0);
              };
              img.src = state;
          }
      },
  
      // Method to check if we can undo
      canUndo: function(layerIndex) {
          return this.history[layerIndex] && this.history[layerIndex].length > 1;
      },
  
      // Method to get state history
      getHistory: function(layerIndex) {
          return this.history[layerIndex] || [];
      },
  
      // Method to clear all states for a layer
      clearStates: function(layerIndex) {
          delete this.editedImages[layerIndex];
          delete this.currentStates[layerIndex];
          this.history[layerIndex] = [];
          if (this.originalImages[layerIndex]) {
              this.history[layerIndex] = [this.originalImages[layerIndex]];
              this.currentStates[layerIndex] = this.originalImages[layerIndex];
          }
      },
  
      // Method to save intermediate state
      saveIntermediateState: function(layerIndex) {
          const canvas = document.getElementById(`layer_canvas_${layerIndex}`);
          if (canvas) {
              const dataUrl = canvas.toDataURL();
              if (!this.history[layerIndex]) {
                  this.history[layerIndex] = [];
              }
              this.history[layerIndex].push(dataUrl);
              this.currentStates[layerIndex] = dataUrl;
              
              // Keep history within size limit
              if (this.history[layerIndex].length > this.maxHistoryLength) {
                  this.history[layerIndex].shift();
              }
          }
      },
  
      // Method to restore to a specific state in history
      restoreToState: function(layerIndex, stateIndex) {
          if (this.history[layerIndex] && this.history[layerIndex][stateIndex]) {
              const state = this.history[layerIndex][stateIndex];
              this.currentStates[layerIndex] = state;
              this.applyState(layerIndex, state);
              // Trim history to this point
              this.history[layerIndex] = this.history[layerIndex].slice(0, stateIndex + 1);
              return true;
          }
          return false;
      }
  };

{% comment %} effect js  {% endcomment %}

document.addEventListener('DOMContentLoaded', function() {
  // Add effects button handler
  const effectsButton = document.getElementById('effectsButton');
  if (effectsButton) {
      effectsButton.addEventListener('click', function(e) {
          e.preventDefault();
          secondaryColumn.style.display = 'flex';
          showContent('effectsContent');
          if (secondaryColumn.classList.contains('collapsed')) {
              const toggleButton = secondaryColumn.querySelector('button');
              toggleSidebar('secondaryColumn', toggleButton);
          }
      });
  }

  // Effect application logic
  const effectItems = document.querySelectorAll('.effect-item');
  effectItems.forEach(item => {
      item.addEventListener('click', function() {
          const effect = this.dataset.effect;
          applyEffectToLayers(effect);
      });
  });
});

function applyEffectToLayers(effect) {
  const totalLayers = document.querySelectorAll('[id^="layer_canvas_"]').length;
  
  for (let layer = 1; layer <= totalLayers; layer++) {
      const colorButton = document.querySelector(`.color-picker[data-layer-index="${layer-1}"]`);
      if (colorButton && colorButton.dataset.locked === 'true') {
          console.log(`Layer ${layer} is locked, skipping effect`);
          continue;
      }

      const canvas = document.getElementById(`layer_canvas_${layer}`);
      if (!canvas) continue;

      const ctx = canvas.getContext('2d');
      if (!ctx) continue;

      if (!layerStates.hasOriginalState(layer)) {
          layerStates.saveOriginalState(layer);
      }

      switch(effect) {
          case 'grayscale':
              applyGrayscale(ctx, canvas.width, canvas.height);
              break;
          case 'sepia':
              applySepia(ctx, canvas.width, canvas.height);
              break;
          case 'brightness':
              applyBrightness(ctx, canvas.width, canvas.height, 1.5);
              break;
          case 'contrast':
              applyContrast(ctx, canvas.width, canvas.height, 1.5);
              break;
          case 'blur':
              applyBlur(ctx, canvas.width, canvas.height);
              break;
          case 'sharpen':
              applySharpen(ctx, canvas.width, canvas.height);
              break;
          case 'vintage':
              applyVintage(ctx, canvas.width, canvas.height);
              break;
          case 'colorize':
              applyColorize(ctx, canvas.width, canvas.height, '#ff6b6b');
              break;
          case 'duotone':
              applyDuotone(ctx, canvas.width, canvas.height, '#ff6b6b', '#4ecdc4');
              break;
          case 'noise':
              applyNoise(ctx, canvas.width, canvas.height, 20);
              break;
          case 'vignette':
              applyVignette(ctx, canvas.width, canvas.height);
              break;
          case 'posterize':
              applyPosterize(ctx, canvas.width, canvas.height, 4);
              break;
          case 'saturation':
              applySaturation(ctx, canvas.width, canvas.height, 1.5);
              break;
      }

      layerStates.saveEditedState(layer);
  }
}

function applyGrayscale(ctx, width, height) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  
  for (let i = 0; i < data.length; i += 4) {
      const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
      data[i] = avg;     // Red
      data[i + 1] = avg; // Green
      data[i + 2] = avg; // Blue
  }
  
  ctx.putImageData(imageData, 0, 0);
}

function applySepia(ctx, width, height) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  
  for (let i = 0; i < data.length; i += 4) {
      const r = data[i];
      const g = data[i + 1];
      const b = data[i + 2];
      
      data[i] = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189));
      data[i + 1] = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168));
      data[i + 2] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131));
  }
  
  ctx.putImageData(imageData, 0, 0);
}

function applyBrightness(ctx, width, height, factor) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  
  for (let i = 0; i < data.length; i += 4) {
      data[i] = Math.min(255, data[i] * factor);
      data[i + 1] = Math.min(255, data[i + 1] * factor);
      data[i + 2] = Math.min(255, data[i + 2] * factor);
  }
  
  ctx.putImageData(imageData, 0, 0);
}

function applyContrast(ctx, width, height, factor) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  
  for (let i = 0; i < data.length; i += 4) {
      for (let j = 0; j < 3; j++) {
          data[i + j] = ((data[i + j] - 128) * factor) + 128;
      }
  }
  
  ctx.putImageData(imageData, 0, 0);
}

function applyBlur(ctx, width, height) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  const kernel = [
      [1/9, 1/9, 1/9],
      [1/9, 1/9, 1/9],
      [1/9, 1/9, 1/9]
  ];
  
  const result = new Uint8ClampedArray(data.length);
  
  for (let y = 1; y < height - 1; y++) {
      for (let x = 1; x < width - 1; x++) {
          for (let c = 0; c < 3; c++) {
              let sum = 0;
              for (let ky = -1; ky <= 1; ky++) {
                  for (let kx = -1; kx <= 1; kx++) {
                      const idx = ((y + ky) * width + (x + kx)) * 4 + c;
                      sum += data[idx] * kernel[ky + 1][kx + 1];
                  }
              }
              result[(y * width + x) * 4 + c] = sum;
          }
          result[(y * width + x) * 4 + 3] = data[(y * width + x) * 4 + 3];
      }
  }
  
  imageData.data.set(result);
  ctx.putImageData(imageData, 0, 0);
}

function applySharpen(ctx, width, height) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  const kernel = [
      [0, -1, 0],
      [-1, 5, -1],
      [0, -1, 0]
  ];
  
  const result = new Uint8ClampedArray(data.length);
  
  for (let y = 1; y < height - 1; y++) {
      for (let x = 1; x < width - 1; x++) {
          for (let c = 0; c < 3; c++) {
              let sum = 0;
              for (let ky = -1; ky <= 1; ky++) {
                  for (let kx = -1; kx <= 1; kx++) {
                      const idx = ((y + ky) * width + (x + kx)) * 4 + c;
                      sum += data[idx] * kernel[ky + 1][kx + 1];
                  }
              }
              result[(y * width + x) * 4 + c] = Math.min(255, Math.max(0, sum));
          }
          result[(y * width + x) * 4 + 3] = data[(y * width + x) * 4 + 3];
      }
  }
  
  imageData.data.set(result);
  ctx.putImageData(imageData, 0, 0);
}

function applyVintage(ctx, width, height) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  
  for (let i = 0; i < data.length; i += 4) {
      const r = data[i];
      const g = data[i + 1];
      const b = data[i + 2];
      
      data[i] = r * 0.9 + 20;
      data[i + 1] = g * 0.7 + 20;
      data[i + 2] = b * 0.5 + 30;
  }
  
  ctx.putImageData(imageData, 0, 0);
}

function applyColorize(ctx, width, height, color) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  
  // Convert hex color to RGB
  const r = parseInt(color.substr(1,2), 16);
  const g = parseInt(color.substr(3,2), 16);
  const b = parseInt(color.substr(5,2), 16);
  
  for (let i = 0; i < data.length; i += 4) {
      const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
      data[i] = avg * (r / 255);
      data[i + 1] = avg * (g / 255);
      data[i + 2] = avg * (b / 255);
  }
  
  ctx.putImageData(imageData, 0, 0);
}

function applyDuotone(ctx, width, height, color1, color2) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  
  // Convert hex colors to RGB
  const r1 = parseInt(color1.substr(1,2), 16);
  const g1 = parseInt(color1.substr(3,2), 16);
  const b1 = parseInt(color1.substr(5,2), 16);
  
  const r2 = parseInt(color2.substr(1,2), 16);
  const g2 = parseInt(color2.substr(3,2), 16);
  const b2 = parseInt(color2.substr(5,2), 16);
  
  for (let i = 0; i < data.length; i += 4) {
      const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
      const t = avg / 255;
      
      data[i] = r1 + (r2 - r1) * t;
      data[i + 1] = g1 + (g2 - g1) * t;
      data[i + 2] = b1 + (b2 - b1) * t;
  }
  
  ctx.putImageData(imageData, 0, 0);
}

function applyNoise(ctx, width, height, amount) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  
  for (let i = 0; i < data.length; i += 4) {
      const noise = (Math.random() - 0.5) * amount;
      data[i] = Math.min(255, Math.max(0, data[i] + noise));
      data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + noise));
      data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + noise));
  }
  
  ctx.putImageData(imageData, 0, 0);
}

function applyVignette(ctx, width, height) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  const centerX = width / 2;
  const centerY = height / 2;
  const radius = Math.sqrt(centerX * centerX + centerY * centerY);
  
  for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
          const idx = (y * width + x) * 4;
          const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
          const vignette = 1 - Math.pow(distance / radius, 2);
          
          data[idx] *= vignette;
          data[idx + 1] *= vignette;
          data[idx + 2] *= vignette;
      }
  }
  
  ctx.putImageData(imageData, 0, 0);
}

function applyPosterize(ctx, width, height, levels) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  const step = 255 / (levels - 1);
  
  for (let i = 0; i < data.length; i += 4) {
      data[i] = Math.round(data[i] / step) * step;
      data[i + 1] = Math.round(data[i + 1] / step) * step;
      data[i + 2] = Math.round(data[i + 2] / step) * step;
  }
  
  ctx.putImageData(imageData, 0, 0);
}

function applySaturation(ctx, width, height, factor) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  
  for (let i = 0; i < data.length; i += 4) {
      const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
      data[i] = avg + (data[i] - avg) * factor;
      data[i + 1] = avg + (data[i + 1] - avg) * factor;
      data[i + 2] = avg + (data[i + 2] - avg) * factor;
  }
  
  ctx.putImageData(imageData, 0, 0);
}
{% comment %} effect js end  {% endcomment %}


{% comment %} for pdf {% endcomment %}
// Function to download PDF
function loadInspirationContent() {
  const inspirationContent = document.getElementById('inspirationContent');

  // Show loading state
  inspirationContent.innerHTML = '<div class="text-center"><div class="spinner-border" role="status"></div></div>';

  fetch('inspiration-pdfs/') // Update this URL to match your URL configuration
      .then(response => response.json())
      .then(data => {
          let htmlContent = `
              <h4 class="ms-auto me-auto">Inspirations</h4>
              <div class="inspiration-content">
                  <div class="pdf-grid">
          `;

          data.pdfs.forEach(pdf => {
              htmlContent += `
                  <div class="pdf-item">
                      <div class="pdf-preview" data-pdf-id="${pdf.id}">
                          <img src="${pdf.preview_image}" alt="${pdf.title}">
                          <div class="pdf-info">
                              <span class="pdf-name">${pdf.title}</span>
                              <div class="pdf-actions">
                                  <span class="pdf-likes">
                                      <i class="bi ${pdf.liked ? 'bi-heart-fill' : 'bi-heart'}"></i> 
                                      <span class="likes-count">${pdf.likes_count}</span>
                                  </span>
                                  <button class="btn btn-sm btn-primary download-btn">
                                      <i class="bi bi-download"></i>
                                  </button>
                              </div>
                          </div>
                      </div>
                  </div>
              `;
          });

          htmlContent += `
                  </div>
              </div>
          `;

          inspirationContent.innerHTML = htmlContent;
          initializePDFEvents(); // Call this after adding the content
      })
      .catch(error => {
          console.error('Error:', error);
          inspirationContent.innerHTML = '<div class="alert alert-danger">Error loading PDFs</div>';
      });
}

function toggleLike(pdfId, element) {
  fetch('inspiration-pdfs/', {
      method: 'POST',
      headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'X-CSRFToken': getCookie('csrftoken'),
      },
      body: `pdf_id=${pdfId}`
  })
  .then(response => response.json())
  .then(data => {
      // Update the like button and count based on the response
      element.className = data.liked ? 'bi bi-heart-fill' : 'bi-heart';
      element.closest('.pdf-likes').querySelector('.likes-count').textContent = data.likes_count;
  })
  .catch(error => console.error('Error:', error));
}

function getCookie(name) {
  let cookieValue = null;
  if (document.cookie && document.cookie !== '') {
      const cookies = document.cookie.split(';');
      for (let i = 0; i < cookies.length; i++) {
          const cookie = cookies[i].trim();
          if (cookie.substring(0, name.length + 1) === (name + '=')) {
              cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
              break;
          }
      }
  }
  return cookieValue;
}

function downloadPDF(pdfUrl, title) {
  fetch(pdfUrl)
      .then(response => response.blob())
      .then(blob => {
          const url = window.URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = title;
          document.body.appendChild(a);
          a.click();
          window.URL.revokeObjectURL(url);
          document.body.removeChild(a);
      })
      .catch(error => {
          console.error('Error downloading PDF:', error);
          alert('Error downloading the PDF');
      });
}

function initializePDFEvents() {
  document.querySelectorAll('.pdf-likes i').forEach(element => {
      element.addEventListener('click', function(e) {
          e.stopPropagation();
          const pdfId = this.closest('.pdf-preview').dataset.pdfId;
          toggleLike(pdfId, this);
      });
  });

  document.querySelectorAll('.download-btn').forEach(button => {
      button.addEventListener('click', function(e) {
          e.stopPropagation();
          const pdfPreview = this.closest('.pdf-preview');
          const pdfUrl = pdfPreview.dataset.pdfUrl; // Make sure to add this data attribute in your HTML
          const title = pdfPreview.querySelector('.pdf-name').textContent;
          downloadPDF(pdfUrl, title);
      });
  });
}

// Call this function when the page loads
loadInspirationContent();

// Call this function when inspiration button is clicked
document.getElementById('inspirationButton').addEventListener('click', function(e) {
  e.preventDefault();
  loadInspirationContent();
});
{% comment %} end pdf  {% endcomment %}

{% comment %} for base color  {% endcomment %}


// Function to convert RGB to HSV
function rgbToHsvBase(r, g, b) {
  r = r / 255;
  g = g / 255;
  b = b / 255;
  
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const diff = max - min;
  
  let h = 0;
  let s = max === 0 ? 0 : diff / max;
  let v = max;
  
  if (max === min) {
      h = 0;
  } else if (max === r) {
      h = (60 * ((g - b) / diff) + 360) % 360;
  } else if (max === g) {
      h = (60 * ((b - r) / diff) + 120) % 360;
  } else {
      h = (60 * ((r - g) / diff) + 240) % 360;
  }
  
  return [h, s, v];
}

function getColorName(rgb) {
  const [r, g, b] = rgb;
  
  function getHueName(h) {
      if (h < 15 || h >= 345) return "Red";
      if (h >= 15 && h < 45) return "Orange";
      if (h >= 45 && h < 75) return "Yellow";
      if (h >= 75 && h < 165) return "Green";
      if (h >= 165 && h < 195) return "Cyan";
      if (h >= 195 && h < 255) return "Blue";
      if (h >= 255 && h < 285) return "Purple";
      if (h >= 285 && h < 345) return "Pink";
  }

  function getShadePrefix(s, v) {
      if (v < 0.2) return "Dark";
      if (v > 0.8) return "Light";
      if (s < 0.2) return "Gray";
      if (s > 0.8) return "Vivid";
      return "";
  }

  // Convert RGB to HSV
  const rNorm = r / 255;
  const gNorm = g / 255;
  const bNorm = b / 255;
  const max = Math.max(rNorm, gNorm, bNorm);
  const min = Math.min(rNorm, gNorm, bNorm);
  const diff = max - min;

  // Calculate Hue
  let h = 0;
  if (max !== min) {
      if (max === rNorm) {
          h = (60 * ((gNorm - bNorm) / diff) + 360) % 360;
      } else if (max === gNorm) {
          h = (60 * ((bNorm - rNorm) / diff) + 120) % 360;
      } else {
          h = (60 * ((rNorm - gNorm) / diff) + 240) % 360;
      }
  }

  // Calculate Saturation
  const s = max === 0 ? 0 : diff / max;

  // Value
  const v = max;

  // Special cases for grayscale
  if (s < 0.1) {
      if (v < 0.2) return "Black";
      if (v < 0.4) return "Dark Gray";
      if (v < 0.6) return "Gray";
      if (v < 0.8) return "Light Gray";
      return "White";
  }

  const hueName = getHueName(h);
  const shadePrefix = getShadePrefix(s, v);

  return shadePrefix ? `${shadePrefix} ${hueName}` : hueName;
}

const style = document.createElement('style');
style.textContent = `
.base-colors-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 10px;
  padding: 15px;
}

.base-color-block {
  {% comment %} aspect-ratio: 3/1; {% endcomment %}
  border-radius: 8px;
  cursor: pointer;
  transition: transform 0.2s;
  border: 1px solid #ddd;
  position: relative;
  display: flex;
  align-items: center;
  padding: 10px;
  height: 8rem
}

.base-color-block:hover {
  transform: scale(1.02);
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.color-name {
  color: white;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
  font-size: 14px;
  font-weight: bold;
}

.base-palettes-section {
  margin-top: 20px;
  display: none;
}
`;
document.head.appendChild(style);

// Modified generateBaseColors function
function generateBaseColors() {
  const baseColorsGrid = document.querySelector('.base-colors-grid');
  const baseColors = [
    { rgb: [128, 0, 128], name: "Purple" },    // Purple
    { rgb: [173, 255, 47], name: "Green" },    // Light Green
    { rgb: [255, 69, 0], name: "Red" },        // Red-Orange
    { rgb: [139, 69, 19], name: "Brown" },     // Brown
    { rgb: [255, 0, 0], name: "Red" },         // Bright Red
    { rgb: [105, 105, 105], name: "Dark Gray" },// Dark Gray
    { rgb: [255, 20, 147], name: "Pink" },     // Pink
    { rgb: [139, 69, 19], name: "Brown" },     // Brown
    { rgb: [0, 255, 0], name: "Neon Green" },  // Neon Green
    { rgb: [0, 191, 255], name: "Blue" }       // Sky Blue
  ];
  
  baseColorsGrid.innerHTML = '';
  
  baseColors.forEach(({rgb, name}) => {
    const colorBlock = document.createElement('div');
    colorBlock.className = 'base-color-block';
    colorBlock.style.backgroundColor = `rgb(${rgb.join(',')})`;
    
    colorBlock.innerHTML = `<div class="color-name">${name}</div>`;
    
    colorBlock.addEventListener('click', () => selectBaseColor(rgb));
    baseColorsGrid.appendChild(colorBlock);
  });

  // Initially hide the palettes section
  const basePalettesSection = document.querySelector('.base-palettes-section');
  if (basePalettesSection) {
    basePalettesSection.style.display = 'none';
  }
}

// Modified selectBaseColor function
function selectBaseColor(color) {
  selectedBaseColor = color;
  
  // Hide the base colors grid
  const baseColorsGrid = document.querySelector('.base-colors-grid');
  baseColorsGrid.style.display = 'none';
  
  // Show the palettes section
  const basePalettesSection = document.querySelector('.base-palettes-section');
  basePalettesSection.style.display = 'block';
  
  // Change the header text to indicate selected color
  const headerElement = document.querySelector('#baseColorContent h4');
  const colorName = getColorName(color);
  headerElement.textContent = `Palettes for ${colorName}`;
  
  // Add a back button next to the header
  if (!document.querySelector('.back-to-base-colors')) {
      const backButton = document.createElement('button');
      backButton.className = 'btn btn-sm btn-outline-secondary back-to-base-colors ms-2';
      backButton.innerHTML = '<i class="bi bi-arrow-left"></i> Back to Colors';
      backButton.onclick = resetBaseColorView;
      headerElement.parentElement.insertBefore(backButton, headerElement.nextSibling);
  }
  
  // Generate palettes based on the selected color
  generatePalettesFromBaseColor(color);

  // Add event listeners for shuffle buttons
  document.querySelectorAll('[id^="base_shufflePalette_"]').forEach(button => {
      const layerIndex = button.id.split('_').pop();
      button.addEventListener('click', () => shufflePalette(layerIndex, 'base'));
  });
}
// Modified generatePalettesFromBaseColor function
function generatePalettesFromBaseColor(baseColor) {
  const numLayers = 7; // Number of palettes
  const paletteTypes = [
    'complementary',
    'analogous',
    'triadic',
    'split-complementary',
    'tetradic',
    'monochromatic',
    'shades'
  ];
  
  for (let i = 1; i <= numLayers; i++) {
    const colors = generateColorPaletteFromBase(baseColor, paletteTypes[i-1]);
    window.basePaletteColors = window.basePaletteColors || {};
    window.basePaletteColors[i] = colors;
    console.log(rgbColors,'rgb1');
    displayColorPalette(i, colors, 'base');
  }
}

// Modified generateColorPaletteFromBase function
function generateColorPaletteFromBase(baseColor, paletteType) {
  const [h, s, v] = rgbToHsvBase(...baseColor);
  const palette = [];
  
  switch(paletteType) {
    case 'complementary':
      // Base color and its complement
      palette.push(hsvToRgbBase(h, s, v)); // Base color
      palette.push(hsvToRgbBase((h + 180) % 360, s, v)); // Complement
      // Add variations
      palette.push(hsvToRgbBase(h, s * 0.8, v * 1.1));
      palette.push(hsvToRgbBase((h + 180) % 360, s * 0.8, v * 1.1));
      palette.push(hsvToRgbBase(h, s * 0.6, v * 1.2));
      palette.push(hsvToRgbBase((h + 180) % 360, s * 0.6, v * 1.2));
      break;

    case 'analogous':
      // Base color and adjacent colors
      for (let i = -2; i <= 2; i++) {
        palette.push(hsvToRgbBase((h + i * 30 + 360) % 360, s, v));
      }
      palette.push(hsvToRgbBase((h + 60) % 360, s * 0.8, v));
      break;

    case 'triadic':
      // Three colors equally spaced around the color wheel
      palette.push(hsvToRgbBase(h, s, v));
      palette.push(hsvToRgbBase((h + 120) % 360, s, v));
      palette.push(hsvToRgbBase((h + 240) % 360, s, v));
      // Add variations
      palette.push(hsvToRgbBase(h, s * 0.8, v * 1.1));
      palette.push(hsvToRgbBase((h + 120) % 360, s * 0.8, v * 1.1));
      palette.push(hsvToRgbBase((h + 240) % 360, s * 0.8, v * 1.1));
      break;

    case 'split-complementary':
      // Base color and two colors adjacent to its complement
      palette.push(hsvToRgbBase(h, s, v));
      palette.push(hsvToRgbBase((h + 150) % 360, s, v));
      palette.push(hsvToRgbBase((h + 210) % 360, s, v));
      palette.push(hsvToRgbBase(h, s * 0.8, v * 1.1));
      palette.push(hsvToRgbBase((h + 150) % 360, s * 0.8, v * 1.1));
      palette.push(hsvToRgbBase((h + 210) % 360, s * 0.8, v * 1.1));
      break;

    case 'tetradic':
      // Four colors forming a rectangle on the color wheel
      palette.push(hsvToRgbBase(h, s, v));
      palette.push(hsvToRgbBase((h + 90) % 360, s, v));
      palette.push(hsvToRgbBase((h + 180) % 360, s, v));
      palette.push(hsvToRgbBase((h + 270) % 360, s, v));
      palette.push(hsvToRgbBase(h, s * 0.8, v * 1.1));
      palette.push(hsvToRgbBase((h + 180) % 360, s * 0.8, v * 1.1));
      break;

    case 'monochromatic':
      // Same hue, different saturation and value
      for (let i = 0; i < 6; i++) {
        palette.push(hsvToRgbBase(
          h,
          Math.max(0.2, Math.min(1, s * (0.5 + i * 0.1))),
          Math.max(0.2, Math.min(1, v * (0.5 + i * 0.1)))
        ));
      }
      break;

    case 'shades':
      // Different shades and tints of the base color
      for (let i = 0; i < 6; i++) {
        palette.push(hsvToRgbBase(
          h,
          s,
          Math.max(0.2, Math.min(1, v * (0.4 + i * 0.12)))
        ));
      }
      break;
  }
  
  // Ensure all values are within valid RGB range
  return palette.map(color => color.map(c => Math.min(255, Math.max(0, Math.round(c)))));
}


// Function to convert HSV to RGB
function hsvToRgbBase(h, s, v) {
  let r, g, b;
  const i = Math.floor(h / 60);
  const f = h / 60 - i;
  const p = v * (1 - s);
  const q = v * (1 - f * s);
  const t = v * (1 - (1 - f) * s);
  
  switch (i % 6) {
      case 0: [r, g, b] = [v, t, p]; break;
      case 1: [r, g, b] = [q, v, p]; break;
      case 2: [r, g, b] = [p, v, t]; break;
      case 3: [r, g, b] = [p, q, v]; break;
      case 4: [r, g, b] = [t, p, v]; break;
      case 5: [r, g, b] = [v, p, q]; break;
  }
  
  return [
      Math.round(r * 255),
      Math.round(g * 255),
      Math.round(b * 255)
  ];
}
// Function to reset the base color view
function resetBaseColorView() {
  // Show the base colors grid
  const baseColorsGrid = document.querySelector('.base-colors-grid');
  baseColorsGrid.style.display = 'grid';
  
  // Hide the palettes section
  const basePalettesSection = document.querySelector('.base-palettes-section');
  basePalettesSection.style.display = 'none';
  
  // Reset the header
  const headerElement = document.querySelector('#baseColorContent h4');
  headerElement.textContent = 'Base Colors';
  
  // Remove the back button
  const backButton = document.querySelector('.back-to-base-colors');
  if (backButton) {
      backButton.remove();
  }
}

// Add some CSS for the back button
const backButtonStyle = document.createElement('style');
backButtonStyle.textContent = `
.back-to-base-colors {
  padding: 0.25rem 0.5rem;
  font-size: 0.875rem;
  margin-bottom: 1rem;
}

#baseColorContent h4 {
  margin-bottom: 0.5rem;
}
`;
document.head.appendChild(backButtonStyle);

// Initialize base colors when the page loads
document.addEventListener('DOMContentLoaded', () => {
  generateBaseColors();
  const baseColorButton = document.getElementById('baseColorButton');
  if (baseColorButton) {
      baseColorButton.addEventListener('click', function(e) {
          e.preventDefault();
          setActiveButton(this);
          secondaryColumn.style.display = 'flex';
          showContent('baseColorContent');
          
          // Reset to show base colors when the button is clicked
          resetBaseColorView();
      });
  }
});
{% comment %} base color end  {% endcomment %}


{% comment %} for generating random color pallete  {% endcomment %}
// Function to generate varied colors with preserved relationships but shifted hues
function generateCorrelatedPalettes(distinctColors, collection = 'trending') {
    // Convert RGB array to HSL
    function rgbToHsl(r, g, b) {
      r /= 255; g /= 255; b /= 255;
      const max = Math.max(r, g, b), min = Math.min(r, g, b);
      let h, s, l = (max + min) / 2;
  
      if (max === min) {
        h = s = 0; // achromatic
      } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
          case g: h = ((b - r) / d + 2) / 6; break;
          case b: h = ((r - g) / d + 4) / 6; break;
        }
      }
      return [h, s, l];
    }
  
    // Convert HSL to RGB
    function hslToRgb(h, s, l) {
      let r, g, b;
  
      if (s === 0) {
        r = g = b = l; // achromatic
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1; if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        };
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }
  
      return [
        Math.round(r * 255),
        Math.round(g * 255),
        Math.round(b * 255)
      ];
    }
  
    // Create a palette with shifted hue while preserving relationships
    function createShiftedPalette(colors, hueShift) {
      return colors.map(color => {
        const [h, s, l] = rgbToHsl(color[0], color[1], color[2]);
        
        // Shift the hue while preserving saturation and lightness
        let newHue = (h + hueShift) % 1.0;
        if (newHue < 0) newHue += 1.0;
        
        // Apply collection-specific adjustments
        let newS = s;
        let newL = l;
        
        if (collection === 'ss') {
          // Spring/Summer: Brighter, more saturated
          newS = Math.min(1, s * 1.1);
          newL = Math.min(0.9, l * 1.15);
        } else if (collection === 'aw') {
          // Autumn/Winter: Deeper, more muted
          newS = Math.max(0, s * 0.9);
          newL = Math.max(0.1, l * 0.85);
        }
        
        return hslToRgb(newHue, newS, newL);
      });
    }
    
    // Generate multiple palette variations based on color theory
    const palettes = [];
    
    // Complementary palette (180° hue shift)
    palettes.push(createShiftedPalette(distinctColors, 0.5));
    
    // Analogous palettes (30° and -30° hue shifts)
    palettes.push(createShiftedPalette(distinctColors, 0.083));
    palettes.push(createShiftedPalette(distinctColors, -0.083));
    
    // Triadic palettes (120° and 240° hue shifts)
    palettes.push(createShiftedPalette(distinctColors, 0.33));
    palettes.push(createShiftedPalette(distinctColors, 0.67));
    
    // Split-complementary palettes
    palettes.push(createShiftedPalette(distinctColors, 0.42));
    palettes.push(createShiftedPalette(distinctColors, 0.58));
    
    // Season-inspired shifts
    if (collection === 'ss') {
      // Spring/Summer: Shift toward yellow-green
      palettes.push(createShiftedPalette(distinctColors, 0.2));
      palettes.push(createShiftedPalette(distinctColors, 0.25));
    } else if (collection === 'aw') {
      // Autumn/Winter: Shift toward orange-red
      palettes.push(createShiftedPalette(distinctColors, -0.08));
      palettes.push(createShiftedPalette(distinctColors, -0.04));
    }
    
    // Add some random creative shifts
    for (let i = 0; i < 2; i++) {
      palettes.push(createShiftedPalette(distinctColors, Math.random()));
    }
    
    return palettes;
  }
  
  // Modified displayColorPalette function to use the correlated palettes
  function displayColorPalette(layerIndex, colors, collection = 'trending', maxVisibleColors = 6, totalLayers = 1) {
    const prefix = collection + '_';
    
    // Helper functions for color manipulation
    function rgbToHsl(r, g, b) {
        r /= 255;
        g /= 255;
        b /= 255;
        
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;

        if (max === min) {
            h = s = 0;
        } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            
            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }

        return [h * 360, s * 100, l * 100];
    }

    function hslToRgb(h, s, l) {
        h /= 360;
        s /= 100;
        l /= 100;

        let r, g, b;

        if (s === 0) {
            r = g = b = l;
        } else {
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            };

            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;

            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
        }

        return [
            Math.round(r * 255),
            Math.round(g * 255),
            Math.round(b * 255)
        ];
    }

    function generateCorrelatedPalette(baseColors) {
        // Analyze the base colors to understand their relationships
        const hslColors = baseColors.map(color => rgbToHsl(...color));
        
        // Calculate average hue and its standard deviation
        const hues = hslColors.map(hsl => hsl[0]);
        const avgHue = hues.reduce((a, b) => a + b, 0) / hues.length;
        
        // Generate different hue shift patterns
        const hueShiftPatterns = [
            // Complementary (180 degree shift)
            () => (h) => (h + 180) % 360,
            // Triadic (120 degree shift)
            () => (h) => (h + 120) % 360,
            // Split-complementary
            () => (h) => (h + 150) % 360,
            // Analogous
            () => (h) => (h + 30) % 360
        ];

        // Create multiple palettes using different patterns
        return hueShiftPatterns.map(getShift => {
            const hueShift = getShift();
            
            return hslColors.map(([h, s, l]) => {
                // Shift the hue while preserving saturation and lightness
                const newHue = hueShift(h);
                // Maintain the same saturation pattern
                const newSat = s;
                // Maintain the same lightness pattern
                const newLight = l;
                
                return hslToRgb(newHue, newSat, newLight);
            });
        });
    }

    if (totalLayers === 1) {
        // Generate multiple palettes for single layer
        for (let i = 0; i < 10; i++) {
            const paletteContainer = document.getElementById(`${prefix}colorPalette_${i}`);
            if (!paletteContainer) continue;
            
            paletteContainer.innerHTML = '';
            
            // Generate correlated palettes
            const correlatedPalettes = generateCorrelatedPalette([...colors]);
            
            // Select one of the generated palettes
            const selectedPalette = correlatedPalettes[i % correlatedPalettes.length];
            
            // Apply collection-specific adjustments
            let adjustedColors = [...selectedPalette];
            
            if (collection === 'ss') {
                adjustedColors = adjustedColors.map(color => {
                    const [h, s, l] = rgbToHsl(...color);
                    return hslToRgb(h, Math.min(100, s * 1.2), Math.min(100, l * 1.1));
                });
            } else if (collection === 'aw') {
                adjustedColors = adjustedColors.map(color => {
                    const [h, s, l] = rgbToHsl(...color);
                    return hslToRgb(h, s * 0.9, l * 0.85);
                });
            }

            // Store and render the palette
            window[`${collection}PaletteColors`] = window[`${collection}PaletteColors`] || {};
            window[`${collection}PaletteColors`][i] = adjustedColors;
        
        window[`${collection}PaletteColors`] = window[`${collection}PaletteColors`] || {};
        window[`${collection}PaletteColors`][i] = adjustedColors;
        
        window.paletteToggleState = window.paletteToggleState || {};
        window.paletteToggleState[i] = false;
  
        // Render function for each palette
        const renderPalette = (container, colors, index) => {
          container.innerHTML = '';
          const isExpanded = window.paletteToggleState[index];
          const colorsToDisplay = isExpanded ? colors : colors.slice(0, maxVisibleColors);
          const remainingColorsCount = colors.length - maxVisibleColors;
  
          colorsToDisplay.forEach((color) => {
            const swatch = document.createElement('div');
            swatch.classList.add('color-swatch');
            swatch.style.backgroundColor = `rgb(${color.join(',')})`;
            swatch.title = `rgb(${color.join(',')})`;
            
            if (collection === 'ss') {
              swatch.classList.add('ss-swatch');
            } else if (collection === 'aw') {
              swatch.classList.add('aw-swatch');
            }
            
            container.appendChild(swatch);
          });
  
          if (remainingColorsCount > 0) {
            const toggleLabel = document.createElement('div');
            toggleLabel.classList.add('toggle-colors-label');
            toggleLabel.innerHTML = isExpanded
              ? '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-file-minus" viewBox="0 0 16 16"><path d="M5.5 8a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 0 1H6a.5.5 0 0 1-.5-.5"/><path d="M4 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2zm0 1h8a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1"/></svg>'
              : `<span class="mx-1" style="font-weight:bold;color:red;">${remainingColorsCount}</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-file-plus" viewBox="0 0 16 16"><path d="M8.5 6a.5.5 0 0 0-1 0v1.5H6a.5.5 0 0 0 0 1h1.5V10a.5.5 0 0 0 1 0V8.5H10a.5.5 0 0 0 0-1H8.5z"/><path d="M2 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2zm10-1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1"/></svg>`;
  
            toggleLabel.addEventListener('click', () => {
              window.paletteToggleState[index] = !window.paletteToggleState[index];
              renderPalette(container, colors, index);
            });
  
            container.appendChild(toggleLabel);
          }
        };
  
        // Initial render for each palette
        renderPalette(paletteContainer, adjustedColors, i);
      }
    } else {
      // Original multi-layer logic remains the same
      const paletteContainer = document.getElementById(`${prefix}colorPalette_${layerIndex}`);
      if (!paletteContainer) return;
      
      let adjustedColors = [...colors];
      
      if (collection === 'ss') {
        adjustedColors = adjustedColors.map(color => {
          return color.map(component => Math.min(255, Math.floor(component * 1.2)));
        });
      } else if (collection === 'aw') {
        adjustedColors = adjustedColors.map(color => {
          return color.map(component => Math.floor(component * 0.85));
        });
      }
  
      window.originalPaletteColors = window.originalPaletteColors || {};
      window.originalPaletteColors[`${prefix}${layerIndex}`] = [...colors];
      
      window[`${collection}PaletteColors`] = window[`${collection}PaletteColors`] || {};
      window[`${collection}PaletteColors`][layerIndex] = adjustedColors;
      
      window.paletteToggleState = window.paletteToggleState || {};
      window.paletteToggleState[layerIndex] = false;
  
      const renderPalette = (container, colors, index) => {
        container.innerHTML = '';
        const isExpanded = window.paletteToggleState[index];
        const colorsToDisplay = isExpanded ? colors : colors.slice(0, maxVisibleColors);
        const remainingColorsCount = colors.length - maxVisibleColors;
  
        colorsToDisplay.forEach((color) => {
          const swatch = document.createElement('div');
          swatch.classList.add('color-swatch');
          swatch.style.backgroundColor = `rgb(${color.join(',')})`;
          swatch.title = `rgb(${color.join(',')})`;
          
          if (collection === 'ss') {
            swatch.classList.add('ss-swatch');
          } else if (collection === 'aw') {
            swatch.classList.add('aw-swatch');
          }
          
          container.appendChild(swatch);
        });
  
        if (remainingColorsCount > 0) {
          const toggleLabel = document.createElement('div');
          toggleLabel.classList.add('toggle-colors-label');
          toggleLabel.innerHTML = isExpanded
            ? '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-file-minus" viewBox="0 0 16 16"><path d="M5.5 8a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 0 1H6a.5.5 0 0 1-.5-.5"/><path d="M4 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2zm0 1h8a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1"/></svg>'
            : `<span class="mx-1" style="font-weight:bold;color:red;">${remainingColorsCount}</span> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-file-plus" viewBox="0 0 16 16"><path d="M8.5 6a.5.5 0 0 0-1 0v1.5H6a.5.5 0 0 0 0 1h1.5V10a.5.5 0 0 0 1 0V8.5H10a.5.5 0 0 0 0-1H8.5z"/><path d="M2 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2zm10-1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1"/></svg>`;
  
          toggleLabel.addEventListener('click', () => {
            window.paletteToggleState[index] = !window.paletteToggleState[index];
            renderPalette(container, colors, index);
          });
  
          container.appendChild(toggleLabel);
        }
      };
  
      renderPalette(paletteContainer, adjustedColors, layerIndex);
    }
  }
// Initialize UI and event listeners
document.addEventListener('DOMContentLoaded', function() {
  const totalLayers = {{ layers|length }};
  const collections = ['trending', 'ss', 'aw', 'base'];
  
  collections.forEach(collection => {
      for (let i = 1; i <= totalLayers; i++) {
          const shuffleButton = document.getElementById(`${collection}_shufflePalette_${i}`);
          if (shuffleButton) {
              shuffleButton.addEventListener('click', () => shufflePalette(i, collection));
          }
      }
  });
});

    document.addEventListener('DOMContentLoaded', function() {
      const totalLayers = {{ layers|length }};
      const collections = ['trending', 'ss', 'aw','base'];
      
      collections.forEach(collection => {
          for (let i = 1; i <= totalLayers; i++) {
              const shuffleButton = document.getElementById(`${collection}_shufflePalette_${i}`);
              if (shuffleButton) {
                  shuffleButton.addEventListener('click', () => shufflePalette(i, collection));
              }
          }
      });
  });



    
      function loadZoomValue(){
        //document.getElementById('zoomWrapper').style.transform = `scale(${0.072})`;
        document.getElementById('zoomWrapper').style.transform = `scale(${0.3})`;
      }
      document.addEventListener('DOMContentLoaded', loadZoomValue);
      document.getElementById('zoomSlider').addEventListener('input', function() {
        const zoomLevel = this.value / 100;
        //const zoomLevel = 0.3;

        document.getElementById('zoomWrapper').style.transform = `scale(${zoomLevel})`;
      });

      function toggleLayer(layerIndex) {
        const layerDiv = document.getElementById(`layer_${layerIndex}`);
        const checkbox = document.getElementById(`toggleLayer${layerIndex}`);
        layerDiv.style.display = checkbox.checked ? 'block' : 'none';
      }

      // Analyze the image data to calculate layer-specific parameters
      function analyzeImageLayer(ctx) {
        const imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
        const data = imageData.data;

        let totalLightness = 0;
        let totalHue = 0;
        let pixelCount = 0;

        const hues = [];

        for (let i = 0; i < data.length; i += 4) {
            // Ignore fully transparent pixels
            if (data[i + 3] === 0) continue;

            const rgb = [data[i], data[i + 1], data[i + 2]];
            const hsl = rgbToHsl(rgb[0], rgb[1], rgb[2]);

            totalLightness += hsl[2];
            totalHue += hsl[0];
            hues.push(hsl[0]);
            pixelCount++;
        }

        // Handle cases where no valid pixels were processed
        if (pixelCount === 0) {
            return {
                avgLightness: 0,
                avgHue: 0,
                hueRange: 0,
                lightnessTolerance: 0,
                hueTolerance: 0,
            };
        }

        const avgLightness = totalLightness / pixelCount;
        const avgHue = totalHue / pixelCount;

        let hueRange = calculateHueRange(hues);

        const lightnessTolerance = Math.min(0.5, avgLightness * 0.5); // Adjusted scaling
        const hueTolerance = Math.min(40, hueRange * 0.5);            // Adjusted scaling

        return {
            avgLightness,
            avgHue,
            hueRange,
            lightnessTolerance,
            hueTolerance,
        };
      }

      function analyzeImageLayerforsingle(ctx) {
         const imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
         const data = imageData.data;

         let totalLightness = 0;
         let totalHue = 0;
         let pixelCount = 0;

         const hues = [];

         for (let i = 0; i < data.length; i += 4) {
             // Ignore fully transparent pixels
             if (data[i + 3] === 0) continue;

             const rgb = [data[i], data[i + 1], data[i + 2]];
             const hsl = rgbToHslforsingle(rgb[0], rgb[1], rgb[2]);

             totalLightness += hsl[2];
             totalHue += hsl[0];
             hues.push(hsl[0]);
             pixelCount++;
         }

         // Handle cases where no valid pixels were processed
         if (pixelCount === 0) {
             //console.warn("No valid pixels found in layer.");
             return {
                 avgLightness: 0,
                 avgHue: 0,
                 hueRange: 0,
                 lightnessTolerance: 0,
                 hueTolerance: 0,
             };
         }

         const avgLightness = totalLightness / pixelCount;
         const avgHue = totalHue / pixelCount;

         // Calculate hue range only if there are hues available
         //const hueRange = hues.length > 0 ? Math.max(...hues) - Math.min(...hues) : 0;
         let hueRange = calculateHueRangeforsingle(hues);



         const lightnessTolerance = Math.min(0.7, avgLightness / 2); // Scaled by avgLightness
         const hueTolerance = Math.min(47, hueRange / 2);            // Scaled by hue range


         return {
             avgLightness,
             avgHue,
             hueRange,
             lightnessTolerance,
             hueTolerance,
         };
       }
      function rgbToHsl(r, g, b) {
        r /= 255; g /= 255; b /= 255;
        const max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;

        if (max === min) {
            h = s = 0; // achromatic
        } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r:
                    h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
                    break;
                case g:
                    h = ((b - r) / d + 2) / 6;
                    break;
                case b:
                    h = ((r - g) / d + 4) / 6;
                    break;
            }
        }
        return [h, s, l];
      }

      function hslToRgb(h, s, l) {
        let r, g, b;

        if (s === 0) {
            r = g = b = l; // achromatic
        } else {
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1; if (t > 1) t -= 1;
                if (t < 1 / 6) return p + (q - p) * 6 * t;
                if (t < 1 / 2) return q;
                if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                return p;
            };
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
        }

        return [r, g, b];
      }


      // Function to convert RGB to HSL





      function rgbToHslforsingle(r, g, b) {
    r /= 255;
    g /= 255;
    b /= 255;

    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;

    if (max === min) {
        h = s = 0; // Achromatic
    } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

        switch (max) {
            case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
            case g:
                h = (b - r) / d + 2;
                break;
            case b:
                h = (r - g) / d + 4;
                break;
        }

        h /= 6;
    }

    return [h, s, l];
}

function hslToRgbforsingle(h, s, l) {
    let r, g, b;

    if (s === 0) {
        r = g = b = l; // Achromatic
    } else {
        const hue2rgb = function (p, q, t) {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
        };

        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
    }

    return [r * 255, g * 255, b * 255];
}

   function calculateHueRange(hues) {
        if (hues.length === 0) return 0;

        // Convert hues to degrees (0 to 360)
        const huesInDegrees = hues.map(h => h * 360);

        // Sort hues
        huesInDegrees.sort((a, b) => a - b);

        // Calculate differences between adjacent hues
        let maxDiff = 0;
        for (let i = 0; i < huesInDegrees.length - 1; i++) {
            const diff = huesInDegrees[i + 1] - huesInDegrees[i];
            if (diff > maxDiff) maxDiff = diff;
        }

        // Include wrap-around difference
        const wrapAroundDiff = 360 - huesInDegrees[huesInDegrees.length - 1] + huesInDegrees[0];
        if (wrapAroundDiff > maxDiff) maxDiff = wrapAroundDiff;

        return maxDiff;
      }

      function calculateHueRangeforsingle(hues) {
         if (hues.length === 0) return 0;

         let maxHue = -Infinity;
         let minHue = Infinity;

         for (let hue of hues) {
             if (hue > maxHue) maxHue = hue;
             if (hue < minHue) minHue = hue;
         }

         return maxHue - minHue;
       }
       function getDistinctColors(imageData, threshold = 30, maxColors = 20) {
        const totalLayers = {{ layers|length }};
        const uniqueColors = new Set();
        const data = imageData.data;
        const totalPixels = data.length / 4;
        const isSingleLayer = totalLayers === 1;
    
        // First pass: collect all unique colors
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            const a = data[i + 3];
    
            // Skip fully transparent pixels
            if (a === 0) continue;
            // Skip black colors
            if (r === 0 && g === 0 && b === 0) continue;
            
            uniqueColors.add(`${r},${g},${b}`);
        }
    
        // Convert to array and map to RGB arrays
        const colors = Array.from(uniqueColors).map(colorStr => {
            const [r, g, b] = colorStr.split(',').map(Number);
            return {
                rgb: [r, g, b],
                count: 1
            };
        });
    
        console.log('Total unique colors found:', colors.length);
    
        const distinctColors = [];
    
        function colorDistance(c1, c2) {
            return Math.sqrt(
                Math.pow(c1[0] - c2[0], 2) +
                Math.pow(c1[1] - c2[1], 2) +
                Math.pow(c1[2] - c2[2], 2)
            );
        }
    
        if (isSingleLayer) {
            // Take all unique colors, up to maxColors
            for (let i = 0; i < colors.length && distinctColors.length < maxColors; i++) {
                const currentColor = colors[i].rgb;
                
                // Check if this color is significantly different from already selected colors
                const isUnique = distinctColors.every(existingColor => 
                    colorDistance(currentColor, existingColor) > 80
                );
    
                if (isUnique) {
                    distinctColors.push(currentColor);
                }
            }
    
            // Ensure we have at least 3 colors 
            if (distinctColors.length < 3) {
                for (let i = 0; i < colors.length && distinctColors.length < 3; i++) {
                    if (!distinctColors.includes(colors[i].rgb)) {
                        distinctColors.push(colors[i].rgb);
                    }
                }
            }
        } else {
            // Original logic for multiple layers
            colors.forEach(({ rgb }) => {
                if (distinctColors.length >= maxColors) return;
    
                const isDistinct = distinctColors.every(d => colorDistance(d, rgb) > threshold);
                if (isDistinct) {
                    distinctColors.push(rgb);
                }
            });
        }
        
        // Function to convert RGB to HSL for color sorting
        function rgbToHsl(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;
            
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
    
            if (max === min) {
                h = s = 0; // achromatic
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                
                h /= 6;
            }
    
            return [h, s, l];
        }
        
        // Sort colors by hue for rainbow/color wheel order
        const sortedColors = [...distinctColors];
        sortedColors.sort((a, b) => {
            const [h1, s1, l1] = rgbToHsl(a[0], a[1], a[2]);
            const [h2, s2, l2] = rgbToHsl(b[0], b[1], b[2]);
            
            // For very pale colors (light pinks, etc.), use their color bias
            function getColorBias(rgb, hsl) {
                const [r, g, b] = rgb;
                const [h, s, l] = hsl;
                
                // For very light colors, detect the color bias
                if (l > 0.8 && s < 0.2) {
                    // Calculate which channel has the highest value
                    const rRatio = r / 255;
                    const gRatio = g / 255;
                    const bRatio = b / 255;
                    
                    if (rRatio > gRatio && rRatio > bRatio) return 0; // reddish/pinkish white
                    if (gRatio > rRatio && gRatio > bRatio) return 0.33; // greenish white
                    if (bRatio > rRatio && bRatio > gRatio) return 0.66; // bluish white
                }
                
                return h; // Use normal hue for non-pale colors
            }
            
            const bias1 = getColorBias(a, [h1, s1, l1]);
            const bias2 = getColorBias(b, [h2, s2, l2]);
            
            // First sort by hue/bias
            if (Math.abs(bias1 - bias2) > 0.05) return bias1 - bias2;
            
            // For similar hues, put more saturated colors first, then lighter colors
            if (Math.abs(s1 - s2) > 0.1) return s2 - s1;
            
            return l1 - l2;
        });
    
        console.log('Final distinct colors:', sortedColors.length);
        return sortedColors;
    }
    
        function generateUniqueRGBColorArray(count) {
            const colors = [];
        
            while (colors.length < count) {
                const r = Math.floor(Math.random() * 256);
                const g = Math.floor(Math.random() * 256);
                const b = Math.floor(Math.random() * 256);
        
                const isGreenish = (g > r && g > b);
                const isDuplicate = colors.some(color => color[0] === r && color[1] === g && color[2] === b);
        
                if (!isGreenish && !isDuplicate) {
                    colors.push([r, g, b]);
                }
            }
        
            return colors;
        }
    
    function generateUniqueRGBColorArray(count) {
        const colors = [];
    
        while (colors.length < count) {
            const r = Math.floor(Math.random() * 256);
            const g = Math.floor(Math.random() * 256);
            const b = Math.floor(Math.random() * 256);
    
            const isGreenish = (g > r && g > b);
            const isDuplicate = colors.some(color => color[0] === r && color[1] === g && color[2] === b);
    
            if (!isGreenish && !isDuplicate) {
                colors.push([r, g, b]);
            }
        }
    
        return colors;
    }

      function showLayerInfo() {
        contextMenu.style.display = 'none';
        $('#colorPickerModal').modal('show');
        const layerIndex = contextMenu.dataset.layerIndex; // Assuming contextMenu is defined

        updateLayersWithNewColorCount(layerIndex);
      }

      async function processLayerAsync(ctx, targetColor, newColor, minAreaThreshold = 1, maxSkipCount = 5) {
    return new Promise(async (resolve) => {
        const colorProcessor = new ColorProcessor();
        
        // Get the layer index from the canvas ID
        const canvasId = ctx.canvas.id;
        const layerIndex = parseInt(canvasId.replace('layer_canvas_', ''));
        
        // Convert canvas to image data URL
        const imageDataUrl = ctx.canvas.toDataURL();
        console.log('Processing layer with colors:', {
            targetColor: targetColor,
            newColor: newColor
        });

        try {
            // Get color mapping analysis
            const colorMapping = await colorProcessor.getColorMapping(imageDataUrl);
            console.log('Color mapping analysis:', colorMapping);
            
            // Apply color mapping
            const processedImageUrl = await colorProcessor.applyColorMapping(
                imageDataUrl,
                colorMapping,
                newColor,    // Target color to map to
                targetColor  // Original/dominant color to replace
            );
            
            // Load the processed image back to canvas
            const img = new Image();
            img.onload = () => {
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                ctx.drawImage(img, 0, 0);
                
                // Update the footer button color
                updateFooterColorButton(layerIndex, newColor);
                
                resolve();
            };
            img.src = processedImageUrl;
            
        } catch (error) {
            console.error('Error processing layer:', error);
            resolve();
        }
    });
}

function updateLayersWithNewColorCount(layerIndex) {
  console.info("layerIndex: " + layerIndex);
  const layerIndexCount = layerIndex - 1;
  const sliderValue = document.getElementById('color-count-slider').value;
  const totalLayers = {{ layers|length }};
  const layers = {{ layers|safe }};

  let distinctColorTolerance = totalLayers > 5 ? 180 : 200;
  let layer = layers[layerIndexCount];
  let canvas = document.getElementById('layer_canvas_' + layerIndex);
  
  // If no canvas found, return early
  if (!canvas) return;

  let ctx = canvas.getContext('2d', { willReadFrequently: true });
  let latestImageData = null;

  // Get current canvas state if it exists
  const currentState = canvas.getAttribute('data-current-state');
  const img = new Image();
  
  img.onload = function() {
      const colorPickerContainer = document.getElementById('color-pickers');
      colorPickerContainer.innerHTML = '';
      
      // Preserve canvas dimensions
      const originalWidth = canvas.width;
      const originalHeight = canvas.height;
      canvas.width = img.width || originalWidth;
      canvas.height = img.height || originalHeight;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0);

      // Save the current state
      layerStates.saveEditedState(layerIndex);

      latestImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const distinctColors = getDistinctColors(imageData, 180, sliderValue);

      console.log('Processing colors for layer:', layerIndex);

      distinctColors.forEach((color, index) => {
          const button = document.createElement('button');
          button.className = 'color-picker';
          button.style.backgroundColor = `rgb(${color.join(',')})`;
          colorPickerContainer.appendChild(button);

          const pickr = Pickr.create({
              el: button,
              theme: 'nano',
              default: `rgb(${color.join(',')})`,
              components: {
                  preview: true,
                  opacity: true,
                  hue: true,
                  interaction: {
                      rgba: true,
                      input: true,
                      hsla: true,
                      save: true,
                  }
              }
          });

          let isProcessing = false;
          pickr.on('save', async (newColor) => {
              if (isProcessing) return;
              isProcessing = true;

              try {
                  const rgbaColor = newColor.toRGBA().map(v => Math.round(v));
                  const currentTargetColor = distinctColors[index];

                  // Save state before processing
                  layerStates.saveEditedState(layerIndex);

                  await processLayerAsync(ctx, currentTargetColor, rgbaColor);
                  
                  // Update UI elements
                  updateFooterColorButton(layerIndex, rgbaColor);
                  button.style.backgroundColor = `rgba(${rgbaColor.join(',')})`;
                  
                  // Update stored colors
                  distinctColors[index] = rgbaColor.slice(0, 3);
                  
                  // Update latest image data
                  latestImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                  ctx.putImageData(latestImageData, 0, 0);

                  // Save the new state after processing
                  canvas.setAttribute('data-current-state', canvas.toDataURL());
                  
                  pickr.hide();
              } catch (error) {
                  console.error('Error processing color change:', error);
              } finally {
                  setTimeout(() => {
                      isProcessing = false;
                  }, 100);
              }
          });

          // Add change event to update preview in real-time
          pickr.on('change', (color) => {
              button.style.backgroundColor = color.toRGBA().toString();
          });
      });
  };

  // Load appropriate image source
  if (currentState) {
      img.src = currentState;
  } else {
      img.src = layer.path;
      // Save original state if it hasn't been saved yet
      if (!layerStates.hasOriginalState(layerIndex)) {
          layerStates.saveOriginalState(layerIndex);
      }
  }

  img.onerror = function(error) {
      console.error('Error loading image:', error);
  };
}
      
      function changeHueWithHueAndLightnessTolerance(ctx, targetColor, newColor, hueTolerance, lightnessTolerance) {
        console.info('Processing Layer with target color:', targetColor, 'and new color:', newColor);
        const canvasWidth = ctx.canvas.width;
        const canvasHeight = ctx.canvas.height;
        const imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
        const data = imageData.data;

        // Convert target and new colors to HSL
        const targetHsl = rgbToHsl(...targetColor);
        const newHsl = rgbToHsl(...newColor);

        // Normalize hue tolerance to fraction (since hue is between 0 and 1 in HSL)
        //const hueToleranceFraction = hueTolerance / 360;
        const hueToleranceFraction = Math.max(0.05, hueTolerance / 360); // Minimum 5% tolerance
        //const lightnessTolerance = Math.max(0.1, lightnessTolerance);   // Minimum 10% tolerance

        for (let i = 0; i < data.length; i += 4) {
            const currentColor = [data[i], data[i + 1], data[i + 2]];
            const currentHsl = rgbToHsl(...currentColor);

            // Calculate hue and lightness differences
            let hueDiff = Math.abs(currentHsl[0] - targetHsl[0]);
            if (hueDiff > 0.5) hueDiff = 1 - hueDiff; // Wrap-around for hue differences
            const lightnessDiff = Math.abs(currentHsl[2] - targetHsl[2]);
            //console.log(`Pixel ${i / 4}: Matches Tolerance (HueDiff: ${hueDiff}, LightnessDiff: ${lightnessDiff})`);
            // Check if the pixel's hue and lightness are within tolerance range
            if (hueDiff <= hueToleranceFraction && lightnessDiff <= lightnessTolerance) {
                //const blendedRgb = hslToRgb(newHsl[0], currentHsl[1], currentHsl[2]);
                const blendedRgb = hslToRgb(newHsl[0], currentHsl[1], currentHsl[2]);

                // Scale RGB values to 0-255 and assign to data array
                data[i] = Math.round(blendedRgb[0] * 255);
                data[i + 1] = Math.round(blendedRgb[1] * 255);
                data[i + 2] = Math.round(blendedRgb[2] * 255);
            }
        }

        ctx.putImageData(imageData, 0, 0);
      }



      {% comment %} fav section starts  {% endcomment %}

// Add this to your existing JavaScript file
function toggleFavorite(button, collection) {
  const paletteType = button.dataset.paletteType;
  const colorsId = button.dataset.colorsId;
  const icon = button.querySelector('i');
  const countSpan = button.querySelector('.fav-count');
  
  // Get the colors from the stored palette
  const colors = window[`${collection}PaletteColors`][colorsId];
  
  if (!colors) {
      console.error('No colors found for this palette');
      return;
  }

  const paletteData = {
      name: `${collection.toUpperCase()} Palette ${colorsId}`,
      type: paletteType,
      base_color_r: colors[0][0],
      base_color_g: colors[0][1],
      base_color_b: colors[0][2],
      num_colors: colors.length,
      colors: colors.map(color => ({
          red: color[0],
          green: color[1],
          blue: color[2]
      }))
  };

  if (icon.classList.contains('bi-heart')) {
      // Add to favorites
      savePalette(paletteData, button);
  } else {
      // Remove from favorites
      removePalette(button.dataset.paletteId);
  }
}

async function savePalette(paletteData, button) {
  try {
      const response = await fetch('api/palettes/favorite/', {
          method: 'POST',
          headers: {
              'Content-Type': 'application/json',
              'X-CSRFToken': getCookie('csrftoken')
          },
          body: JSON.stringify(paletteData)
      });

      const data = await response.json();
      
      if (response.ok) {
          const icon = button.querySelector('i');
          const countSpan = button.querySelector('.fav-count');
          
          icon.classList.remove('bi-heart');
          icon.classList.add('bi-heart-fill');
          button.dataset.paletteId = data.palette_id;
          countSpan.textContent = data.favorites_count;
          
          // Refresh favorites section
          loadFavorites();
      }
  } catch (error) {
      console.error('Error saving palette:', error);
  }
}

async function removePalette(paletteId) {
  try {
      const response = await fetch(`api/palettes/favorite/${paletteId}/`, {
          method: 'DELETE',
          headers: {
              'X-CSRFToken': getCookie('csrftoken')
          }
      });

      if (response.ok) {
          const button = document.querySelector(`[data-palette-id="${paletteId}"]`);
          const icon = button.querySelector('i');
          const countSpan = button.querySelector('.fav-count');
          
          icon.classList.remove('bi-heart-fill');
          icon.classList.add('bi-heart');
          delete button.dataset.paletteId;
          
          const data = await response.json();
          countSpan.textContent = data.favorites_count;
          
          // Refresh favorites section
          loadFavorites();
      }
  } catch (error) {
      console.error('Error removing palette:', error);
  }
}

async function loadFavorites() {
  try {
      const response = await fetch('api/palettes/favorites/');
      const favorites = await response.json();
      
      const favContent = document.getElementById('favCollectionContent');
      const favContainer = favContent.querySelector('.layer-toggles');
      favContainer.innerHTML = '';
      
      // Get the number of layers from your existing layers
      const numLayers = document.querySelectorAll('[id^="layer_canvas_"]').length;
      ; // Assuming your layers have IDs starting with "layer"
      
       // Filter favorites to only include palettes with matching number of colors
       const matchingFavorites = favorites.filter(favorite => 
       favorite.colors && favorite.colors.length === numLayers
   );
   
   matchingFavorites.forEach((favorite, index) => {
       const colors = favorite.colors.map(color => [color.red, color.green, color.blue]);
       const paletteHtml = createPaletteHTML(favorite, index + 1);
       favContainer.insertAdjacentHTML('beforeend', paletteHtml);
       displayColorPalette(index + 1, colors, 'fav');
           
       // Add click handler for apply button
       const applyButton = document.getElementById(`fav_applyButton_${index + 1}`);
       if (applyButton) {
           applyButton.addEventListener('click', () => applyPaletteToLayer(colors));
       }
   });

   if (matchingFavorites.length === 0) {
    const popup = document.createElement('div');
    popup.innerHTML = `
        <div class="popup-overlay"></div>
        <div class="popup">
            <button class="close-btn">&times;</button>
            <p>No favorite palettes found matching ${numLayers} layers</p>
        </div>
    `;
    
    document.body.appendChild(popup);

    // Close popup when clicking the close button or overlay
    const closeBtn = popup.querySelector('.close-btn');
    const overlay = popup.querySelector('.popup-overlay');
    
    const closePopup = () => {
        popup.remove();
    };

    closeBtn.addEventListener('click', closePopup);
    overlay.addEventListener('click', closePopup);

    // Auto close after 3 seconds
    setTimeout(closePopup, 3000);
}
} catch (error) {
   console.error('Error loading favorites:', error);
}
}
function createPaletteHTML(palette, index) {
  return `
      <div class="layer-toggle-item d-flex flex-column gap-2">
          <div id="fav_colorPalette_${index}" class="color-palette d-flex flex-column"></div>
          <div class="d-flex align-items-center justify-content-between w-100">
              <button id="fav_shufflePalette_${index}" class="btn btn-sm btn-primary">
                  <i class="bi bi-shuffle"></i>
              </button>
              <button type="button" 
                      class="btn favorite-btn"
                      data-palette-id="${palette.id}"
                      onclick="removePalette(${palette.id})">
                  <i class="bi bi-heart-fill"></i>
                  <span class="fav-count">${palette.favorites_count}</span>
              </button>
              <button type="button" id="fav_applyButton_${index}" class="btn btn-success">
                  <i class="bi bi-magic"></i>
              </button>
          </div>
      </div>
  `;
}

// Helper function to get CSRF token
function getCookie(name) {
  let cookieValue = null;
  if (document.cookie && document.cookie !== '') {
      const cookies = document.cookie.split(';');
      for (let i = 0; i < cookies.length; i++) {
          const cookie = cookies[i].trim();
          if (cookie.substring(0, name.length + 1) === (name + '=')) {
              cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
              break;
          }
      }
  }
  return cookieValue;
}

// Load favorites when the page loads
document.addEventListener('DOMContentLoaded', loadFavorites);

      {% comment %} fav sections ends  {% endcomment %}
      
      function changeHueWithHueAndLightnessTolerance(ctx, targetColor, newColor, hueTolerance, lightnessTolerance) {
  console.info('Processing Layer with target color:', targetColor, 'and new color:', newColor);
  const canvasWidth = ctx.canvas.width;
  const canvasHeight = ctx.canvas.height;
  const imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
  const data = imageData.data;

  // Convert target and new colors to HSL
  const targetHsl = rgbToHsl(...targetColor);
  const newHsl = rgbToHsl(...newColor);

  // Normalize hue tolerance to fraction (since hue is between 0 and 1 in HSL)
  const hueToleranceFraction = hueTolerance / 360; // Strict hue tolerance
  const lightnessTolerance1 = Math.max(0.05, lightnessTolerance); // Minimum 5% lightness tolerance
  const minSaturation = 0.1; // Minimum saturation threshold

  for (let i = 0; i < data.length; i += 4) {
    const currentColor = [data[i], data[i + 1], data[i + 2]];
    const currentHsl = rgbToHsl(...currentColor);

    // Skip desaturated colors
    if (currentHsl[1] < minSaturation) continue;

    // Calculate hue and lightness differences
    let hueDiff = Math.abs(currentHsl[0] - targetHsl[0]);
    if (hueDiff > 0.5) hueDiff = 1 - hueDiff; // Wrap-around for hue differences
    const lightnessDiff = Math.abs(currentHsl[2] - targetHsl[2]);

    // Check if the pixel's hue and lightness are within tolerance range
    if (hueDiff <= hueToleranceFraction && lightnessDiff <= lightnessTolerance1) {
      const blendedRgb = hslToRgb(newHsl[0], currentHsl[1], currentHsl[2]);

      // Scale RGB values to 0-255 and assign to data array
      data[i] = Math.round(blendedRgb[0] * 255);
      data[i + 1] = Math.round(blendedRgb[1] * 255);
      data[i + 2] = Math.round(blendedRgb[2] * 255);
    }
  }

  ctx.putImageData(imageData, 0, 0);
}


function updateColorCountDisplay() {
         const sliderValue = document.getElementById('color-count-slider').value;
         document.getElementById('color-count-display').innerText = sliderValue;

       }


 
       // Function to convert RGB to HSL
       function rgbToHsl(r, g, b) {
         r /= 255;
         g /= 255;
         b /= 255;

         const max = Math.max(r, g, b);
         const min = Math.min(r, g, b);
         let h, s, l = (max + min) / 2;

         if (max === min) {
             h = s = 0; // Achromatic
         } else {
             const d = max - min;
             s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

             switch (max) {
                 case r:
                     h = (g - b) / d + (g < b ? 6 : 0);
                     break;
                 case g:
                     h = (b - r) / d + 2;
                     break;
                 case b:
                     h = (r - g) / d + 4;
                     break;
             }

             h /= 6;
         }

         return [h, s, l];
       }
       async function generatePallateColors() {
        updateColorCountDisplay();
        const layerIndex = contextMenu.dataset.layerIndex;
        const layerIndexCount = layerIndex - 1;
        const sliderValue = document.getElementById('color-count-slider').value;
    
        const layers = {{ layers|safe }};
        let layer = layers[layerIndexCount];
        let img = new Image();
        img.src = layer.path;
        let canvas = document.getElementById('layer_canvas_'+layerIndex);
        let ctx = canvas.getContext('2d', { willReadFrequently: true });
        let latestImageData = null;
    
        img.onload = async function() {
            const colorPickerContainer = document.getElementById('color-pickers');
            colorPickerContainer.innerHTML = '';
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
    
            // Create ImageColorAnalyzer instance
            const analyzer = new ImageColorAnalyzer();
            const colorAnalysis = await analyzer.analyzeImageColors(img);
    
            // Get all colors including dominant and other colors
            let distinctColors = [colorAnalysis.dominantColor];
            if (colorAnalysis.otherColors) {
                colorAnalysis.otherColors.forEach(color => {
                    distinctColors.push(color.rgb);
                });
            }
    
            // Store original colors
            window.originalColors = [...distinctColors];
    
            // Limit colors based on slider value
            distinctColors = distinctColors.slice(0, parseInt(sliderValue));
    
            // Create color pickers for each distinct color
            distinctColors.forEach((color, index) => {
                const button = document.createElement('button');
                button.className = 'color-picker';
                button.style.backgroundColor = `rgb(${color.join(',')})`;
                
                // Get color name using analyzer
                const colorName = analyzer.getColorGroup(...color);
                button.title = colorName;
                
                document.getElementById('color-pickers').appendChild(button);
    
                const pickr = Pickr.create({
                    el: button,
                    theme: 'nano',
                    default: `rgb(${color.join(',')})`,
                    components: {
                        preview: true,
                        opacity: true,
                        hue: true,
                        interaction: {
                            rgba: true,
                            input: true,
                            hsla: true,
                            save: true,
                        }
                    }
                });
    
                let isProcessing = false;
                pickr.on('save', async (newColor) => {
                    if (isProcessing) return;
                    const rgbaColor = newColor.toRGBA().map(v => Math.round(v));
                    const currentTargetColor = distinctColors[index];
    
                    isProcessing = true;
                    await processLayerAsync(ctx, currentTargetColor, rgbaColor);
                    
                    button.style.backgroundColor = `rgba(${rgbaColor.join(',')})`;
                    distinctColors[index] = rgbaColor.slice(0, 3);
    
                    isProcessing = false;
                    pickr.hide();
                });
            });
    
            // Create a shuffle button for this color set
            const shuffleButton = document.createElement('button');
            shuffleButton.className = 'btn btn-sm btn-secondary mt-2';
            shuffleButton.innerHTML = '<i class="bi bi-shuffle"></i> Shuffle Colors';
            shuffleButton.onclick = async () => {
                const newColorAnalysis = await analyzer.analyzeImageColors(img);
                const newColors = [newColorAnalysis.dominantColor];
                
                if (newColorAnalysis.otherColors) {
                    newColorAnalysis.otherColors.forEach(color => {
                        if (newColors.length < distinctColors.length) {
                            newColors.push(color.rgb);
                        }
                    });
                }
    
                // Update existing color pickers with new colors
                const colorPickers = document.querySelectorAll('#color-pickers .color-picker');
                colorPickers.forEach((picker, index) => {
                    if (newColors[index]) {
                        picker.style.backgroundColor = `rgb(${newColors[index].join(',')})`;
                        distinctColors[index] = newColors[index];
                    }
                });
            };
            
            document.getElementById('color-pickers').appendChild(shuffleButton);
        };
    }


    // Helper function to set up palette buttons consistently
function setupPaletteButton(buttonId, paletteIndex, collection, targetLayerIndex) {
    const button = document.getElementById(buttonId);
    if (!button) {
        console.warn(`Button ${buttonId} not found`);
        return;
    }
    
    button.addEventListener('click', async function(event) {
        // Load the original image
        const img = new Image();
        img.src = "{{ layer.path }}";
        
        await new Promise((resolve) => {
            img.onload = resolve;
        });
        
        // Reset canvas to original image
        const canvas = document.getElementById(`layer_canvas_${targetLayerIndex}`);
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0);
        
        // Find the correct palette
        const paletteId = `${collection}_colorPalette_${paletteIndex}`;
        const currentPalette = document.getElementById(paletteId);
        
        if (!currentPalette) {
            console.error(`Palette not found: ${paletteId}`, {collection, paletteIndex, totalLayers});
            return;
        }
        
        console.log(`Applying palette: ${paletteId} to layer ${targetLayerIndex}`);
        
        // Extract colors from the palette
        const paletteColors = Array.from(currentPalette.querySelectorAll('.color-swatch'))
            .map(swatch => {
                const style = window.getComputedStyle(swatch);
                const color = style.backgroundColor;
                return color.match(/\d+/g).map(Number);
            });
        
        // Apply the palette - make sure to pass the paletteIndex as a parameter
        await processPallet(
            ctx, 
            totalLayers, 
            canvas, 
            targetLayerIndex, 
            [], 
            paletteColors,
            paletteIndex  // Add this parameter
        );
    });
}
async function processPallet(layerCtx, totalLayers, layerCanvas, currentLayerIndex, oldColorArray, trendingColors, paletteIndex) {
    const loadingScreen = document.getElementById('loading-screen');
    loadingScreen.style.display = 'block';
    const colorProcessor = new ColorProcessor();
  
    try {
        if (totalLayers === 1) {
            // Single layer optimized processing
            if (paletteIndex === undefined) {
                paletteIndex = 0;
            }
            
            const layer = 1;
            const layerCanvas = document.getElementById(`layer_canvas_${layer}`);
            if (!layerCanvas) return;
            
            // Cache DOM elements and computed values
            const colorButtons = document.querySelectorAll('.color-picker');
            const unlockedButtons = Array.from(colorButtons).filter(button => button.dataset.locked !== 'true');
            
            if (unlockedButtons.length === 0) {
                console.log('All colors are locked');
                loadingScreen.style.display = 'none';
                return;
            }
            
            // Save current state before processing
            layerStates.saveEditedState(layer);
            
            // Process all unlocked colors in a single pass
            const ctx = layerCanvas.getContext('2d', { willReadFrequently: true });
            const originalImageData = ctx.getImageData(0, 0, layerCanvas.width, layerCanvas.height);
            const imageDataUrl = layerCanvas.toDataURL();
            
            // Create array of color mappings to process
            const colorMappings = [];
            for (let i = 0; i < unlockedButtons.length; i++) {
                const button = unlockedButtons[i];
                const style = window.getComputedStyle(button);
                const bgcolor = style.backgroundColor;
                const originalColor = bgcolor.match(/\d+/g).map(Number);
                
                const targetColorIndex = (paletteIndex + i) % trendingColors.length;
                const targetColor = trendingColors[targetColorIndex];
                
                colorMappings.push({
                    originalColor,
                    targetColor,
                    button
                });
            }
            
            // Process all colors in one go
            const processedImageUrl = await colorProcessor.applyMultipleColorMappings(
                imageDataUrl,
                colorMappings
            );
            
            // Load the processed image back to canvas once
            const resultImg = new Image();
            await new Promise(resolve => {
                resultImg.onload = () => {
                    ctx.clearRect(0, 0, layerCanvas.width, layerCanvas.height);
                    ctx.drawImage(resultImg, 0, 0);
                    
                    // Update all button colors
                    colorMappings.forEach(mapping => {
                        mapping.button.style.backgroundColor = `rgb(${mapping.targetColor.join(',')})`;
                    });
                    
                    resolve();
                };
                resultImg.src = processedImageUrl;
            });
            
            // Update footer once
            updateFooterColorButton(layer, trendingColors[0]);
            
        } else {
            // Optimized multi-layer processing
            const colorButtons = document.querySelectorAll('.color-picker');
            const unlockedLayers = [];
            const colorMappingsPerLayer = new Map();
            
            // Prepare all color mappings first to minimize DOM access
            for (let layer = 1; layer <= totalLayers; layer++) {
                const colorButton = document.querySelector(`.color-picker[data-layer-index="${layer-1}"]`);
                if (colorButton && colorButton.dataset.locked === 'true') {
                    console.log(`Layer ${layer} is locked, skipping processing`);
                    continue;
                }
                
                const layerCanvas = document.getElementById(`layer_canvas_${layer}`);
                if (!layerCanvas) continue;
                
                // Save current state before processing
                layerStates.saveEditedState(layer);
                
                const style = window.getComputedStyle(colorButton);
                const bgcolor = style.backgroundColor;
                const originalColor = bgcolor.match(/\d+/g).map(Number);
                
                // Get target color (cycle through trending colors)
                const targetColorIndex = (layer - 1) % trendingColors.length;
                const targetColor = trendingColors[targetColorIndex];
                
                unlockedLayers.push({
                    layer,
                    canvas: layerCanvas,
                    button: colorButton
                });
                
                colorMappingsPerLayer.set(layer, {
                    originalColor,
                    targetColor
                });
            }
            
            // Process all layers in parallel
            const layerPromises = unlockedLayers.map(async ({ layer, canvas, button }) => {
                const layerCtx = canvas.getContext('2d', { willReadFrequently: true });
                const mapping = colorMappingsPerLayer.get(layer);
                
                const imageDataUrl = canvas.toDataURL();
                let processedImageUrl;
                
                if (layerStates.hasEditedState(layer)) {
                    const img = new Image();
                    await new Promise((resolve) => {
                        img.onload = async () => {
                            layerCtx.clearRect(0, 0, canvas.width, canvas.height);
                            layerCtx.drawImage(img, 0, 0);
                            
                            processedImageUrl = await colorProcessor.applyColorMapping(
                                canvas.toDataURL(),
                                await colorProcessor.getColorMapping(canvas.toDataURL()),
                                mapping.targetColor,
                                mapping.originalColor
                            );
                            
                            resolve();
                        };
                        img.src = layerStates.getEditedState(layer);
                    });
                } else {
                    processedImageUrl = await colorProcessor.applyColorMapping(
                        imageDataUrl,
                        await colorProcessor.getColorMapping(imageDataUrl),
                        mapping.targetColor,
                        mapping.originalColor
                    );
                }
                
                // Load the processed image back to canvas
                const resultImg = new Image();
                await new Promise(resolve => {
                    resultImg.onload = () => {
                        layerCtx.clearRect(0, 0, canvas.width, canvas.height);
                        layerCtx.drawImage(resultImg, 0, 0);
                        
                        // Update button color
                        button.style.backgroundColor = `rgb(${mapping.targetColor.join(',')})`;
                        updateFooterColorButton(layer, mapping.targetColor);
                        
                        resolve();
                    };
                    resultImg.src = processedImageUrl;
                });
            });
            
            // Wait for all layers to complete
            await Promise.all(layerPromises);
        }
    } catch (error) {
        console.error("Error while processing pallet:", error);
    } finally {
        loadingScreen.style.display = 'none';
    }
}

function getRandomColor() {
  const r = Math.floor(Math.random() * 256);
  const g = Math.floor(Math.random() * 256);
  const b = Math.floor(Math.random() * 256);
  return [r, g, b];
}
function processNonDominantColors(ctx, dominantColor) {
    if (!dominantColor || !dominantColor.nonDominantColors || dominantColor.nonDominantColors.length === 0) {
        console.log('No non-dominant colors found');
        return;
    }

    console.log('Non-dominant colors:', dominantColor.nonDominantColors);

    const imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
    const data = imageData.data;

    // Analyze the current layer for dynamic thresholds
    const analysis = analyzeImageLayer(ctx);
    const { hueTolerance, lightnessTolerance } = analysis;

    for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        const a = data[i + 3];

        if (a === 0) continue; // Skip fully transparent pixels

        const currentColor = [r, g, b];

        // Check if the current color is a non-dominant color
        if (!isColorInArray(currentColor, dominantColor.nonDominantColors)) continue;

        // Convert current color to HSL
        const currentHsl = rgbToHsl(r, g, b);

        // Calculate hue and lightness differences from the dominant color
        const dominantHsl = rgbToHsl(...dominantColor.referenceColor);
        const hueDiff = Math.abs(currentHsl[0] - dominantHsl[0]);
        const lightnessDiff = Math.abs(currentHsl[2] - dominantHsl[2]);

        // Check if the pixel's hue and lightness are within tolerance range
        if (
            hueDiff <= hueTolerance / 360 && // Normalize hue tolerance
            lightnessDiff <= lightnessTolerance
        ) {
            const randomColor = getRandomColor();
            console.log('Replacing non-dominant color', currentColor, 'with', randomColor);
            data[i] = randomColor[0];
            data[i + 1] = randomColor[1];
            data[i + 2] = randomColor[2];
        }
    }

    ctx.putImageData(imageData, 0, 0);
}

function updateFooterColorButton(layerIndex, newColor) {
    const colorButton = document.querySelector(`.color-picker[data-layer-index="${layerIndex-1}"]`);
    if (colorButton) {
        colorButton.style.backgroundColor = Array.isArray(newColor) ? 
            `rgb(${newColor.join(',')})` : newColor;
    }
}


class ImageColorAnalyzer {
    constructor() {
        this.logger = console;
        this.cv = null;
        this.isReady = false;
        this.initializationPromise = null;
    }

    async initialize() {
        // If already initialized, return
        if (this.isReady) return;

        // If initialization is in progress, return the existing promise
        if (this.initializationPromise) {
            return this.initializationPromise;
        }

        this.initializationPromise = new Promise((resolve, reject) => {
            // Check if OpenCV is already loaded
            if (typeof cv !== 'undefined') {
                this.cv = cv;
                this.isReady = true;
                resolve();
                return;
            }

            // Check if the script is already being loaded
            const existingScript = document.querySelector('script[src*="opencv.js"]');
            if (existingScript) {
                existingScript.addEventListener('load', () => {
                    this.cv = cv;
                    this.isReady = true;
                    resolve();
                });
                existingScript.addEventListener('error', () => {
                    reject(new Error('Failed to load OpenCV.js'));
                });
                return;
            }

            // Load OpenCV if not already loading
            const script = document.createElement('script');
            script.src = 'https://docs.opencv.org/4.8.0/opencv.js';
            script.async = true;
            script.type = 'text/javascript';

            // Only set Module if it's not already defined
            if (typeof window.Module === 'undefined') {
                window.Module = {
                    onRuntimeInitialized: () => {
                        this.cv = cv;
                        this.isReady = true;
                        resolve();
                    }
                };
            }

            script.onerror = () => {
                reject(new Error('Failed to load OpenCV.js'));
            };

            document.body.appendChild(script);
        });

        return this.initializationPromise;
    }

    rgbToLab(r, g, b) {
        // Convert RGB to XYZ
        r = r / 255;
        g = g / 255;
        b = b / 255;

        // RGB to XYZ conversion
        r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
        g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
        b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;

        r *= 100;
        g *= 100;
        b *= 100;

        const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
        const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
        const z = r * 0.0193 + g * 0.1192 + b * 0.9505;

        // XYZ to Lab conversion
        const xn = 95.047;
        const yn = 100.000;
        const zn = 108.883;

        const fx = x / xn > 0.008856 ? Math.pow(x / xn, 1/3) : (7.787 * x / xn) + 16/116;
        const fy = y / yn > 0.008856 ? Math.pow(y / yn, 1/3) : (7.787 * y / yn) + 16/116;
        const fz = z / zn > 0.008856 ? Math.pow(z / zn, 1/3) : (7.787 * z / zn) + 16/116;

        const L = (116 * fy) - 16;
        const a = 500 * (fx - fy);
        const b_val = 200 * (fy - fz);

        return [L, a, b_val];
    }

    calculateColorDifference(lab1, lab2) {
        // Delta E 2000 calculation (simplified version)
        const deltaL = lab2[0] - lab1[0];
        const deltaA = lab2[1] - lab1[1];
        const deltaB = lab2[2] - lab1[2];

        return Math.sqrt(
            Math.pow(deltaL, 2) +
            Math.pow(deltaA, 2) +
            Math.pow(deltaB, 2)
        );
    }

    async analyzeImageColors(imageElement) {
        if (!this.isReady) {
            await this.initialize();
        }

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = imageElement.width;
        canvas.height = imageElement.height;
        ctx.drawImage(imageElement, 0, 0);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const pixels = imageData.data;

        // Store colors with their frequency and LAB values
        const colorMap = new Map();
        const totalPixels = pixels.length / 4;

        // Sample pixels (analyze every 4th pixel for performance)
        for (let i = 0; i < pixels.length; i += 16) {
            const r = pixels[i];
            const g = pixels[i + 1];
            const b = pixels[i + 2];
            const a = pixels[i + 3];

            // Skip transparent pixels
            if (a < 127) continue;

            const key = `${r},${g},${b}`;
            const lab = this.rgbToLab(r, g, b);

            if (colorMap.has(key)) {
                colorMap.get(key).count++;
            } else {
                colorMap.set(key, {
                    rgb: [r, g, b],
                    lab: lab,
                    count: 1
                });
            }
        }

        // Convert map to array for processing
        let colors = Array.from(colorMap.values());

        // Merge similar colors
        const mergedColors = [];
        const threshold = 5; // Color difference threshold

        while (colors.length > 0) {
            const baseColor = colors[0];
            let totalCount = baseColor.count;
            const similarColors = [baseColor];

            // Find and merge similar colors
            for (let i = 1; i < colors.length; i++) {
                const diff = this.calculateColorDifference(baseColor.lab, colors[i].lab);
                if (diff < threshold) {
                    totalCount += colors[i].count;
                    similarColors.push(colors[i]);
                }
            }

            // Calculate weighted average color
            const avgColor = similarColors.reduce((acc, curr) => {
                const weight = curr.count / totalCount;
                return {
                    rgb: [
                        acc.rgb[0] + curr.rgb[0] * weight,
                        acc.rgb[1] + curr.rgb[1] * weight,
                        acc.rgb[2] + curr.rgb[2] * weight
                    ]
                };
            }, { rgb: [0, 0, 0] });

            mergedColors.push({
                rgb: avgColor.rgb.map(Math.round),
                percentage: (totalCount / (totalPixels / 4)) * 100
            });

            // Remove processed colors
            colors = colors.filter(c => !similarColors.includes(c));
        }

        // Sort by percentage and group by basic color categories
        const colorGroups = {};
        
        mergedColors.sort((a, b) => b.percentage - a.percentage)
            .forEach(color => {
                const colorGroup = this.getColorGroup(...color.rgb);
                
                if (!colorGroups[colorGroup]) {
                    colorGroups[colorGroup] = {
                        totalPercentage: 0,
                        shades: []
                    };
                }

                colorGroups[colorGroup].shades.push({
                    rgb: color.rgb,
                    percentage: color.percentage
                });
                colorGroups[colorGroup].totalPercentage += color.percentage;
            });

        // Sort and format results
        const sortedGroups = Object.entries(colorGroups)
            .map(([name, data]) => ({
                name,
                totalPercentage: data.totalPercentage,
                dominantShade: data.shades.sort((a, b) => b.percentage - a.percentage)[0]
            }))
            .sort((a, b) => b.totalPercentage - a.totalPercentage);

        const dominantGroup = sortedGroups[0];
        const otherColors = sortedGroups.slice(1, 5).map(group => ({
            colorName: group.name,
            rgb: group.dominantShade.rgb,
            percentage: group.totalPercentage
        }));



        const [h, s, l] = this.rgbToHsl(...dominantGroup.dominantShade.rgb);

        return {
            dominantColor: dominantGroup.dominantShade.rgb,
            dominantColorName: dominantGroup.name,
            dominantPercentage: dominantGroup.totalPercentage,
            otherColors: otherColors,
            hue: h * 360,
            saturation: s * 100,
            lightness: l * 100
        };
    }

    rgbToHsl(r, g, b) {
        r /= 255;
        g /= 255;
        b /= 255;

        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;

        if (max === min) {
            h = s = 0;
        } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }

            h /= 6;
        }

        return [h, s, l];
    }

    getColorGroup(r, g, b) {
    const [h, s, l] = this.rgbToHsl(r, g, b);
    const hue = h * 360;

    // Define color ranges by hue
    if (l < 0.1) return 'black';
    if (l > 0.9 && s < 0.1) return 'white';
    if (s < 0.15 && l > 0.1 && l < 0.9) return 'gray';

    // Hue-based color grouping
    if ((hue >= 345 || hue <= 10) && s > 0.15) return 'red';
    if (hue > 10 && hue <= 45) return 'orange';
    if (hue > 45 && hue <= 65) return 'yellow';
    if (hue > 65 && hue <= 170) return 'green';
    if (hue > 170 && hue <= 190) return 'cyan';
    if (hue > 190 && hue <= 260) return 'blue';
    if (hue > 260 && hue <= 320) return 'magenta';
    if (hue > 320 && hue <= 345) return 'purple';

    return 'other';
}
}


class ColorProcessor {
  constructor() {
        this.EPSILON = 0.0001;
        this.COLOR_SIMILARITY_THRESHOLD = 30;
        this.COLOR_QUANTIZATION_STEP = 15; // Added for color quantization
        this.cv = null; // Will store OpenCV instance
        
        // Bind methods
        this.applyColorMapping = this.applyColorMapping.bind(this);
   
       
        this.rgbToHsvProcessor = this.rgbToHsvProcessor.bind(this);
        this.hsvToRgbProcessor = this.hsvToRgbProcessor.bind(this);
        this.quantizeColor = this.quantizeColor.bind(this)
    }

    rgbToLab(rgb) {
      // First, convert RGB to XYZ using D65 illuminant
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;

      // Convert to sRGB space
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;

      // Convert to XYZ space
      const x = (r * 0.4124564 + g * 0.3575761 + b * 0.1804375) * 100;
      const y = (r * 0.2126729 + g * 0.7151522 + b * 0.0721750) * 100;
      const z = (r * 0.0193339 + g * 0.1191920 + b * 0.9503041) * 100;

      // Convert XYZ to Lab
      const xn = 95.047;
      const yn = 100.000;
      const zn = 108.883;

      const fx = x / xn > 0.008856 ? Math.pow(x / xn, 1/3) : (903.3 * x / xn + 16) / 116;
      const fy = y / yn > 0.008856 ? Math.pow(y / yn, 1/3) : (903.3 * y / yn + 16) / 116;
      const fz = z / zn > 0.008856 ? Math.pow(z / zn, 1/3) : (903.3 * z / zn + 16) / 116;

      const L = Math.max(0, 116 * fy - 16);
      const a = 500 * (fx - fy);
      const c = 200 * (fy - fz);

      return [L, a, c];
  }

  rgbToHsvProcessor(rgb) {
        const r = rgb[0] / 255;
        const g = rgb[1] / 255;
        const b = rgb[2] / 255;
        
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        const diff = max - min;
        
        let h = 0;
        if (max === min) {
            h = 0;
        } else if (max === r) {
            h = (60 * ((g - b) / diff) + 360) % 360;
        } else if (max === g) {
            h = (60 * ((b - r) / diff) + 120) % 360;
        } else {
            h = (60 * ((r - g) / diff) + 240) % 360;
        }
        
        const s = max === 0 ? 0 : diff / max;
        const v = max;
        
        return [h, s, v];
    }







   
    isColorSimilar(color1, color2) {
    const hsv1 = this.rgbToHsvProcessor(color1);
    const hsv2 = this.rgbToHsvProcessor(color2);
    
    // Calculate hue difference
    let hueDiff = Math.abs(hsv1[0] - hsv2[0]);
    if (hueDiff > 180) hueDiff = 360 - hueDiff;
    
    // Make the similarity check more strict
    const saturationThreshold = (hsv1[1] < 0.1 || hsv2[1] < 0.1) ? 0.1 : 0.2;
    
    return (
        (hueDiff < 20 || (hsv1[1] < 0.1 && hsv2[1] < 0.1)) && // Stricter hue check
        Math.abs(hsv1[1] - hsv2[1]) < saturationThreshold && 
        Math.abs(hsv1[2] - hsv2[2]) < 0.3
    );
}
quantizeColor(rgb) {
    return rgb.map(v => Math.round(v / this.COLOR_QUANTIZATION_STEP) * this.COLOR_QUANTIZATION_STEP);
}
calculateColorDistance(lab1, lab2) {
    // Use Delta E 2000 instead of Euclidean distance for more perceptually accurate color differences
    const kL = 1;
    const kC = 1;
    const kH = 1;
    
    const deltaL = lab1[0] - lab2[0];
    const L1 = lab1[0], L2 = lab2[0];
    const a1 = lab1[1], a2 = lab2[1];
    const b1 = lab1[2], b2 = lab2[2];
    
    const C1 = Math.sqrt(a1 * a1 + b1 * b1);
    const C2 = Math.sqrt(a2 * a2 + b2 * b2);
    const deltaC = C1 - C2;
    
    const deltaA = a1 - a2;
    const deltaB = b1 - b2;
    
    const deltaH = Math.sqrt(deltaA * deltaA + deltaB * deltaB - deltaC * deltaC);
    
    const SL = 1;
    const SC = 1 + 0.045 * (C1 + C2) / 2;
    const SH = 1 + 0.015 * (C1 + C2) / 2;
    
    return Math.sqrt(
        Math.pow(deltaL / (kL * SL), 2) +
        Math.pow(deltaC / (kC * SC), 2) +
        Math.pow(deltaH / (kH * SH), 2)
    );
}

    findSimilarColors(currentLab, shades, threshold = 25) {
        return shades.filter(shade => 
            this.calculateColorDistance(currentLab, shade.lab) < threshold
        );
    }

    async getColorMapping(imageData) {
      return new Promise((resolve) => {
          const img = new Image();
          img.onload = () => {
              const canvas = document.createElement('canvas');
              const ctx = canvas.getContext('2d');
              canvas.width = img.width;
              canvas.height = img.height;
              ctx.drawImage(img, 0, 0);
              
              const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
              const pixels = imgData.data;
              const totalPixels = pixels.length / 4;
              
              // Store colors with their frequency and LAB values
              const colorMap = new Map();
  
              // Analyze every pixel for better accuracy
              for (let i = 0; i < pixels.length; i += 4) {
                  const r = pixels[i];
                  const g = pixels[i + 1];
                  const b = pixels[i + 2];
                  const a = pixels[i + 3];
  
                  // Skip fully transparent pixels and pure black/white
                  if (a < 127) continue;
                  if (r === 0 && g === 0 && b === 0) continue;
                  if (r === 255 && g === 255 && b === 255) continue;
  
                  const key = `${r},${g},${b}`;
                  const lab = this.rgbToLab([r, g, b]);
                  const hsv = this.rgbToHsv(r, g, b);
  
                  if (colorMap.has(key)) {
                      colorMap.get(key).count++;
                  } else {
                      colorMap.set(key, {
                          rgb: [r, g, b],
                          lab: lab,
                          hsv: hsv,
                          count: 1
                      });
                  }
              }
  
              // Convert map to array for processing
              let colors = Array.from(colorMap.values());
  
              // Initial filtering of insignificant colors
              colors = colors.filter(color => 
                  (color.count / totalPixels) * 100 > 0.1 && // More than 0.1% of image
                  color.hsv[1] > 0.05 // Has some saturation
              );
  
              // Merge similar colors with adaptive threshold
              const mergedColors = [];
              const baseThreshold = 5; // Base threshold for color difference
  
              while (colors.length > 0) {
                  const baseColor = colors[0];
                  let totalCount = baseColor.count;
                  const similarColors = [baseColor];
  
                  // Adaptive threshold based on color properties
                  const adaptiveThreshold = this.calculateAdaptiveThreshold(baseColor, baseThreshold);
  
                  // Find and merge similar colors
                  for (let i = 1; i < colors.length; i++) {
                      const diff = this.calculateColorDistance(baseColor.lab, colors[i].lab);
                      const hsvDiff = this.calculateHSVDifference(baseColor.hsv, colors[i].hsv);
                      
                      if (diff < adaptiveThreshold || hsvDiff < 0.15) {
                          totalCount += colors[i].count;
                          similarColors.push(colors[i]);
                      }
                  }
  
                  // Calculate weighted average color
                  const avgColor = similarColors.reduce((acc, curr) => {
                      const weight = curr.count / totalCount;
                      return {
                          rgb: [
                              acc.rgb[0] + curr.rgb[0] * weight,
                              acc.rgb[1] + curr.rgb[1] * weight,
                              acc.rgb[2] + curr.rgb[2] * weight
                          ]
                      };
                  }, { rgb: [0, 0, 0] });
  
                  const finalRGB = avgColor.rgb.map(Math.round);
                  mergedColors.push({
                      rgb: finalRGB,
                      lab: this.rgbToLab(finalRGB),
                      hsv: this.rgbToHsv(...finalRGB),
                      percentage: (totalCount / totalPixels) * 100
                  });
  
                  // Remove processed colors
                  colors = colors.filter(c => !similarColors.includes(c));
              }
  
              // Sort by perceptual importance (combination of frequency and distinctiveness)
              mergedColors.sort((a, b) => {
                  const aScore = this.calculateColorImportance(a);
                  const bScore = this.calculateColorImportance(b);
                  return bScore - aScore;
              });
  
              // Get distinct colors while maintaining relationships
              const distinctColors = this.filterDistinctColors(mergedColors);
  
              // Get base color and shades
              const baseColor = distinctColors[0].rgb;
              const shades = distinctColors.map(color => ({
                  original: color.rgb,
                  lab: color.lab,
                  hsv: color.hsv,
                  frequency: color.percentage,
                  distance: this.calculateColorDistance(color.lab, distinctColors[0].lab)
              }));
  
              resolve({
                  baseColor,
                  shades
              });
          };
          img.src = imageData;
      });
  }
  

  async applyMultipleColorMappings(imageData, colorMappings) {
    return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
            console.time('colorMapping');
            const canvasElement = document.createElement('canvas');
            const ctx = canvasElement.getContext('2d');
            canvasElement.width = img.width;
            canvasElement.height = img.height;

            ctx.drawImage(img, 0, 0);
            const imageDataObj = ctx.getImageData(0, 0, img.width, img.height);
            const data = imageDataObj.data;
            const width = img.width;
            const height = img.height;

            // Color conversion utilities
            function rgbToHsv(r, g, b) {
                r /= 255; g /= 255; b /= 255;
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                const d = max - min;
                let h, s = max === 0 ? 0 : d / max, v = max;

                if (max === min) {
                    h = 0;
                } else {
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    h /= 6;
                }
                return [h * 360, s * 100, v * 100];
            }

            function hsvToRgb(h, s, v) {
                h /= 360; s /= 100; v /= 100;
                let r, g, b;
                const i = Math.floor(h * 6);
                const f = h * 6 - i;
                const p = v * (1 - s);
                const q = v * (1 - f * s);
                const t = v * (1 - (1 - f) * s);

                switch (i % 6) {
                    case 0: r = v; g = t; b = p; break;
                    case 1: r = q; g = v; b = p; break;
                    case 2: r = p; g = v; b = t; break;
                    case 3: r = p; g = q; b = v; break;
                    case 4: r = t; g = p; b = v; break;
                    case 5: r = v; g = p; b = q; break;
                }

                return [
                    Math.round(r * 255),
                    Math.round(g * 255),
                    Math.round(b * 255)
                ];
            }
            
            // Check if two colors are in the same color family
            function sameColorFamily(color1, color2) {
                const [r1, g1, b1] = color1;
                const [r2, g2, b2] = color2;
                
                // Convert to HSV to better compare color families
                const hsv1 = rgbToHsv(r1, g1, b1);
                const hsv2 = rgbToHsv(r2, g2, b2);
                
                // Check if both are achromatic (black, white, gray)
                const isAchromatic1 = hsv1[1] < 15; // Low saturation
                const isAchromatic2 = hsv2[1] < 15; 
                
                // If both are achromatic, compare by value (brightness)
                if (isAchromatic1 && isAchromatic2) {
                    // Allow more variance in brightness for achromatic colors
                    return Math.abs(hsv1[2] - hsv2[2]) < 30;
                }
                
                // If one is achromatic and the other not, they're different families
                if (isAchromatic1 !== isAchromatic2) {
                    return false;
                }
                
                // For chromatic colors, check hue similarity
                // Calculate hue difference with wrap-around
                let hueDiff = Math.abs(hsv1[0] - hsv2[0]);
                if (hueDiff > 180) hueDiff = 360 - hueDiff;
                
                // For very dark colors, hue is less reliable, so be more lenient
                const areBothDark = hsv1[2] < 30 && hsv2[2] < 30;
                
                // Colors in the same family should have similar hue and not too different saturation
                // Dark colors can have more hue variance since hue is less perceptible in dark colors
                return hueDiff < (areBothDark ? 45 : 30) && 
                       Math.abs(hsv1[1] - hsv2[1]) < 40;
            }
            
            // Detect gradients
            function detectGradients() {
                // Store gradient information
                const gradientMap = new Array(width * height).fill(false);
                const gradientStrengthMap = new Array(width * height).fill(0);
                
                // First pass: detect gradient pixels using color differences
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const centerIdx = (y * width + x) * 4;
                        if (data[centerIdx + 3] < 128) continue; // Skip transparent
                        
                        const centerColor = [data[centerIdx], data[centerIdx + 1], data[centerIdx + 2]];
                        
                        // Check neighbors
                        let maxDiff = 0;
                        let hasGradient = false;
                        
                        // Check in cardinal directions
                        const directions = [
                            { dx: -1, dy: 0 }, // left
                            { dx: 1, dy: 0 },  // right
                            { dx: 0, dy: -1 }, // up
                            { dx: 0, dy: 1 }   // down
                        ];
                        
                        for (const { dx, dy } of directions) {
                            const nx = x + dx;
                            const ny = y + dy;
                            
                            if (nx < 0 || nx >= width || ny < 0 || ny >= height) continue;
                            
                            const neighborIdx = (ny * width + nx) * 4;
                            if (data[neighborIdx + 3] < 128) continue;
                            
                            const neighborColor = [data[neighborIdx], data[neighborIdx + 1], data[neighborIdx + 2]];
                            
                            // Calculate color difference
                            const diff = Math.sqrt(
                                Math.pow(centerColor[0] - neighborColor[0], 2) +
                                Math.pow(centerColor[1] - neighborColor[1], 2) +
                                Math.pow(centerColor[2] - neighborColor[2], 2)
                            );
                            
                            // Only consider as gradient if colors are from the same family
                            if (diff > 5 && diff < 50 && sameColorFamily(centerColor, neighborColor)) {
                                hasGradient = true;
                                maxDiff = Math.max(maxDiff, diff);
                            }
                        }
                        
                        if (hasGradient) {
                            gradientMap[y * width + x] = true;
                            gradientStrengthMap[y * width + x] = Math.min(1, maxDiff / 50);
                        }
                    }
                }
                
                // Second pass: expand gradient regions to include all pixels in a gradient
                const expandedGradientMap = [...gradientMap];
                
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const pixelIndex = y * width + x;
                        if (expandedGradientMap[pixelIndex] || data[(pixelIndex * 4) + 3] < 128) continue;
                        
                        // Check if surrounded by gradient pixels of the same color family
                        const centerColor = [
                            data[pixelIndex * 4], 
                            data[pixelIndex * 4 + 1], 
                            data[pixelIndex * 4 + 2]
                        ];
                        
                        let gradientNeighbors = 0;
                        let sameColorNeighbors = 0;
                        
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                
                                const nx = x + dx;
                                const ny = y + dy;
                                
                                if (nx < 0 || nx >= width || ny < 0 || ny >= height) continue;
                                
                                const nIndex = ny * width + nx;
                                const nColorIdx = nIndex * 4;
                                
                                if (data[nColorIdx + 3] < 128) continue;
                                
                                const neighborColor = [
                                    data[nColorIdx], 
                                    data[nColorIdx + 1], 
                                    data[nColorIdx + 2]
                                ];
                                
                                if (gradientMap[nIndex]) {
                                    gradientNeighbors++;
                                    
                                    if (sameColorFamily(centerColor, neighborColor)) {
                                        sameColorNeighbors++;
                                    }
                                }
                            }
                        }
                        
                        // If enough gradient neighbors of same color family, include this pixel
                        if (gradientNeighbors >= 2 && sameColorNeighbors >= 2) {
                            expandedGradientMap[pixelIndex] = true;
                            gradientStrengthMap[pixelIndex] = 0.5; // Medium strength for expanded areas
                        }
                    }
                }
                
                return { gradientMap: expandedGradientMap, gradientStrengthMap };
            }
            
            // Identify color families in the image
            function identifyColorFamilies() {
                // Use a more sophisticated approach to group related colors
                const colorFamilies = [];
                const pixelFamilyMap = new Array(width * height).fill(-1); // Maps each pixel to family index
                
                // Process pixels to form initial color families
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const pixelIndex = y * width + x;
                        const colorIdx = pixelIndex * 4;
                        
                        if (data[colorIdx + 3] < 128) continue; // Skip transparent
                        
                        // Skip if already assigned to a family
                        if (pixelFamilyMap[pixelIndex] !== -1) continue;
                        
                        const pixelColor = [data[colorIdx], data[colorIdx + 1], data[colorIdx + 2]];
                        
                        // Skip pure black
                        if (pixelColor[0] <= 5 && pixelColor[1] <= 5 && pixelColor[2] <= 5) continue;
                        
                        // Check if this color fits into an existing family
                        let foundFamily = false;
                        for (let i = 0; i < colorFamilies.length; i++) {
                            const family = colorFamilies[i];
                            
                            // Check if color belongs to this family
                            if (sameColorFamily(pixelColor, family.referenceColor)) {
                                // Add to family
                                family.pixels.push(pixelIndex);
                                family.sumR += pixelColor[0];
                                family.sumG += pixelColor[1];
                                family.sumB += pixelColor[2];
                                family.count++;
                                
                                pixelFamilyMap[pixelIndex] = i;
                                foundFamily = true;
                                break;
                            }
                        }
                        
                        // If no matching family, create a new one
                        if (!foundFamily) {
                            const familyIndex = colorFamilies.length;
                            colorFamilies.push({
                                referenceColor: pixelColor,
                                pixels: [pixelIndex],
                                sumR: pixelColor[0],
                                sumG: pixelColor[1],
                                sumB: pixelColor[2],
                                count: 1,
                                mappingIndex: -1 // Will be set later
                            });
                            
                            pixelFamilyMap[pixelIndex] = familyIndex;
                        }
                    }
                }
                
                // Calculate average color for each family
                colorFamilies.forEach(family => {
                    family.avgColor = [
                        Math.round(family.sumR / family.count),
                        Math.round(family.sumG / family.count),
                        Math.round(family.sumB / family.count)
                    ];
                    
                    // Also calculate HSV for easier comparisons
                    family.hsv = rgbToHsv(...family.avgColor);
                });
                
                return { colorFamilies, pixelFamilyMap };
            }
            
            // Process color mappings
            function prepareColorMappings() {
                return colorMappings.map((mapping, index) => {
                    const { originalColor, targetColor } = mapping;
                    
                    // Convert to HSV for easier transformations
                    const originalHsv = rgbToHsv(...originalColor);
                    const targetHsv = rgbToHsv(...targetColor);
                    
                    // Calculate transformation parameters
                    let hueShift = targetHsv[0] - originalHsv[0];
                    if (hueShift > 180) hueShift -= 360;
                    else if (hueShift < -180) hueShift += 360;
                    
                    const satRatio = originalHsv[1] > 0 ? targetHsv[1] / originalHsv[1] : 1;
                    const valRatio = originalHsv[2] > 0 ? targetHsv[2] / originalHsv[2] : 1;
                    
                    return {
                        originalColor,
                        targetColor,
                        originalHsv,
                        targetHsv,
                        hueShift,
                        satRatio,
                        valRatio,
                        index
                    };
                });
            }
            
            // Map color families to color mappings
            function mapFamiliesToMappings(colorFamilies, processedMappings) {
                // For each color family, find the best matching source color
                colorFamilies.forEach(family => {
                    let bestMappingIndex = -1;
                    let bestDistance = Infinity;
                    
                    for (let i = 0; i < processedMappings.length; i++) {
                        const mapping = processedMappings[i];
                        
                        // Skip if not in same color family
                        if (!sameColorFamily(family.avgColor, mapping.originalColor)) {
                            continue;
                        }
                        
                        // Calculate distance - use simpler RGB distance for performance
                        const distance = Math.sqrt(
                            Math.pow(family.avgColor[0] - mapping.originalColor[0], 2) +
                            Math.pow(family.avgColor[1] - mapping.originalColor[1], 2) +
                            Math.pow(family.avgColor[2] - mapping.originalColor[2], 2)
                        );
                        
                        if (distance < bestDistance) {
                            bestDistance = distance;
                            bestMappingIndex = i;
                        }
                    }
                    
                    // If we found a good match (within threshold), assign it
                    // Use a more generous threshold for families that are gradients
                    const threshold = 150; // More generous threshold to ensure all families get mapped
                    
                    if (bestMappingIndex !== -1 && bestDistance < threshold) {
                        family.mappingIndex = bestMappingIndex;
                    }
                });
            }
            
            // Transform colors based on mapping, preserving color family relationships
            function transformColor(r, g, b, mappingIndex, isGradient = false, gradientStrength = 0) {
                // Get the mapping
                const mapping = processedMappings[mappingIndex];
                
                // Get color in HSV space
                const pixelHsv = rgbToHsv(r, g, b);
                
                // Check if color is achromatic (low saturation)
                const isAchromatic = pixelHsv[1] < 15;
                
                // Calculate how this color relates to the source color
                // For hue, calculate the difference with wrap-around handling
                let hueDiff = ((pixelHsv[0] - mapping.originalHsv[0] + 360) % 360);
                hueDiff = hueDiff > 180 ? hueDiff - 360 : hueDiff;
                
                // For saturation and value, calculate ratios
                const satRatio = mapping.originalHsv[1] > 0 ? pixelHsv[1] / mapping.originalHsv[1] : 1;
                const valRatio = mapping.originalHsv[2] > 0 ? pixelHsv[2] / mapping.originalHsv[2] : 1;
                
                // Different transformation strategy based on pixel characteristics
                let newHue, newSat, newVal;
                
                if (isAchromatic) {
                    // For grayscale, focus on value transformation
                    newHue = mapping.targetHsv[0]; // Take target hue directly
                    
                    // Take some saturation from target, but keep it low
                    newSat = Math.min(mapping.targetHsv[1] * 0.3, pixelHsv[1] * mapping.satRatio);
                    
                    // Transform value while preserving relative brightness
                    newVal = Math.max(0, Math.min(100, pixelHsv[2] * mapping.valRatio));
                } 
                else if (isGradient) {
                    // For gradients, preserve relative relationships more strongly
                    // Calculate adaptive transformation strength based on gradient intensity
                    const strength = Math.max(0.7, 1 - gradientStrength * 0.3);
                    
                    // For gradients, we maintain the hue difference but rotate to target
                    newHue = (mapping.targetHsv[0] + hueDiff) % 360;
                    if (newHue < 0) newHue += 360;
                    
                    // For saturation and value, we keep the relationship to original
                    newSat = Math.max(0, Math.min(100, mapping.targetHsv[1] * satRatio));
                    newVal = Math.max(0, Math.min(100, mapping.targetHsv[2] * valRatio));
                    
                    // For very dark colors in gradients, boost saturation slightly to match target better
                    if (pixelHsv[2] < 30) {
                        newSat = Math.min(100, newSat * 1.2);
                    }
                } 
                else {
                    // Regular transformation - apply target with preserved relationship
                    newHue = (mapping.targetHsv[0] + hueDiff * 0.5) % 360; // Partial preservation of hue offset
                    if (newHue < 0) newHue += 360;
                    
                    newSat = Math.max(0, Math.min(100, mapping.targetHsv[1] * satRatio));
                    newVal = Math.max(0, Math.min(100, mapping.targetHsv[2] * valRatio));
                }
                
                // Convert back to RGB
                return hsvToRgb(newHue, newSat, newVal);
            }
            
            // Main processing pipeline
            
            // Step 1: Detect gradients
            console.log("Detecting gradients...");
            const { gradientMap, gradientStrengthMap } = detectGradients();
            
            // Step 2: Identify color families
            console.log("Identifying color families...");
            const { colorFamilies, pixelFamilyMap } = identifyColorFamilies();
            
            // Step 3: Process mappings
            console.log("Processing color mappings...");
            const processedMappings = prepareColorMappings();
            
            // Step 4: Map families to mappings
            console.log("Mapping color families to target colors...");
            mapFamiliesToMappings(colorFamilies, processedMappings);
            
            // Step 5: Transform colors
            console.log("Transforming colors...");
            
            // Use a cache for processed colors
            const transformCache = new Map();
            
            // Apply transformations
            for (let i = 0; i < data.length; i += 4) {
                if (data[i + 3] < 128) continue; // Skip transparent
                
                const r = data[i], g = data[i + 1], b = data[i + 2];
                
                // Skip pure black
                if (r <= 5 && g <= 5 && b <= 5) continue;
                
                const pixelIndex = Math.floor(i / 4);
                const familyIndex = pixelFamilyMap[pixelIndex];
                
                // Skip pixels not assigned to a family
                if (familyIndex === -1) continue;
                
                const family = colorFamilies[familyIndex];
                
                // Skip families without a mapping
                if (family.mappingIndex === -1) continue;
                
                // Check cache for this color
                const colorKey = `${r},${g},${b}`;
                if (transformCache.has(colorKey)) {
                    const cachedColor = transformCache.get(colorKey);
                    data[i] = cachedColor[0];
                    data[i + 1] = cachedColor[1];
                    data[i + 2] = cachedColor[2];
                    continue;
                }
                
                // Check if this pixel is part of a gradient
                const isGradient = gradientMap[pixelIndex];
                const gradientStrength = gradientStrengthMap[pixelIndex];
                
                // Transform the color
                const newColor = transformColor(r, g, b, family.mappingIndex, isGradient, gradientStrength);
                
                // Apply the transformed color
                data[i] = newColor[0];
                data[i + 1] = newColor[1];
                data[i + 2] = newColor[2];
                
                // Cache this transformation
                transformCache.set(colorKey, newColor);
            }
            
            // Step 6: Smooth gradient transitions
            console.log("Smoothing gradients...");
            
            // Only smooth if there are any gradient pixels
            let hasGradients = false;
            for (let i = 0; i < gradientMap.length; i++) {
                if (gradientMap[i]) {
                    hasGradients = true;
                    break;
                }
            }
            
            if (hasGradients) {
                const tempData = new Uint8ClampedArray(data);
                
                // Only process gradient pixels for better performance
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const pixelIndex = y * width + x;
                        
                        // Skip non-gradient pixels
                        if (!gradientMap[pixelIndex]) continue;
                        
                        const idx = pixelIndex * 4;
                        
                        // Skip transparent or pure black pixels
                        if (data[idx + 3] < 128 || (data[idx] <= 5 && data[idx + 1] <= 5 && data[idx + 2] <= 5)) {
                            continue;
                        }
                        
                        // Apply weighted smoothing
                        let rSum = 0, gSum = 0, bSum = 0, weightSum = 0;
                        
                        const kernelSize = 3; // 3x3 kernel for speed
                        
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const nx = x + dx;
                                const ny = y + dy;
                                
                                if (nx < 0 || nx >= width || ny < 0 || ny >= height) continue;
                                
                                const nidx = (ny * width + nx) * 4;
                                if (data[nidx + 3] < 128) continue;
                                
                                // Use a gaussian-like weight
                                const weight = (dx === 0 && dy === 0) ? 0.5 : 0.125;
                                
                                rSum += data[nidx] * weight;
                                gSum += data[nidx + 1] * weight;
                                bSum += data[nidx + 2] * weight;
                                weightSum += weight;
                            }
                        }
                        
                        if (weightSum > 0) {
                            const blendStrength = gradientStrengthMap[pixelIndex] * 0.7;
                            
                            tempData[idx] = Math.round((1 - blendStrength) * data[idx] + blendStrength * (rSum / weightSum));
                            tempData[idx + 1] = Math.round((1 - blendStrength) * data[idx + 1] + blendStrength * (gSum / weightSum));
                            tempData[idx + 2] = Math.round((1 - blendStrength) * data[idx + 2] + blendStrength * (bSum / weightSum));
                        }
                    }
                }
                
                // Apply smoothed values only to gradient pixels
                for (let i = 0; i < gradientMap.length; i++) {
                    if (gradientMap[i]) {
                        const idx = i * 4;
                        if (data[idx + 3] >= 128 && !(data[idx] <= 5 && data[idx + 1] <= 5 && data[idx + 2] <= 5)) {
                            data[idx] = tempData[idx];
                            data[idx + 1] = tempData[idx + 1];
                            data[idx + 2] = tempData[idx + 2];
                        }
                    }
                }
            }
            
            console.log("Finished color mapping!");

            // Apply the changes to the canvas
            ctx.putImageData(imageDataObj, 0, 0);
            const dataUrl = canvasElement.toDataURL('image/png');
            console.timeEnd('colorMapping');
            resolve(dataUrl);
        };
        img.src = imageData;
    });
}

  // Helper methods
  calculateAdaptiveThreshold(color, baseThreshold) {
      const saturation = color.hsv[1];
      const value = color.hsv[2];
      return baseThreshold * (1 + (1 - saturation) * 0.5) * (1 + (1 - value) * 0.5);
  }
  
  calculateHSVDifference(hsv1, hsv2) {
      const hueDiff = Math.abs(hsv1[0] - hsv2[0]) / 360;
      const satDiff = Math.abs(hsv1[1] - hsv2[1]);
      const valDiff = Math.abs(hsv1[2] - hsv2[2]);
      return (hueDiff + satDiff + valDiff) / 3;
  }
  
  calculateColorImportance(color) {
      const saturationWeight = 0.3;
      const valueWeight = 0.2;
      const frequencyWeight = 0.5;
  
      return (color.hsv[1] * saturationWeight) +
             (color.hsv[2] * valueWeight) +
             (color.percentage * frequencyWeight);
  }
  
  filterDistinctColors(colors) {
      const distinct = [];
      const minDistance = 15; // Minimum distance for distinct colors
  
      for (const color of colors) {
          const isDistinct = !distinct.some(existingColor =>
              this.calculateColorDistance(color.lab, existingColor.lab) < minDistance &&
              this.calculateHSVDifference(color.hsv, existingColor.hsv) < 0.2
          );
  
          if (isDistinct) {
              distinct.push(color);
          }
      }
  
      return distinct;
  }
  
  rgbToHsv(r, g, b) {
      r /= 255;
      g /= 255;
      b /= 255;
  
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      const diff = max - min;
  
      let h = 0;
      let s = max === 0 ? 0 : diff / max;
      let v = max;
  
      if (max !== min) {
          switch (max) {
              case r: h = (g - b) / diff + (g < b ? 6 : 0); break;
              case g: h = (b - r) / diff + 2; break;
              case b: h = (r - g) / diff + 4; break;
          }
          h /= 6;
      }
  
      return [h, s, v];
  }


  async applyColorMapping(imageData, colorMapping, targetColor, dominantColor, totalLayers) {
    return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
            const canvasElement = document.createElement('canvas');
            const ctx = canvasElement.getContext('2d');
            canvasElement.width = img.width;
            canvasElement.height = img.height;

            ctx.drawImage(img, 0, 0);
            const imageDataObj = ctx.getImageData(0, 0, img.width, img.height);
            const data = imageDataObj.data;

            // Color conversion utilities
            function rgbToLab(r, g, b) {
                r /= 255; g /= 255; b /= 255;

                r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
                g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
                b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;

                let x = (r * 0.4124564 + g * 0.3575761 + b * 0.1804375) * 100;
                let y = (r * 0.2126729 + g * 0.7151522 + b * 0.0721750) * 100;
                let z = (r * 0.0193339 + g * 0.1191920 + b * 0.9503041) * 100;

                x /= 95.047; y /= 100; z /= 108.883;

                x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + 16/116;
                y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + 16/116;
                z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + 16/116;

                return [
                    116 * y - 16,   // L
                    500 * (x - y),   // a
                    200 * (y - z)    // b
                ];
            }

            function rgbToHsv(r, g, b) {
                r /= 255; g /= 255; b /= 255;
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                const d = max - min;
                let h, s = max === 0 ? 0 : d / max, v = max;

                if (max === min) {
                    h = 0;
                } else {
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    h /= 6;
                }
                return [h * 360, s * 100, v * 100];
            }

            // Get color properties
            const dominantHsv = rgbToHsv(...dominantColor);
            const targetHsv = rgbToHsv(...targetColor);
            const dominantLab = rgbToLab(...dominantColor);
            const targetLab = rgbToLab(...targetColor);

            // Create color clusters
            const colorClusters = new Map();
            for (let i = 0; i < data.length; i += 4) {
                if (data[i + 3] < 128) continue;

                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                const pixelHsv = rgbToHsv(r, g, b);
                const pixelLab = rgbToLab(r, g, b);

                // Calculate multiple similarity metrics
                const labDistance = Math.sqrt(
                    Math.pow(pixelLab[0] - dominantLab[0], 2) +
                    Math.pow(pixelLab[1] - dominantLab[1], 2) +
                    Math.pow(pixelLab[2] - dominantLab[2], 2)
                );

                const hueDistance = Math.abs(pixelHsv[0] - dominantHsv[0]);
                const normalizedHueDistance = hueDistance > 180 ? 360 - hueDistance : hueDistance;
                
                // Create cluster key based on quantized values
                const clusterKey = [
                    Math.round(pixelHsv[0] / 10) * 10,
                    Math.round(pixelHsv[1] / 10) * 10,
                    Math.round(pixelHsv[2] / 10) * 10
                ].join(',');

                if (!colorClusters.has(clusterKey)) {
                    colorClusters.set(clusterKey, {
                        count: 0,
                        sumRGB: [0, 0, 0],
                        labDistance,
                        hueDistance: normalizedHueDistance
                    });
                }

                const cluster = colorClusters.get(clusterKey);
                cluster.count++;
                cluster.sumRGB[0] += r;
                cluster.sumRGB[1] += g;
                cluster.sumRGB[2] += b;
            }

            // Process each pixel using cluster information
            for (let i = 0; i < data.length; i += 4) {
                if (data[i + 3] < 128) continue;

                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                const pixelHsv = rgbToHsv(r, g, b);
                const clusterKey = [
                    Math.round(pixelHsv[0] / 10) * 10,
                    Math.round(pixelHsv[1] / 10) * 10,
                    Math.round(pixelHsv[2] / 10) * 10
                ].join(',');

                const cluster = colorClusters.get(clusterKey);
                if (!cluster) continue;

                // Determine if color should be transformed
                const shouldTransform = (
                    cluster.labDistance < 45 || // Similar in Lab space
                    cluster.hueDistance < 30 || // Similar hue
                    (pixelHsv[1] < 20 && Math.abs(pixelHsv[2] - dominantHsv[2]) < 30) // Handle grays
                );

                if (shouldTransform) {
                    // Calculate transformation ratios
                    const hueDiff = targetHsv[0] - dominantHsv[0];
                    const satDiff = targetHsv[1] - dominantHsv[1];
                    const valDiff = targetHsv[2] - dominantHsv[2];

                    // Apply transformation while preserving relative relationships
                    let newHue = (pixelHsv[0] + hueDiff) % 360;
                    if (newHue < 0) newHue += 360;

                    let newSat = Math.max(0, Math.min(100,
                        pixelHsv[1] * (targetHsv[1] / Math.max(1, dominantHsv[1]))
                    ));

                    let newVal = Math.max(0, Math.min(100,
                        pixelHsv[2] * (targetHsv[2] / Math.max(1, dominantHsv[2]))
                    ));

                    // Convert back to RGB
                    const newRGB = hsvToRgb(newHue / 360, newSat / 100, newVal / 100);
                    
                    data[i] = newRGB[0];
                    data[i + 1] = newRGB[1];
                    data[i + 2] = newRGB[2];
                }
            }

            function hsvToRgb(h, s, v) {
                let r, g, b;
                const i = Math.floor(h * 6);
                const f = h * 6 - i;
                const p = v * (1 - s);
                const q = v * (1 - f * s);
                const t = v * (1 - (1 - f) * s);

                switch (i % 6) {
                    case 0: r = v; g = t; b = p; break;
                    case 1: r = q; g = v; b = p; break;
                    case 2: r = p; g = v; b = t; break;
                    case 3: r = p; g = q; b = v; break;
                    case 4: r = t; g = p; b = v; break;
                    case 5: r = v; g = p; b = q; break;
                }

                return [
                    Math.round(r * 255),
                    Math.round(g * 255),
                    Math.round(b * 255)
                ];
            }

            ctx.putImageData(imageDataObj, 0, 0);
            const dataUrl = canvasElement.toDataURL('image/png');
            resolve(dataUrl);
        };
        img.src = imageData;
    });
}
// Helper functions
calculateDeltaE(lab1, lab2) {
    const deltaL = lab1[0] - lab2[0];
    const deltaA = lab1[1] - lab2[1];
    const deltaB = lab1[2] - lab2[2];
    return Math.sqrt(deltaL * deltaL + deltaA * deltaA + deltaB * deltaB);
}

hsvToRgbProcessor(hsv) {
    let h = hsv[0];
    let s = hsv[1];
    let v = hsv[2];
    
    let r, g, b;
    const i = Math.floor(h * 6);
    const f = h * 6 - i;
    const p = v * (1 - s);
    const q = v * (1 - f * s);
    const t = v * (1 - (1 - f) * s);

    switch (i % 6) {
        case 0: r = v; g = t; b = p; break;
        case 1: r = q; g = v; b = p; break;
        case 2: r = p; g = v; b = t; break;
        case 3: r = p; g = q; b = v; break;
        case 4: r = t; g = p; b = v; break;
        case 5: r = v; g = p; b = q; break;
    }

    return [
        Math.round(r * 255),
        Math.round(g * 255),
        Math.round(b * 255)
    ];
}
}  
async function processHarmony(layerCtx, totalLayers, layerCanvas, currentLayerIndex, harmonyType) {
  const loadingScreen = document.getElementById('loading-screen');
  loadingScreen.style.display = 'block';
  const analyzer = new ImageColorAnalyzer();
  const colorProcessor = new ColorProcessor();

  try {
      if (totalLayers === 1) {
          // Single layer processing
          const layer = 1;
          const layerCanvas = document.getElementById(`layer_canvas_${layer}`);
          if (!layerCanvas) return;

          const layerCtx = layerCanvas.getContext('2d');
          if (!layerCtx) return;

          // Load and draw original image
          const originalImg = new Image();
          const originalSrc = layerCanvas.getAttribute('data-original-src');
          if (!originalSrc) {
              console.error('Original source not found');
              return;
          }

          await new Promise((resolve, reject) => {
              originalImg.onload = () => {
                  layerCtx.clearRect(0, 0, layerCanvas.width, layerCanvas.height);
                  layerCtx.drawImage(originalImg, 0, 0);
                  resolve();
              };
              originalImg.onerror = reject;
              originalImg.src = originalSrc;
          });

          // Analyze the image colors
          const tempImage = new Image();
          tempImage.src = layerCanvas.toDataURL('image/png');
          await new Promise(resolve => tempImage.onload = resolve);

          const colorAnalysis = await analyzer.analyzeImageColors(tempImage);
          if (!colorAnalysis || !colorAnalysis.dominantColor) {
              console.error('No dominant color found');
              return;
          }

          // Generate harmony colors based on the dominant color
          const harmonyColors = generateHarmonyColors(colorAnalysis.dominantColor, harmonyType);

          // Create variation canvases for each harmony color
          const variationCanvases = [];
          for (let i = 0; i < harmonyColors.length; i++) {
              const variationCanvas = document.createElement('canvas');
              variationCanvas.width = layerCanvas.width;
              variationCanvas.height = layerCanvas.height;
              variationCanvas.style.display = 'none';
              document.body.appendChild(variationCanvas);
              variationCanvases.push(variationCanvas);
          }

          // Process the image with each harmony color
          for (let i = 0; i < harmonyColors.length; i++) {
              const targetColor = harmonyColors[i];
              const variationCanvas = variationCanvases[i];
              const variationCtx = variationCanvas.getContext('2d');

              // Get the base64 data of the original image
              const base64Data = layerCanvas.toDataURL('image/png');

              // Apply the harmony color
              const colorMapping = await colorProcessor.getColorMapping(base64Data);
              const modifiedImage = await colorProcessor.applyColorMapping(
                  base64Data,
                  colorMapping,
                  targetColor,
                  colorAnalysis.dominantColor
              );

              // Draw the modified image to the variation canvas
              await new Promise((resolve) => {
                  const img = new Image();
                  img.onload = () => {
                      variationCtx.clearRect(0, 0, variationCanvas.width, variationCanvas.height);
                      variationCtx.drawImage(img, 0, 0);
                      resolve();
                  };
                  img.src = modifiedImage;
              });

              // Process secondary colors if needed
              const updatedImage = new Image();
              updatedImage.src = variationCanvas.toDataURL('image/png');
              await new Promise(resolve => updatedImage.onload = resolve);

              const updatedColorAnalysis = await analyzer.analyzeImageColors(updatedImage);
              if (updatedColorAnalysis.otherColors) {
                  const secondaryColors = updatedColorAnalysis.otherColors.filter(color => 
                      color.percentage > 3.0 &&
                      !isColorSimilar(color.rgb, targetColor)
                  );

                  for (let j = 0; j < secondaryColors.length && j < harmonyColors.length - 1; j++) {
                      await processLayerAsync(
                          variationCtx,
                          secondaryColors[j].rgb,
                          harmonyColors[(i + j + 1) % harmonyColors.length]
                      );
                  }
              }
          }

          // Apply the final result to the main canvas
          layerCtx.clearRect(0, 0, layerCanvas.width, layerCanvas.height);
          layerCtx.drawImage(variationCanvases[0], 0, 0);

          // Clean up variation canvases
          variationCanvases.forEach(canvas => canvas.remove());

      } else {
          // Multi-layer processing
          let dominantColor = null;
          let firstUnlockedLayer = null;

          // Find the first unlocked layer and its dominant color
          for (let layer = 1; layer <= totalLayers; layer++) {
              const colorButton = document.querySelector(`.color-picker[data-layer-index="${layer-1}"]`);
              if (!colorButton || colorButton.dataset.locked !== 'true') {
                  firstUnlockedLayer = layer;
                  const layerCanvas = document.getElementById(`layer_canvas_${layer}`);
                  if (layerCanvas) {
                      const tempImage = new Image();
                      tempImage.src = layerCanvas.toDataURL('image/png');
                      await new Promise(resolve => tempImage.onload = resolve);
                      const colorAnalysis = await analyzer.analyzeImageColors(tempImage);
                      if (colorAnalysis && colorAnalysis.dominantColor) {
                          dominantColor = colorAnalysis.dominantColor;
                          break;
                      }
                  }
              }
          }

          if (!dominantColor) {
              console.error('No dominant color found');
              return;
          }

          // Generate harmony colors based on the dominant color
          const harmonyColors = generateHarmonyColors(dominantColor, harmonyType);

          // Process each layer with harmony colors
          for (let layer = 1; layer <= totalLayers; layer++) {
              const colorButton = document.querySelector(`.color-picker[data-layer-index="${layer-1}"]`);
              if (colorButton && colorButton.dataset.locked === 'true') {
                  console.log(`Layer ${layer} is locked, skipping processing`);
                  continue;
              }

              const layerCanvas = document.getElementById(`layer_canvas_${layer}`);
              if (!layerCanvas) continue;

              const layerCtx = layerCanvas.getContext('2d');
              if (!layerCtx) continue;

              // Load and draw original image
              const originalImg = new Image();
              const originalSrc = layerCanvas.getAttribute('data-original-src');
              if (!originalSrc) continue;

              await new Promise((resolve) => {
                  originalImg.onload = () => {
                      layerCtx.clearRect(0, 0, layerCanvas.width, layerCanvas.height);
                      layerCtx.drawImage(originalImg, 0, 0);
                      resolve();
                  };
                  originalImg.src = originalSrc;
              });

              const tempImage = new Image();
              tempImage.src = layerCanvas.toDataURL('image/png');
              await new Promise(resolve => tempImage.onload = resolve);

              const colorAnalysis = await analyzer.analyzeImageColors(tempImage);
              if (!colorAnalysis) continue;

              // Determine which harmony color to use based on layer position
              const harmonyIndex = (layer - firstUnlockedLayer) % harmonyColors.length;
              const targetColor = harmonyColors[harmonyIndex];

              // Apply the harmony color
              const base64Data = layerCanvas.toDataURL('image/png');
              const colorMapping = await colorProcessor.getColorMapping(base64Data);
              const modifiedImage = await colorProcessor.applyColorMapping(
                  base64Data,
                  colorMapping,
                  targetColor,
                  colorAnalysis.dominantColor
              );

              // Update the canvas with the new color
              await new Promise((resolve) => {
                  const img = new Image();
                  img.onload = () => {
                      layerCtx.clearRect(0, 0, layerCanvas.width, layerCanvas.height);
                      layerCtx.drawImage(img, 0, 0);
                      resolve();
                  };
                  img.src = modifiedImage;
              });

              updateFooterColorButton(layer, targetColor);
          }
      }
  } catch (error) {
      console.error("Error while processing harmony:", error);
  } finally {
      loadingScreen.style.display = 'none';
  }
}

// Color Conversion Utilities
function rgbToHsl(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;

  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  let h, s, l = (max + min) / 2;

  if (max === min) {
      h = s = 0;
  } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

      switch (max) {
          case r: h = (g - b) / d + (g < b ? 6 : 0); break;
          case g: h = (b - r) / d + 2; break;
          case b: h = (r - g) / d + 4; break;
      }
      h /= 6;
  }

  return [h, s, l];
}

function hslToRgb(h, s, l) {
  let r, g, b;

  if (s === 0) {
      r = g = b = l;
  } else {
      const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
      };

      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;

      r = hue2rgb(p, q, h + 1/3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1/3);
  }

  return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}

// Updated Harmony Generation Functions with variations
function generateMonochromatic(hsl) {
  const [h, s, l] = hsl;
  const variation = Math.random() * 0.2; // Random variation

  return [
      [h, s, l],
      [h, s, Math.min(l + 0.2 + variation, 0.9)],
      [h, s, Math.max(l - 0.2 - variation, 0.1)],
      [h, Math.min(s + 0.15 + variation, 1), l],
      [h, Math.max(s - 0.15 - variation, 0), l]
  ];
}

function generateAnalogous(hsl) {
  const [h, s, l] = hsl;
  const variation = Math.random() * 0.05; // Random angle variation

  return [
      [h, s, l],
      [(h + (1/12 + variation)) % 1, s, l],
      [(h - (1/12 + variation) + 1) % 1, s, Math.min(l + 0.1, 0.9)],
      [(h + (1/6 + variation)) % 1, s, Math.max(l - 0.1, 0.1)],
      [(h - (1/6 + variation) + 1) % 1, Math.min(s + 0.1, 1), l]
  ];
}

function generateComplementary(hsl) {
  const [h, s, l] = hsl;
  const variation = Math.random() * 0.1; // Random variation

  return [
      [h, s, l],
      [(h + 0.5) % 1, s + variation, l],
      [h, Math.min(s + 0.2 + variation, 1), l],
      [h, s, Math.min(l + 0.15 + variation, 0.9)],
      [(h + 0.5) % 1, Math.min(s + 0.15 + variation, 1), Math.min(l + 0.15, 0.9)]
  ];
}

function generateSplitComplementary(hsl) {
  const [h, s, l] = hsl;
  const variation = Math.random() * 0.05; // Random angle variation

  return [
      [h, s, l],
      [(h + 0.5 + (1/12 + variation)) % 1, s, Math.min(l + 0.1, 0.9)],
      [(h + 0.5 - (1/12 + variation) + 1) % 1, s, Math.max(l - 0.1, 0.1)],
      [h, Math.min(s + 0.15 + variation, 1), l],
      [(h + 0.5) % 1, Math.min(s + 0.1, 1), Math.min(l + 0.15, 0.9)]
  ];
}

function generateTriadic(hsl) {
  const [h, s, l] = hsl;
  const variation = Math.random() * 0.05; // Random variation

  return [
      [h, s, l],
      [(h + (1/3 + variation)) % 1, Math.min(s + 0.1, 1), l],
      [(h + (2/3 - variation)) % 1, s, Math.min(l + 0.1, 0.9)],
      [(h + (1/3 + variation)) % 1, Math.max(s - 0.1, 0), Math.max(l - 0.1, 0.1)],
      [(h + (2/3 - variation)) % 1, Math.min(s + 0.15, 1), l]
  ];
}

function generateTetradic(hsl) {
  const [h, s, l] = hsl;
  const variation = Math.random() * 0.05; // Random variation

  return [
      [h, s, l],
      [(h + (0.25 + variation)) % 1, Math.min(s + 0.1, 1), l],
      [(h + (0.5 - variation)) % 1, s, Math.min(l + 0.1, 0.9)],
      [(h + (0.75 + variation)) % 1, Math.max(s - 0.1, 0), Math.max(l - 0.1, 0.1)],
      [h, Math.min(s + 0.15, 1), Math.min(l + 0.15, 0.9)]
  ];
}

function generateSquare(hsl) {
  const [h, s, l] = hsl;
  const variation = Math.random() * 0.05; // Random variation

  return [
      [h, s, l],
      [(h + (0.25 + variation)) % 1, Math.min(s + 0.1, 1), Math.min(l + 0.1, 0.9)],
      [(h + (0.5 - variation)) % 1, Math.max(s - 0.1, 0), l],
      [(h + (0.75 + variation)) % 1, s, Math.max(l - 0.1, 0.1)],
      [h, Math.min(s + 0.2, 1), Math.min(l + 0.15, 0.9)]
  ];
}

// Helper function to add subtle variations to colors
function addVariation(value, amount, min = 0, max = 1) {
  const variation = (Math.random() - 0.5) * 2 * amount;
  return Math.max(min, Math.min(max, value + variation));
}

// Additional function to ensure colors are visually distinct
function ensureDistinctColors(colors) {
  return colors.map((color, index) => {
      if (index === 0) return color; // Keep the base color unchanged
      
      const [h, s, l] = color;
      return [
          addVariation(h, 0.05),
          addVariation(s, 0.1, 0.2, 1),
          addVariation(l, 0.1, 0.2, 0.8)
      ];
  });
}

// Modify the generateHarmonyColors function to use ensureDistinctColors
function generateHarmonyColors(baseColor, harmonyType) {
  const hsl = rgbToHsl(baseColor[0], baseColor[1], baseColor[2]);
  let colors = [];

  switch (harmonyType) {
      case 'Monochromatic':
          colors = generateMonochromatic(hsl);
          break;
      case 'Analogous':
          colors = generateAnalogous(hsl);
          break;
      case 'Complementary':
          colors = generateComplementary(hsl);
          break;
      case 'Split Complementary':
          colors = generateSplitComplementary(hsl);
          break;
      case 'Triadic':
          colors = generateTriadic(hsl);
          break;
      case 'Tetradic':
          colors = generateTetradic(hsl);
          break;
      case 'Square':
          colors = generateSquare(hsl);
          break;
  }

  // Ensure colors are distinct
  colors = ensureDistinctColors(colors);
  
  // Convert back to RGB
  return colors.map(hsl => hslToRgb(hsl[0], hsl[1], hsl[2]));
}
document.addEventListener('DOMContentLoaded', function() {
  const harmonyButton = document.getElementById('harmonyButton');
  const harmonyMenu = document.getElementById('harmonyMenu');
  let selectedHarmony = '';

  // Toggle menu on button click
  harmonyButton.addEventListener('click', function(e) {
      e.stopPropagation();
      harmonyMenu.style.display = harmonyMenu.style.display === 'none' ? 'block' : 'none';
  });

  // Handle menu item selection
  document.querySelectorAll('.menu-item').forEach(item => {
      item.addEventListener('click', function(e) {
          e.stopPropagation();
          selectedHarmony = this.dataset.harmony;
          
          // Remove active class from all items
          document.querySelectorAll('.menu-item').forEach(i => i.classList.remove('active'));
          // Add active class to selected item
          this.classList.add('active');
          
          // Close menu
          harmonyMenu.style.display = 'none';
          
          // Process harmony
          const totalLayers = document.querySelectorAll('[id^="layer_canvas_"]').length;
          const firstCanvas = document.getElementById('layer_canvas_1');
          if (firstCanvas) {
              const ctx = firstCanvas.getContext('2d');
              processHarmony(ctx, totalLayers, firstCanvas, 0, selectedHarmony);
          }
      });
  });

  // Close menu when clicking outside
  document.addEventListener('click', function(e) {
      if (!harmonyButton.contains(e.target) && !harmonyMenu.contains(e.target)) {
          harmonyMenu.style.display = 'none';
      }
  });

  // Prevent menu from closing when clicking inside it
  harmonyMenu.addEventListener('click', function(e) {
      e.stopPropagation();
  });
});
class ImageAdjuster {
  constructor() {
        this.adjustments = {
            combined: {
                hue: 0,
                saturation: 0,
                brightness: 0,
                temperature: 0
            }
        };
        this.showIndividualLayers = false;
        this.setupEventListeners();
        this.originalImageData = {}; // Change to object to store data for each layer
    }

    setupEventListeners() {
        const toggleButton = document.getElementById('adjustmentToggle');
        const adjustmentPanel = document.getElementById('adjustmentPanel');

        toggleButton.addEventListener('click', () => {
            const isHidden = adjustmentPanel.style.display === 'none';
            adjustmentPanel.style.display = isHidden ? 'block' : 'none';
            if (isHidden) {
                this.createAdjustmentSliders();
            }
        });
    }

    createAdjustmentSliders() {
        const container = document.querySelector('.sliders-container');
        container.innerHTML = '';

        // Add toggle button for individual layers
        const toggleLayersBtn = document.createElement('button');
        toggleLayersBtn.textContent = this.showIndividualLayers ? 'Show Combined Layer' : 'Show Individual Layers';
        toggleLayersBtn.className = 'toggle-layers-btn';
        toggleLayersBtn.style.cssText = `
            margin-bottom: 15px;
            padding: 8px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
        `;
        toggleLayersBtn.addEventListener('click', () => {
            this.showIndividualLayers = !this.showIndividualLayers;
            this.createAdjustmentSliders();
        });
        container.appendChild(toggleLayersBtn);

        if (!this.showIndividualLayers) {
            // Create combined layer controls
            const combinedDiv = document.createElement('div');
            combinedDiv.className = 'layer-adjustments';
            combinedDiv.innerHTML = `
                <h4>All Layers</h4>
                <div class="slider-group">
                    <label>Hue</label>
                    <input type="range" min="-180" max="180" value="${this.adjustments.combined.hue}" 
                           data-layer="combined" data-adjustment="hue">
                </div>
                <div class="slider-group">
                    <label>Saturation</label>
                    <input type="range" min="-100" max="100" value="${this.adjustments.combined.saturation}" 
                           data-layer="combined" data-adjustment="saturation">
                </div>
                <div class="slider-group">
                    <label>Brightness</label>
                    <input type="range" min="-100" max="100" value="${this.adjustments.combined.brightness}" 
                           data-layer="combined" data-adjustment="brightness">
                </div>
                <div class="slider-group">
                    <label>Temperature</label>
                    <input type="range" min="-100" max="100" value="${this.adjustments.combined.temperature}" 
                           data-layer="combined" data-adjustment="temperature">
                </div>
            `;
            container.appendChild(combinedDiv);

            this.setupSliderListeners(combinedDiv);
        } else {
            // Create individual layer controls
            const layerCanvases = document.querySelectorAll('[id^="layer_canvas_"]');
            
            layerCanvases.forEach(layerCanvas => {
                const layer = layerCanvas.id.split('_')[2];
                
                // Initialize layer adjustments if they don't exist
                if (!this.adjustments[layer]) {
                    this.adjustments[layer] = {
                        hue: 0,
                        saturation: 0,
                        brightness: 0,
                        temperature: 0
                    };
                }

                const layerDiv = document.createElement('div');
                layerDiv.className = 'layer-adjustments';
                layerDiv.innerHTML = `
                    <h4>Layer ${layer}</h4>
                    <div class="slider-group">
                        <label>Hue</label>
                        <input type="range" min="-180" max="180" value="${this.adjustments[layer].hue}" 
                               data-layer="${layer}" data-adjustment="hue">
                    </div>
                    <div class="slider-group">
                        <label>Saturation</label>
                        <input type="range" min="-100" max="100" value="${this.adjustments[layer].saturation}" 
                               data-layer="${layer}" data-adjustment="saturation">
                    </div>
                    <div class="slider-group">
                        <label>Brightness</label>
                        <input type="range" min="-100" max="100" value="${this.adjustments[layer].brightness}" 
                               data-layer="${layer}" data-adjustment="brightness">
                    </div>
                    <div class="slider-group">
                        <label>Temperature</label>
                        <input type="range" min="-100" max="100" value="${this.adjustments[layer].temperature}" 
                               data-layer="${layer}" data-adjustment="temperature">
                    </div>
                `;

                container.appendChild(layerDiv);
                this.setupSliderListeners(layerDiv);
            });
        }
    }

    setupSliderListeners(containerDiv) {
        containerDiv.querySelectorAll('input[type="range"]').forEach(slider => {
            slider.addEventListener('input', (e) => {
                const layer = e.target.dataset.layer;
                const adjustment = e.target.dataset.adjustment;
                
                // Initialize layer adjustments if they don't exist
                if (!this.adjustments[layer]) {
                    this.adjustments[layer] = {
                        hue: 0,
                        saturation: 0,
                        brightness: 0,
                        temperature: 0
                    };
                }

                this.adjustments[layer][adjustment] = parseInt(e.target.value);
                
                if (layer === 'combined') {
                    // Apply to all layers
                    const layerCanvases = document.querySelectorAll('[id^="layer_canvas_"]');
                    layerCanvases.forEach(canvas => {
                        const layerNum = canvas.id.split('_')[2];
                        // Initialize layer adjustments if they don't exist
                        if (!this.adjustments[layerNum]) {
                            this.adjustments[layerNum] = {
                                hue: 0,
                                saturation: 0,
                                brightness: 0,
                                temperature: 0
                            };
                        }
                        this.adjustments[layerNum][adjustment] = parseInt(e.target.value);
                        this.applyAdjustments(layerNum);
                    });
                } else {
                    this.applyAdjustments(layer);
                }
            });
        });
    }

    applyAdjustments(layer) {
    const layerCanvas = document.getElementById(`layer_canvas_${layer}`);
    if (!layerCanvas) return;

    if (!this.adjustments[layer]) {
        this.adjustments[layer] = {
            hue: 0,
            saturation: 0,
            brightness: 0,
            temperature: 0
        };
    }

    const ctx = layerCanvas.getContext('2d');
    const imageData = ctx.getImageData(0, 0, layerCanvas.width, layerCanvas.height);
    const data = imageData.data;

    // Store original image data if not already stored for this layer
    if (!this.originalImageData[layer]) {
        this.originalImageData[layer] = new Uint8ClampedArray(data);
    }

    for (let i = 0; i < data.length; i += 4) {
        // Start from original values for this layer
        let r = this.originalImageData[layer][i];
        let g = this.originalImageData[layer][i + 1];
        let b = this.originalImageData[layer][i + 2];

            // Apply temperature adjustment
            const temp = this.adjustments[layer].temperature;
            if (temp !== 0) {
                const adjustment = temp / 100;
                if (adjustment > 0) {
                    // Warming: increase red, decrease blue
                    r = Math.min(255, r + (adjustment * 30));
                    b = Math.max(0, b - (adjustment * 30));
                } else {
                    // Cooling: decrease red, increase blue
                    r = Math.max(0, r - (Math.abs(adjustment) * 30));
                    b = Math.min(255, b + (Math.abs(adjustment) * 30));
                }
            }

            // Convert to HSL for other adjustments
            let [h, s, l] = this.rgbToHsl(r, g, b);

            // Apply other adjustments
            h = (h + this.adjustments[layer].hue) % 360;
            if (h < 0) h += 360;
            s = Math.max(0, Math.min(100, s + this.adjustments[layer].saturation));
            l = Math.max(0, Math.min(100, l + this.adjustments[layer].brightness));

            // Convert back to RGB
            [r, g, b] = this.hslToRgb(h, s, l);

            // Set final values
            data[i] = Math.round(Math.max(0, Math.min(255, r)));
            data[i + 1] = Math.round(Math.max(0, Math.min(255, g)));
            data[i + 2] = Math.round(Math.max(0, Math.min(255, b)));
            // Alpha channel remains unchanged
        }

        ctx.putImageData(imageData, 0, 0);
    }


    rgbToHsl(r, g, b) {
        r /= 255;
        g /= 255;
        b /= 255;

        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;

        if (max === min) {
            h = s = 0;
        } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }

        return [h * 360, s * 100, l * 100];
    }

    hslToRgb(h, s, l) {
        h /= 360;
        s /= 100;
        l /= 100;

        let r, g, b;

        if (s === 0) {
            r = g = b = l;
        } else {
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            };

            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;

            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
        }

        return [r * 255, g * 255, b * 255];
    }
}

// Initialize the adjuster
const imageAdjuster = new ImageAdjuster();


      function showLayerInfoButton(layerIndex) {
        // Save current canvas state before showing modal
        const canvas = document.getElementById(`layer_canvas_${layerIndex + 1}`);
        if (canvas) {
            const currentState = canvas.toDataURL();
            canvas.setAttribute('data-current-state', currentState);
        }

        $('#colorPickerModal').modal('show');
        updateLayersWithNewColorCount(layerIndex + 1);
      }
      function showLayerInfo() {
         contextMenu.style.display = 'none';
         $('#colorPickerModal').modal('show');
         const layerIndex = contextMenu.dataset.layerIndex; // Assuming contextMenu is defined

         updateLayersWithNewColorCount(layerIndex);
       }
      document.addEventListener('DOMContentLoaded', function() {
        const layerColors = {};
        const loadingScreen = document.getElementById('loading-screen');
        const totalLayers = {{ layers|length }};
        let loadedImagesCount = 0;
        const loader = document.getElementById('loading-screen');
        function showContextMenu(event, layerIndex, layerName) {

          event.preventDefault();

          // Set the layer name in the context menu
          layerNameDisplay.innerText = layerName;

          // Get the clicked thumbnail’s coordinates
          const thumbnail = event.target.getBoundingClientRect();
          const toolbarWidth = document.querySelector('.toolbar').offsetWidth;

          // Position the context menu aligned to the toolbar, on the left side of the thumbnail
          contextMenu.style.left = `${thumbnail.left - toolbarWidth - 20}px`; // Adjust as needed
          contextMenu.style.top = `${thumbnail.top + window.scrollY}px`;
          contextMenu.style.display = 'block';
          contextMenu.dataset.layerIndex = layerIndex;

          // Temporarily disable pointer events to avoid immediate hiding
          setTimeout(() => {
            contextMenu.style.pointerEvents = 'auto';
          }, 0);
        }

        // Hide the context menu on clicking outside
        document.addEventListener('click', function(event) {
          if (contextMenu.style.display === 'block' && !contextMenu.contains(event.target) && !event.target.classList.contains('thumbnail')) {
            contextMenu.style.display = 'none';
          }
        });
        function checkIfAllImagesLoaded() {
            if (loadedImagesCount === totalLayers) {
                loadingScreen.style.display = 'none';
                createColorButtons();
            }
        }

      
        function isColorInArray(color, array) {
          return array.some(existingColor =>
              existingColor[0] === color[0] &&
              existingColor[1] === color[1] &&
              existingColor[2] === color[2]
          );
        }
        let distinctColorsArray = [];
        let singleLayerDistinctColorsArray = [];
        let distinctColorsArrayColorPallet = [];

        {% for layer in layers %}
        let img{{ forloop.counter }} = new Image();
        img{{ forloop.counter }}.src = "{{ layer.path }}";
        let canvas{{ forloop.counter }} = document.getElementById('layer_canvas_{{ forloop.counter }}');
        let ctx{{ forloop.counter }} = canvas{{ forloop.counter }}.getContext('2d', { willReadFrequently: true });
        let latestImageData{{ forloop.counter }} = null;
        img{{ forloop.counter }}.onload = function() {
          canvas{{ forloop.counter }}.width = img{{ forloop.counter }}.width;
          canvas{{ forloop.counter }}.height = img{{ forloop.counter }}.height;
          ctx{{ forloop.counter }}.drawImage(img{{ forloop.counter }}, 0, 0);
            layerStates.saveOriginalState({{ forloop.counter }});
            {% comment %} latestImageData{{ forloop.counter }} = ctx{{ forloop.counter }}.getImageData(0, 0, canvas{{ forloop.counter }}.width, canvas{{ forloop.counter }}.height); {% endcomment %}
            const imageData{{ forloop.counter }} = ctx{{ forloop.counter }}.getImageData(0, 0, canvas{{ forloop.counter }}.width, canvas{{ forloop.counter }}.height);

            // Add distinct colors to the set (ensures no duplicates)
            let colorCount = 0;
            let distinctColorTolarance = 0;
            
            if(totalLayers === 1) {
                // For single layer, get more colors with less tolerance
                distinctColorTolarance = 100; // Lower tolerance to detect more color variations
                colorCount = 20;  // Get more colors for single layer
            } else if(totalLayers > 5) {
                distinctColorTolarance = 180;
                colorCount = 7;
            } else {
                distinctColorTolarance = 190;
                colorCount = 7;
            }
            
            const analysis = analyzeImageLayer(ctx{{ forloop.counter }});
            let { avgLightness, hueTolerance, lightnessTolerance } = analysis;
            hueTolerance = hueTolerance*100;
            if(lightnessTolerance<0.5) lightnessTolerance=0.7;
            
            // Now this should return more colors for single layer
            let distinctColors{{ forloop.counter }} = getDistinctColors(imageData{{ forloop.counter }}, distinctColorTolarance, colorCount);
            console.log(distinctColors{{ forloop.counter }})
            //console.info(distinctColors{{forloop.counter}});
            

            distinctColors{{ forloop.counter }}.forEach((color, index) => {
              if (!isColorInArray(color, distinctColorsArray)) {
                // Remove the index == 0 condition to allow more colors
                // if(index == 0){  // Remove this condition
                  distinctColorsArrayColorPallet.push(color);
                // }  // Remove this
                distinctColorsArray.push(color);
              }
            });


            // Create a thumbnail
            const thumbnailCanvas = document.createElement('canvas');
            const thumbnailSize = 30;
            thumbnailCanvas.width = thumbnailSize;
            thumbnailCanvas.height = thumbnailSize;
            const thumbnailCtx = thumbnailCanvas.getContext('2d');
            thumbnailCtx.drawImage(img{{ forloop.counter }}, 0, 0, thumbnailSize, thumbnailSize);
            document.getElementById('thumbnail_{{ forloop.counter }}').src = thumbnailCanvas.toDataURL();

            // Increment the loaded image counter and check if all images are loaded
            loadedImagesCount++;
            checkIfAllImagesLoaded();
          };
          img{{ forloop.counter }}.onerror = function() {
              //console.error(`Failed to load image {{ forloop.counter }}`);
              loadedImagesCount++;
              checkIfAllImagesLoaded();
          };



          let layerName{{ forloop.counter }} = "{{ layer.name }}"; // Store the layer name
          let thumbnail{{ forloop.counter }} = document.getElementById('thumbnail_{{ forloop.counter }}');
          let layerNameElement{{ forloop.counter }} = document.querySelector(`#toggleLayer{{ forloop.counter }}`).nextElementSibling;
          if (thumbnail{{ forloop.counter }}) {
            thumbnail{{ forloop.counter }}.addEventListener('click', function(event) {
              showContextMenu(event, {{ forloop.counter }}, layerName{{ forloop.counter }});
            });
          }

          if (layerNameElement{{ forloop.counter }}) {
            layerNameElement{{ forloop.counter }}.addEventListener('click', function(event) {
              showContextMenu(event, {{ forloop.counter }}, layerName{{ forloop.counter }});
            });
          }
          loader.style.display = 'block';

          setTimeout(() => {
            const buttons = document.querySelectorAll('#image-color-pickers button');
            const rgbColors = generateUniqueRGBColorArray(distinctColorsArrayColorPallet.length+1);
            layerColors[{{ forloop.counter }}] = {
                targetColors: distinctColorsArrayColorPallet,
                newColors: rgbColors
            };
            
            const layerIndex = {{ forloop.counter }};
            const totalLayers = {{ layers|length }};
            
            // For single layer mode, we need to handle differently
            if (totalLayers === 1) {
                // Generate multiple palettes for single layer
                for (let i = 0; i < 10; i++) {
            
                    displayColorPalette(i, distinctColorsArrayColorPallet, 'trending', distinctColorsArrayColorPallet.length+1, totalLayers);
                    displayColorPalette(i, distinctColorsArrayColorPallet, 'ss', distinctColorsArrayColorPallet.length+1, totalLayers);
                    displayColorPalette(i, distinctColorsArrayColorPallet, 'aw', distinctColorsArrayColorPallet.length+1, totalLayers);
                }
            } else {
                // For multi-layer mode
                displayColorPalette(layerIndex, rgbColors, 'trending', distinctColorsArrayColorPallet.length+1, totalLayers);
                displayColorPalette(layerIndex, rgbColors, 'ss', distinctColorsArrayColorPallet.length+1, totalLayers);
                displayColorPalette(layerIndex, rgbColors, 'aw', distinctColorsArrayColorPallet.length+1, totalLayers);
            }
        
            const layerCanvas = document.getElementById(`layer_canvas_${layerIndex}`);
            const layerCtx = layerCanvas.getContext('2d', { willReadFrequently: true });
        
            if (totalLayers === 1) {
                // For single layer mode, set up all palette buttons (0-9)
                for (let i = 0; i < 10; i++) {
                    setupPaletteButton(`applyButton_${i}`, i, 'trending', layerIndex);
                    setupPaletteButton(`ss_applyButton_${i}`, i, 'ss', layerIndex);
                    setupPaletteButton(`aw_applyButton_${i}`, i, 'aw', layerIndex); 
                }
                
                // Also set up the main layer buttons that might use different IDs
                setupPaletteButton(`applyButton_${layerIndex}`, 0, 'trending', layerIndex);
                setupPaletteButton(`ss_applyButton_${layerIndex}`, 0, 'ss', layerIndex);
                setupPaletteButton(`aw_applyButton_${layerIndex}`, 0, 'aw', layerIndex);
                if (document.getElementById(`base_applyButton_${layerIndex}`)) {
                    setupPaletteButton(`base_applyButton_${layerIndex}`, 0, 'base', layerIndex);
                }
            } else {
                // For multi-layer mode, just set up the layer-specific buttons
                setupPaletteButton(`applyButton_${layerIndex}`, layerIndex, 'trending', layerIndex);
                setupPaletteButton(`ss_applyButton_${layerIndex}`, layerIndex, 'ss', layerIndex);
                setupPaletteButton(`aw_applyButton_${layerIndex}`, layerIndex, 'aw', layerIndex);
                if (document.getElementById(`base_applyButton_${layerIndex}`)) {
                    setupPaletteButton(`base_applyButton_${layerIndex}`, layerIndex, 'base', layerIndex);
                }
            }
            
            // Helper function to set up palette buttons consistently
            function setupPaletteButton(buttonId, paletteIndex, collection, targetLayerIndex) {
                const button = document.getElementById(buttonId);
                if (!button) {
                    // Button might not exist, especially in single layer mode with multiple palettes
                    return;
                }
                
                button.addEventListener('click', async function(event) {
                    console.log(`Button clicked: ${buttonId}, applying ${collection} palette ${paletteIndex} to layer ${targetLayerIndex}`);
                    
                    // Load the original image
                    const img = new Image();
                    img.src = "{{ layer.path }}";
                    
                    await new Promise((resolve) => {
                        img.onload = resolve;
                    });
                    
                    // Reset canvas to original image
                    const canvas = document.getElementById(`layer_canvas_${targetLayerIndex}`);
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                    
                    // Find the correct palette
                    const paletteId = `${collection}_colorPalette_${paletteIndex}`;
                    const currentPalette = document.getElementById(paletteId);
                    
                    if (!currentPalette) {
                        console.error(`Palette not found: ${paletteId}`);
                        return;
                    }
                    
                    console.log(`Found palette: ${paletteId}, extracting colors`);
                    
                    const paletteColors = Array.from(currentPalette.querySelectorAll('.color-swatch'))
                        .map(swatch => {
                            const style = window.getComputedStyle(swatch);
                            const color = style.backgroundColor;
                            return color.match(/\d+/g).map(Number);
                        });
                    
                    console.log(`Extracted ${paletteColors.length} colors from palette`);
                    
                    // Pass the paletteIndex to processPallet to fix the reference error
                    await processPallet(
                        ctx, 
                        totalLayers, 
                        canvas, 
                        targetLayerIndex, 
                        [], 
                        paletteColors,
                        paletteIndex  // Add this parameter to fix the error
                    );
                });
            }
        }, 1000); // 1-second delay
          {% endfor %}
      });
  


      function getDominantColor(imageData) {
  const data = imageData.data;
  const colorCounts = {};
  const allColors = new Map();
  let totalPixels = 0;

  for (let i = 0; i < data.length; i += 4) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];
    const a = data[i + 3];

    if (a === 0) continue;
    if ((r === 0 && g === 0 && b === 0) || (r === 255 && g === 255 && b === 255)) continue;

    const [h, s, l] = rgbToHsl(r, g, b);

    if (s < 0.05) continue;

    const colorName = getDominantColorName([r, g, b]);
    const existingColor = allColors.get(colorName);

    if (existingColor) {
      existingColor.pixelCount++;
    } else {
      allColors.set(colorName, { rgb: [r, g, b], colorName, pixelCount: 1 });
    }

    totalPixels++;
  }

  let maxCount = 0;
  let dominantColor = null;

  for (const [colorName, colorInfo] of allColors.entries()) {
    if (colorInfo.pixelCount > maxCount) {
      maxCount = colorInfo.pixelCount;
      dominantColor = colorInfo;
    }
  }

  if (dominantColor) {
    const nonDominantColors = [];
    for (const [colorName, colorInfo] of allColors.entries()) {
      if (colorName !== dominantColor.colorName) {
        const pixelPercentage = (colorInfo.pixelCount / totalPixels) * 100;
        nonDominantColors.push({ ...colorInfo, pixelPercentage });
      }
    }

    return {
      referenceColor: dominantColor.rgb,
      dominantHue: rgbToHsl(...dominantColor.rgb)[0],
      tolerance: {
        hue: 45 / 360,
        saturation: 0.4,
        lightness: 0.45
      },
      isSingleShade: false,
      nonDominantColors,
      dominantColorName: dominantColor.colorName
    };
  }

  return null;
}

// Add this shuffle function at the top level
function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}

function shuffleSinglePalette(layerIndex) {
  const paletteContainer = document.getElementById(`colorPalette_${layerIndex}`);
  if (!paletteContainer) return;

  // Toggle the state for this palette
  window.paletteToggleState[layerIndex] = !window.paletteToggleState[layerIndex];

  if (window.paletteToggleState[layerIndex]) {
      // If toggled on, generate and apply new colors
      const swatches = Array.from(paletteContainer.querySelectorAll('.color-swatch'));
      if (swatches.length === 0) return;

      const colors = swatches.map(swatch => {
          const style = window.getComputedStyle(swatch);
          const bgcolor = style.backgroundColor;
          return bgcolor.match(/\d+/g).map(Number);
      });

      // Shuffle colors
      const shuffledColors = shuffleArray([...colors]);

      // Apply shuffled colors
      swatches.forEach((swatch, index) => {
          swatch.style.backgroundColor = `rgb(${shuffledColors[index].join(',')})`;
      });

      // Store the shuffled colors
      window.trendingPaletteColors = window.trendingPaletteColors || {};
      window.trendingPaletteColors[layerIndex] = shuffledColors;
  } else {
      // If toggled off, revert to original colors
      const originalColors = window.originalPaletteColors[layerIndex];
      if (originalColors) {
          displayColorPalette(layerIndex, originalColors);
      }
  }
}
// Add event listeners for all shuffle buttons
document.addEventListener('DOMContentLoaded', function() {
  const totalLayers = {{ layers|length }};
  const collections = ['trending', 'ss', 'aw'];
  
  // Add event listeners for all shuffle buttons across all collections
  collections.forEach(collection => {
      for (let i = 1; i <= totalLayers; i++) {
          const shuffleButton = document.getElementById(`shufflePalette_${i}`);
          if (shuffleButton) {
              shuffleButton.addEventListener('click', () => shufflePalette(i, collection));
          }
      }
  });
});

function shufflePalette(layerIndex, collection) {
  // Get the stored colors for this collection and layer
  const collectionColors = window[`${collection}PaletteColors`];
  if (!collectionColors || !collectionColors[layerIndex]) {
      console.error(`No colors found for ${collection} collection, layer ${layerIndex}`);
      return;
  }

  const colors = [...collectionColors[layerIndex]];
  
  // Fisher-Yates shuffle algorithm
  for (let i = colors.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [colors[i], colors[j]] = [colors[j], colors[i]];
  }

  // Display the shuffled colors
  displayColorPalette(layerIndex, colors, collection);
}


function handleShuffleColors() {
  const imageColorPickerContainer = document.getElementById('image-color-pickers');
  const colorButtons = Array.from(imageColorPickerContainer.getElementsByClassName('pcr-button'));
  
  if (colorButtons.length === 0) return;

  // Filter out locked colors
  const unlockedColors = colorButtons.filter(button => button.dataset.locked !== 'true');
  
  if (unlockedColors.length === 0) {
      console.log('All colors are locked');
      return;
  }

  const isSingleLayer = colorButtons.length === 1;

  if (isSingleLayer) {
      // Single layer processing
      const button = unlockedColors[0];
      const layerIndex = parseInt(button.dataset.layerIndex) + 1;
      const canvas = document.getElementById(`layer_canvas_${layerIndex}`);
      
      if (!canvas) return;

      // Save current state
      layerStates.saveEditedState(layerIndex);

      // Get original color
      const style = window.getComputedStyle(button);
      const bgcolor = style.backgroundColor;
      const originalColor = bgcolor.match(/\d+/g).map(Number);

      // Generate multiple variations of the color
      const variations = generateColorVariations(originalColor);
      const shuffledVariations = shuffleArray(variations);

      // Create temporary canvases for variations
      const variationCanvases = shuffledVariations.map((color, index) => {
          const variationCanvas = document.createElement('canvas');
          variationCanvas.width = canvas.width;
          variationCanvas.height = canvas.height;
          variationCanvas.style.display = 'none';
          variationCanvas.id = `variation_canvas_${index}`;
          document.body.appendChild(variationCanvas);
          return {
              canvas: variationCanvas,
              color: color
          };
      });

      // Process each variation
      const processPromises = variationCanvases.map(({ canvas, color }) => {
          return new Promise((resolve) => {
              if (layerStates.hasEditedState(layerIndex)) {
                  const img = new Image();
                  img.onload = async () => {
                      const ctx = canvas.getContext('2d');
                      ctx.clearRect(0, 0, canvas.width, canvas.height);
                      ctx.drawImage(img, 0, 0);
                      await processLayerAsync(ctx, originalColor, color);
                      resolve();
                  };
                  img.src = layerStates.getEditedState(layerIndex);
              } else {
                  const ctx = canvas.getContext('2d', { willReadFrequently: true });
                  resolve(processLayerAsync(ctx, originalColor, color));
              }
          });
      });

      // Apply the first variation
      Promise.all(processPromises).then(() => {
          const mainCanvas = document.getElementById(`layer_canvas_${layerIndex}`);
          const mainCtx = mainCanvas.getContext('2d');
          const firstVariation = variationCanvases[0];
          
          mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
          mainCtx.drawImage(firstVariation.canvas, 0, 0);
          
          // Update color button
          button.style.backgroundColor = `rgb(${firstVariation.color.join(',')})`;

          // Clean up variation canvases
          variationCanvases.forEach(({ canvas }) => canvas.remove());

          console.log('Single layer processing complete');
      }).catch(error => {
          console.error('Error during single layer processing:', error);
      });

  } else {
      // Multiple layer processing
      const colorData = unlockedColors.map(button => {
          const style = window.getComputedStyle(button);
          const bgcolor = style.backgroundColor;
          const layerIndex = button.dataset.layerIndex;
          const colorArray = bgcolor.match(/\d+/g).map(Number);
          return {
              color: colorArray,
              layerIndex: layerIndex,
              element: button
          };
      });

      const shuffledColors = shuffleArray([...colorData]);

      // Save current states before shuffling
      unlockedColors.forEach(button => {
          const layerIndex = parseInt(button.dataset.layerIndex) + 1;
          layerStates.saveEditedState(layerIndex);
      });

      const originalColors = new Map();
      colorData.forEach(data => {
          originalColors.set(data.layerIndex, data.color);
      });

      const processPromises = shuffledColors.map((newColorData, index) => {
          const originalData = colorData[index];
          const button = originalData.element;
          const layerIndex = parseInt(originalData.layerIndex) + 1;
          
          button.style.backgroundColor = `rgb(${newColorData.color.join(',')})`;
          
          const canvas = document.getElementById(`layer_canvas_${layerIndex}`);
          if (canvas) {
              if (layerStates.hasEditedState(layerIndex)) {
                  return new Promise((resolve) => {
                      const img = new Image();
                      img.onload = async () => {
                          const ctx = canvas.getContext('2d');
                          ctx.clearRect(0, 0, canvas.width, canvas.height);
                          ctx.drawImage(img, 0, 0);
                          await processLayerAsync(ctx, originalColors.get(originalData.layerIndex), newColorData.color);
                          resolve();
                      };
                      img.src = layerStates.getEditedState(layerIndex);
                  });
              } else {
                  const ctx = canvas.getContext('2d', { willReadFrequently: true });
                  return processLayerAsync(ctx, originalColors.get(originalData.layerIndex), newColorData.color);
              }
          }
          return Promise.resolve();
      });

      Promise.all(processPromises).then(() => {
          console.log('All layers processed');
      }).catch(error => {
          console.error('Error during color processing:', error);
      });
  }
}

// Helper function to generate color variations
function generateColorVariations(baseColor) {
  const variations = [];
  
  // Add the original color
  variations.push([...baseColor]);
  
  // Generate some variations by adjusting hue
  for (let i = 1; i <= 3; i++) {
      const hslColor = rgbToHsl(baseColor[0], baseColor[1], baseColor[2]);
      hslColor[0] = (hslColor[0] + (i * 30)) % 360; // Rotate hue by 30 degrees
      const rgbColor = hslToRgb(hslColor[0], hslColor[1], hslColor[2]);
      variations.push(rgbColor);
  }
  
  return variations;
}

// Add a utility function to check if colors are significantly different
function areColorsDifferent(color1, color2, threshold = 5) {
    return Math.abs(color1[0] - color2[0]) > threshold ||
           Math.abs(color1[1] - color2[1]) > threshold ||
           Math.abs(color1[2] - color2[2]) > threshold;
}

// Modify your createColorButtons function to add layer index to buttons

function createColorButtons() {
  const imageColorAnalyzer = new ImageColorAnalyzer();
  const imageColorPickerContainer = document.getElementById('image-color-pickers');
  imageColorPickerContainer.innerHTML = '';
  
  const canvasElements = document.querySelectorAll('canvas[id^="layer_canvas_"]');
  const isSingleLayer = canvasElements.length === 1;

  if (isSingleLayer) {
      // Handle single layer case - create buttons for all distinct colors
      const canvas = canvasElements[0];
      const ctx = canvas.getContext('2d');
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const distinctColors = getDistinctColors(imageData, 100, 20); // Lower tolerance, more colors

      distinctColors.forEach((color, index) => {
          // Create wrapper div for button and lock
          const wrapper = document.createElement('div');
          wrapper.className = 'color-button-wrapper';
          
          // Create color button
          const button = document.createElement('button');
          button.className = 'pcr-button color-picker';
          button.style.backgroundColor = `rgb(${color.join(',')})`;
          button.dataset.layerIndex = 0;
          button.dataset.locked = 'false';
          
          // Create lock overlay
          const lockOverlay = document.createElement('div');
          lockOverlay.className = 'lock-overlay';
          lockOverlay.innerHTML = `
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-unlock" viewBox="0 0 16 16">
                  <path d="M11 1a2 2 0 0 0-2 2v4a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h5V3a3 3 0 0 1 6 0v4a.5.5 0 0 1-1 0V3a2 2 0 0 0-2-2zM3 8a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1H3z"/>
              </svg>`;

          // Add lock overlay click handler
          lockOverlay.addEventListener('click', (e) => {
              e.stopPropagation();
              const isLocked = button.dataset.locked === 'true';
              button.dataset.locked = !isLocked;
              lockOverlay.innerHTML = !isLocked ? 
                  `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-lock" viewBox="0 0 16 16">
                      <path d="M8 1a2 2 0 0 1 2 2v4H6V3a2 2 0 0 1 2-2zm3 6V3a3 3 0 0 0-6 0v4a2 2 0 0 0-2 2v5a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2zM5 8h6a1 1 0 0 1 1 1v5a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V9a1 1 0 0 1 1-1z"/>
                  </svg>` :
                  `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-unlock" viewBox="0 0 16 16">
                      <path d="M11 1a2 2 0 0 0-2 2v4a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h5V3a3 3 0 0 1 6 0v4a.5.5 0 0 1-1 0V3a2 2 0 0 0-2-2zM3 8a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1H3z"/>
                  </svg>`;
          });

          wrapper.appendChild(button);
          wrapper.appendChild(lockOverlay);
          imageColorPickerContainer.appendChild(wrapper);
          button.dataset.layerIndex = index;
          
          button.addEventListener('click', () => {
            
              showLayerInfoButton(index);
          });
      });
  } else {
      // Original multiple layer logic
      canvasElements.forEach((canvas, index) => {
          const img = new Image();

          img.onload = () => {
            const canvas = document.getElementById(`layer_canvas_${layerIndex}`);
            const ctx = canvas.getContext('2d');
            console.log('im fucking triggered')
        
            // Save the current state of the canvas
            const currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        
            // Check if the canvas is already populated
            const isEmpty = currentImageData.data.every(value => value === 0);
        
            // Only reset the canvas if it's empty
            if (isEmpty) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);
            } else {
                // Restore the previous state if the canvas is not empty
                ctx.putImageData(currentImageData, 0, 0);
            }

              imageColorAnalyzer.analyzeImageColors(img)
                  .then(colorAnalysis => {
                      if (colorAnalysis) {
                          const dominantColor = colorAnalysis.dominantColor;

                          // Create wrapper div for button and lock
                          const wrapper = document.createElement('div');
                          wrapper.className = 'color-button-wrapper';
                          
                          // Create color button
                          const button = document.createElement('button');
                          button.className = 'pcr-button color-picker';
                          button.style.backgroundColor = `rgb(${dominantColor.join(',')})`;
                          button.dataset.layerIndex = index;
                          button.dataset.locked = 'false';
                          
                          // Create lock overlay
                          const lockOverlay = document.createElement('div');
                          lockOverlay.className = 'lock-overlay';
                          lockOverlay.innerHTML = `
                              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-unlock" viewBox="0 0 16 16">
                                  <path d="M11 1a2 2 0 0 0-2 2v4a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h5V3a3 3 0 0 1 6 0v4a.5.5 0 0 1-1 0V3a2 2 0 0 0-2-2zM3 8a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1H3z"/>
                              </svg>`;

                          // Add lock overlay click handler
                          lockOverlay.addEventListener('click', (e) => {
                              e.stopPropagation();
                              const isLocked = button.dataset.locked === 'true';
                              button.dataset.locked = !isLocked;
                              lockOverlay.innerHTML = !isLocked ? 
                                  `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-lock" viewBox="0 0 16 16">
                                      <path d="M8 1a2 2 0 0 1 2 2v4H6V3a2 2 0 0 1 2-2zm3 6V3a3 3 0 0 0-6 0v4a2 2 0 0 0-2 2v5a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2zM5 8h6a1 1 0 0 1 1 1v5a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V9a1 1 0 0 1 1-1z"/>
                                  </svg>` :
                                  `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-unlock" viewBox="0 0 16 16">
                                      <path d="M11 1a2 2 0 0 0-2 2v4a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h5V3a3 3 0 0 1 6 0v4a.5.5 0 0 1-1 0V3a2 2 0 0 0-2-2zM3 8a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1H3z"/>
                                  </svg>`;
                          });

                          wrapper.appendChild(button);
                          wrapper.appendChild(lockOverlay);
                          imageColorPickerContainer.appendChild(wrapper);
                          
                          button.addEventListener('click', () => {
                              showLayerInfoButton(index);
                          });
                      }
                  })
                  .catch(error => {
                      console.error(`Error analyzing colors for layer ${index}:`, error);
                  });
          };

          img.src = canvas.toDataURL('image/png');
      });
  }
}
// Add event listener for shuffle button
document.querySelector('.btn-success2').addEventListener('click', handleShuffleColors);

// Add this to your existing DOMContentLoaded event listener
document.addEventListener('DOMContentLoaded', function() {
    const layerColors = {};
    const totalLayers = {{ layers|length }};
    let loadedImagesCount = 0;

    function checkIfAllImagesLoaded() {
        if (loadedImagesCount === totalLayers) {
            const loadingScreen = document.getElementById('loading-screen');
            loadingScreen.style.display = 'none';

            // Generate unique RGB color palettes for the trending palettes
            const trendingPalettes = generateUniqueRGBColorPalettes(totalLayers, totalLayers);

      
        }
    }

    {% for layer in layers %}
    let img{{ forloop.counter }} = new Image();
    img{{ forloop.counter }}.src = "{{ layer.path }}";
    let canvas{{ forloop.counter }} = document.getElementById('layer_canvas_{{ forloop.counter }}');
    let ctx{{ forloop.counter }} = canvas{{ forloop.counter }}.getContext('2d', { willReadFrequently: true });
    img{{ forloop.counter }}.onload = function() {
        canvas{{ forloop.counter }}.width = img{{ forloop.counter }}.width;
        canvas{{ forloop.counter }}.height = img{{ forloop.counter }}.height;
        ctx{{ forloop.counter }}.drawImage(img{{ forloop.counter }}, 0, 0);
        loadedImagesCount++;
        checkIfAllImagesLoaded();
    };
    img{{ forloop.counter }}.onerror = function() {
        loadedImagesCount++;
        checkIfAllImagesLoaded();
    };
    {% endfor %}
});

function generateUniqueRGBColorPalettes(count, totalLayers) {
    const palettes = [];

    for (let i = 0; i < count; i++) {
        const colors = generateUniqueRGBColorArray(totalLayers);
        palettes.push(colors);
    }

    return palettes;
}

function exportTiff() {
  return new Promise((resolve, reject) => {
      const loadingScreen = document.getElementById('loading-screen');
      loadingScreen.style.display = 'block';
      
      const formData = new FormData();
      const layers = [];
      
      // Get all layer canvases in correct order
      const layerCanvases = Array.from(document.querySelectorAll('[id^="layer_canvas_"]'))
          .sort((a, b) => {
              const indexA = parseInt(a.id.split('_').pop());
              const indexB = parseInt(b.id.split('_').pop());
              return indexA - indexB;
          });
      
      // Collect all layer data matching the read format
      layerCanvases.forEach((canvas) => {
          // Get the actual positions from the canvas or its wrapper
          const wrapper = canvas.closest('.layer-wrapper') || canvas.parentElement;
          const position_top = parseInt(wrapper.style.top) || 0;
          const position_left = parseInt(wrapper.style.left) || 0;

          const layerData = {
              name: canvas.getAttribute('data-layer-name') || canvas.id,
              position_top: position_top,
              position_left: position_left,
              width: canvas.width,
              height: canvas.height,
              imageData: canvas.toDataURL('image/png', 1.0)
          };
          
          console.log(`Exporting Layer: ${layerData.name}, Position: (${layerData.position_left}, ${layerData.position_top}), Size: ${layerData.width}x${layerData.height}`);
          layers.push(layerData);
      });
      
      formData.append('layers_data', JSON.stringify(layers));
      
      // Send data to server
      fetch('export_tiff/', {
          method: 'POST',
          headers: {
              'X-CSRFToken': getCookie('csrftoken')
          },
          body: formData
      })
      .then(response => {
          if (!response.ok) {
              return response.text().then(text => {
                  try {
                      const json = JSON.parse(text);
                      throw new Error(json.error || 'Export failed');
                  } catch (e) {
                      throw new Error('Export failed: ' + text);
                  }
              });
          }
          return response.blob();
      })
      .then(blob => {
          const url = window.URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'exported.tif';
          document.body.appendChild(a);
          a.click();
          window.URL.revokeObjectURL(url);
          a.remove();
          resolve();
      })
      .catch(error => {
          console.error('Export failed:', error);
          reject(error);
      })
      .finally(() => {
          loadingScreen.style.display = 'none';
      });
  });
}

// Event listener setup
document.addEventListener('DOMContentLoaded', function() {
  const exportButton = document.querySelector('.btn.btn-success4') || document.getElementById('exportTiffButton');
  
  if (exportButton) {
      exportButton.addEventListener('click', function() {
          const loadingScreen = document.getElementById('loading-screen');
          if (loadingScreen) {
              loadingScreen.style.display = 'block';
          }

          exportTiff()
              .then(() => {
                  console.log('Export completed successfully');
              })
              .catch(error => {
                  console.error('Export failed:', error);
                  alert('Export failed: ' + error.message);
              })
              .finally(() => {
                  if (loadingScreen) {
                      loadingScreen.style.display = 'none';
                  }
              });
      });
  }
});

// Helper function to get CSRF token
function getCookie(name) {
  let cookieValue = null;
  if (document.cookie && document.cookie !== '') {
      const cookies = document.cookie.split(';');
      for (let i = 0; i < cookies.length; i++) {
          const cookie = cookies[i].trim();
          if (cookie.substring(0, name.length + 1) === (name + '=')) {
              cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
              break;
          }
      }
  }
  return cookieValue;
}

    </script>
  </body>
</html>
