{% load static %}

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>COLORIFY</title>
    <!-- Add Bootstrap CSS -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <!-- Add Bootstrap Icons -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@simonwep/pickr/dist/themes/nano.min.css"
    />
    <script src="https://cdn.jsdelivr.net/npm/@simonwep/pickr"></script>
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/color-thief/2.3.0/color-thief.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <script src="
https://cdn.jsdelivr.net/npm/jimp@1.6.0/dist/browser/index.min.js
"></script>

    <style>

      .palette-preview-container {
        position: relative;
    }
    
    .palette-preview-container::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
     
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1;
    }
    
    .palette-preview-container::after {
        content: 'Loading...';
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #666;
        z-index: 2;
    }
    
    .preview-ready .palette-preview-container::before,
    .preview-ready .palette-preview-container::after {
        display: none;
    }

    /* Styles for the "Show All Colors" button */
.show-all-colors-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 24px;
  height: 24px;
  background-color: rgba(255, 255, 255, 0.8);
  color: #333;
  border-radius: 50%;
  font-size: 16px;
  font-weight: bold;
  cursor: pointer;
  margin-left: 8px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
  transition: all 0.2s ease;
}

.show-all-colors-btn:hover {
  background-color: white;
  transform: scale(1.1);
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
}

/* Styles for the full palette modal */
.full-palette-modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.7);
  z-index: 1000;
  overflow: auto;
}

.full-palette-modal-content {
  position: relative;
  background-color: #fefefe;
  margin: 10% auto;
  padding: 20px;
  width: 80%;
  max-width: 800px;
  border-radius: 8px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
}

.close-palette-modal {
  position: absolute;
  top: 10px;
  right: 15px;
  color: #aaa;
  font-size: 28px;
  font-weight: bold;
  cursor: pointer;
}

.close-palette-modal:hover {
  color: #333;
}

.palette-modal-title {
  margin-top: 0;
  margin-bottom: 20px;
  color: #333;
}

.all-colors-container {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
  gap: 10px;
}

.full-palette-color {
  position: relative;
  height: 80px;
  border-radius: 4px;
  overflow: hidden;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
  cursor: pointer;
  transition: transform 0.2s ease;
}

.full-palette-color:hover {
  transform: scale(1.05);
} 

.color-info {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: rgba(0, 0, 0, 0.7);
  color: white;
  padding: 4px;
  font-size: 0.8rem;
  text-align: center;
  opacity: 0;
  transition: opacity 0.2s ease;
}

.full-palette-color:hover .color-info {
  opacity: 1;
}
      .harmony-container {
          position: relative;
          display: inline-block;
      }
      
      .btn-success3 {
          background-color: #28a745;
          color: white;
          border: none;
          padding: 8px 16px;
          border-radius: 4px;
          cursor: pointer;
          display: flex;
          align-items: center;
          gap: 8px;
      }
      
      .harmony-menu {
          position: absolute;
          bottom: 100%;
          left: 0;
          background-color: white;
          border: 1px solid #ddd;
          border-radius: 4px;
          box-shadow: 0 2px 10px rgba(0,0,0,0.1);
          width: 200px;
          z-index: 1000;
          margin-bottom: 5px;
      }
      
      .menu-item {
          padding: 10px 15px;
          cursor: pointer;
          transition: background-color 0.2s;
      }
      
      .menu-item:hover {
          background-color: #f8f9fa;
      }
      
      .menu-item.active {
          background-color: #e9ecef;
      }
      
      .menu-item:first-child {
          border-top-left-radius: 4px;
          border-top-right-radius: 4px;
      }
      
      .menu-item:last-child {
          border-bottom-left-radius: 4px;
          border-bottom-right-radius: 4px;
      }
      </style>
    <style>
      body {
        height: 100vh;
        display: flex;
        flex-direction: column;
      }

      main {
        flex-grow: 1;
        display: flex;
        flex-direction: row;
      }
      header {
        background: #fff !important;
        border-radius: 20px;
        margin-bottom:15px;
        width: 100%;
      }

      .content {
        flex-grow: 1;
        padding: 20px;
        overflow-y: auto;
        transition: all 0.3s;
        background: #fff;
        border-radius: 1%;
      }

      .footer {
        background-color: #343a40;
        color: white;
        text-align: center;
        padding: 10px;
      }

      .sidebar {
        background-color: #f8f9fa;
        overflow-y: auto;
        transition: all 0.3s;
        position: relative;
      }
      
      .sidebar .nav-btn{
        position: absolute;
        right: 7px;
      }
      .collapsed {
        flex: 0 0 46px !important;
      }

      .sidebar ul {
        padding: 0;
        list-style-type: none;
      }

      .sidebar ul li a {
        display: block;
        padding: 10px;
        text-decoration: none;
        color: black;
      }
      .header-logo {
        font-size: 1.5rem;
      }

      .header-profile-pic {
        width: 40px;
        height: 40px;
        border-radius: 50%;
      }
      #leftMostColumn {
        background: #fff;
        margin-right: 10px;
        border-radius: 20px;
      }
      #rightSidebar {
        background: #fff;
        margin-right: 10px;
        margin-left: 10px;
        border-radius: 20px;
      }
      #secondaryColumn {
        background: #fff;
        margin-right: 10px;
        border-radius: 20px;
        height: 100vh;
      }
      .upload-btn{
        color: white;
        border: none;
      }
      .bg-linear-blue{
        background: linear-gradient(to right, #7a85eb , #3C4CD1);
      }
    </style>

    {% comment %} pop up css  {% endcomment %}
    <style>
      .popup {
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background-color: white;
          padding: 20px;
          border-radius: 8px;
          box-shadow: 0 2px 10px rgba(0,0,0,0.2);
          z-index: 1000;
          animation: fadeIn 0.3s ease-out;
      }
      
      .popup-overlay {
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background-color: rgba(0,0,0,0.5);
          z-index: 999;
      }
      
      @keyframes fadeIn {
          from { opacity: 0; transform: translate(-50%, -60%); }
          to { opacity: 1; transform: translate(-50%, -50%); }
      }
      
      .close-btn {
          position: absolute;
          top: 10px;
          right: 10px;
          cursor: pointer;
          border: none;
          background: none;
          font-size: 18px;
      }
      </style>
    <style>
      body {
        font-family: "Arial", sans-serif;
        background-color: #f8f9fa;
        margin: 0;
        padding:15px;
      }
      h1 {
        text-align: center;
        color: #333;
        margin-bottom: 30px;
      }
      .scrollable-container {
        width: calc(100% - 220px);
        height: 84vh;
        overflow: auto;
        border: 1px solid #ddd;
        position: relative;
        margin-right: 220px;
      }
      .zoom-wrapper {
        transform-origin: top left;
        transition: transform 0.3s;
      }
      .canvas-container {
        position: relative;
        overflow: hidden;

        width: {{width}}px;
        height: {{height}}px;
      }
      .layer {
        position: absolute;
        background: transparent;
        pointer-events: none;
      }

      .toolbar h2 {
        font-size: 18px;
        text-align: center;
        margin-bottom: 15px;
      }

      .zoom-controls,
      .layer-toggles {
        //margin-bottom: 20px;
      }
      .zoom-slider {
        width: 100%;
      }
      .layer-toggle-item {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
      }
      .thumbnail {
        width: 30px;
        height: 30px;
        margin-right: 10px;
        border-radius: 4px;
        border: 1px solid #ddd;
        cursor: pointer;
      }
      .layer-name {
        font-size: 14px;
        flex-grow: 1;
      }
      .color-swatch {
        width: 99px;
        height: 30px;
        //display: inline-block;



      }


      .cp_light {
        position: absolute;
        background-color: #ffffff;
        border: 1px solid #ddd;
        box-shadow: 0px 4px 12px rgba(0, 0, 0, 0.15);
        width: 200px;
        z-index: 1500;
        border-radius: 8px;
        display: none; /* Initially hidden */
        padding: 10px;
        overflow-y: auto;
        max-height: 200px;
      }

      .cp_light .option {
        padding: 8px;
        cursor: pointer;
        font-size: 14px;
        color: #333;
      }

      .cp_light .option:hover {
        background-color: #f0f0f0;
      }
      .cp_light {
        position: absolute;
        background-color: #ffffff;
        border: 1px solid #ddd;
        box-shadow: 0px 4px 12px rgba(0, 0, 0, 0.15);
        width: 200px;
        z-index: 1500;
        border-radius: 8px;
        display: none;
        padding: 10px;
        overflow-y: auto;
      }

      .scrollable {
          max-height: 330px;
          overflow-y: auto;
      }

      .enab, .disab {
          padding: 8px;
          font-size: 14px;
          color: #333;
          cursor: pointer;
          display: flex;
          justify-content: space-between;
      }

      .disab {
          color: #aaa;
          cursor: not-allowed;
      }

      .enab:hover {
          background-color: #f0f0f0;
      }

      .context-panel hr {
          margin: 8px 0;
          border-color: #ddd;
      }
      /* Add a small arrow on the left side of the context menu */
      .cp_light::before {
        content: "";
        position: absolute;
        left: -10px;
        top: 10px;
        width: 0;
        height: 0;
        border-top: 10px solid transparent;
        border-bottom: 10px solid transparent;
        border-right: 10px solid #ffffff; /* Match the context menu background color */
      }
      .pickr-container {
        display: flex;
        {% comment %} gap: 10px; /* Space between buttons */ {% endcomment %}
        align-items: center; /* Center vertically if the buttons have different heights */
      }

      .pcr-button {
          width: 40px;
          height:38px;
          border: none;
          cursor: pointer;
      }
      #colorPickerModal .modal-dialog {
        position: fixed;
        bottom: 0;
        left: 50%;
        transform: translateX(-50%);
        width: 100%;
        max-width: 600px; /* Adjust as needed */
        margin: 0;
      }

      #colorPickerModal .modal-content {
          border-radius: 10px 10px 0 0; /* Rounded corners at the top */
          box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.3);
      }
      .modal-backdrop {
        display: none !important;
      }

      #colorPickerModal {
        pointer-events: auto;
      }

      .modal.fade.show {
          background: transparent;
          pointer-events: none; /* Allow clicks through the modal */
      }

      .modal-dialog {
          pointer-events: auto; /* Only the modal dialog should capture clicks */
      }
      #colorPickerModal {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        max-height: 50%;
        pointer-events: auto;
        z-index: 1050; /* Ensure it appears above other content */
      }

      #loading-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: #fff;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
      }

      .spinner {
          width: 50px;
          height: 50px;
          border: 5px solid rgba(0, 0, 0, 0.1);
          border-top-color: #000;
          border-radius: 50%;
          animation: spin 1s linear infinite;
      }
      .visualizer_toolbar {
        position: fixed;
        bottom: 0;
        background: white;
        left: 0;
        z-index: 101;
        padding: 24px;
        width: 100%;
        box-shadow: rgba(0, 0, 0, 0.075) 0 -1px;
        display: flex;
        justify-content: space-between;
      }
      #visualizer_palette {
        width: 350px;
      }
      .palette-selector {
        height: 46px;
        position: relative;
      }
      .palette-selector.has-btns .palette-selector_colors {
        width: calc(100% - 35px);
      }
      .palette-selector_colors {
        height: 46px;
        width: 100%;
        border-radius: 10px;
        overflow: hidden;
        display: flex;
        position: relative;
      }
      .palette-selector_colors div.is-visible {
        display: block;
      }
      .palette-selector_colors div {
        box-shadow: 1px 0;
        cursor: pointer;
        height: 100%;
        position: relative;
        overflow: hidden;
        float: left;
        display: none;
        flex-grow: 1;
      }
      .palette-selector.has-btns .palette-selector_buttons {
        display: block;
      }
      .palette-selector_buttons {
        position: absolute;
        right: 0;
        top: 0;
        width: 23px;
        text-align: center;
        display: none;
      }
      .palette-selector.has-btns .palette-selector_colors {
        width: calc(100% - 35px);
      }
      @keyframes spin {
          to {
              transform: rotate(360deg);
          }
      }

      .palette-wrapper {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .scroll-container {
          width: 80%; /* Adjust this width as needed */
          overflow-x: auto;
          white-space: nowrap;
          position: relative;
          {% comment %} border-radius:11px; {% endcomment %}
      }

      .color-pickers {
        display: flex;
        gap: 10px;
        padding: 10px;
        overflow-x: auto; /* Make it horizontally scrollable */
        max-width: 100%; /* Ensure it doesn't exceed container width */
        flex-wrap: nowrap; /* Keep items in a single row */
    }
    
    .pickr {
        flex: 0 0 auto; /* Prevents shrinking */
    }
    

      .scroll-btn {
          border:1px solid;
          color: #000;
          border: none;
          padding: 10px;
          cursor: pointer;
          border-radius: 5px;
          font-size: 18px;
      }

      .scroll-btn:hover {
          background-color: #0056b3;
      }

      .pickr .pcr-button{
        height:2em!important;
        margin: 0 .3em 0 .3em !important;

      }
      .color-picker-container {
        width: 100%;
        overflow-x: auto;
        white-space: nowrap;
        -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
        scrollbar-width: thin; /* For Firefox */
    }
    
    /* Style scrollbar for webkit browsers */
    .color-picker-container::-webkit-scrollbar {
        height: 6px;
    }
    
    .color-picker-container::-webkit-scrollbar-thumb {
        background-color: #888;
        border-radius: 3px;
    }

      /* Left Sidebar */
      #leftSidebar {
        position: fixed;
        top: 0;
        left: 0;
        width: 250px;
        height: 100vh;
        background-color: #f5f5f5;
        box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1);
        padding: 20px;
        overflow-y: auto;
        z-index: 1000;
      }

      /* Main Content */
      .scrollable-container {
        margin-left: 250px;
        margin-right: 250px;
        overflow: auto;
        flex: 1;
        position: relative;
      }
      /* Toggle Button */
      .toggle-btn {
        position: absolute;
        top: 10px;
        left: 10px;
        background-color: #007bff;
        color: #fff;
        border: none;
        border-radius: 4px;
        padding: 5px;
        cursor: pointer;
      }
      /* Collapsed State */
      .collapsed {
        width: 40px;
      }


      .collapsed .sidebar-content {
        opacity: 0;
        pointer-events: none;
      }

      #leftSidebar {
        left: 0;
      }

      /* Color Palette Styles */
      .color-palette {
        display: flex;
        flex-wrap: wrap;
        margin-top: 10px;
        overflow-x: auto;
      }


      #loader {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 9999;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .spinner {
        width: 50px;
        height: 50px;
        border: 5px solid #f3f3f3;
        border-top: 5px solid #3498db;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .color-palette {
        display: grid;
        grid-template-columns: repeat(2, 1fr); /* Two columns */
        //gap: 10px; /* Space between swatches */
      }

      .color-swatch {
          width: 125px; /* Full width within the grid cell */
          height: 25px; /* Fixed height for uniformity */
          //border-radius: 5px; /* Rounded corners */
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Optional shadow */
          cursor: pointer;
          transition: transform 0.2s ease;
      }

      .color-swatch:hover {
          transform: scale(1.05); /* Enlarge slightly on hover */
      }
    </style>
    
  <style>
 .image-adjustments {
    position: relative;
}

.adjustment-panel {
    position: fixed;  /* Changed to fixed positioning */
    left: 60px;      /* Offset from left to not overlap with the button */
    bottom: 20px;    /* Position from bottom */
    background: white;
    padding: 15px;
    border-radius: 8px;
    box-shadow: 0 0 10px rgba(0,0,0,0.1);
    min-width: 250px;
    max-height: 80vh; /* Limit height to 80% of viewport height */
    overflow-y: auto; /* Add scrolling if content is too long */
    z-index: 1000;
}

.layer-adjustments {
    margin-bottom: 20px;
    padding: 10px;
    border: 1px solid #ddd;
    border-radius: 5px;
    background-color: #f9f9f9;
}

.layer-adjustments h4 {
    margin-bottom: 10px;
    font-size: 14px;
    color: #333;
}

.slider-group {
    margin-bottom: 10px;
}

.slider-group label {
    display: block;
    margin-bottom: 5px;
    font-size: 12px;
    color: #666;
}

.slider-group input {
    width: 100%;
}

/* Add some hover effects */
.layer-adjustments:hover {
    border-color: #999;
    transition: border-color 0.2s ease;
}

.color-button-wrapper {
    position: relative;
    display: inline-block;
}

.lock-overlay {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(255, 255, 255, 0.8);
    border-radius: 50%;
    padding: 4px;
    cursor: pointer;
    opacity: 0;
    transition: opacity 0.2s;
}


.color-button-wrapper:hover .lock-overlay {
    opacity: 1;
}

.lock-overlay svg {
    display: block;
}

.mostLeftUl li a {
  position: relative;
  transition: all 0.3s ease;
  padding: 10px;
  display: block;
  text-decoration: none;
  color: #333;
}

.mostLeftUl li a.active {
  background-color: rgba(0, 123, 255, 0.1);
  color: #007bff;
}

.mostLeftUl li a:hover {
  background-color: rgba(0, 123, 255, 0.05);
}

.mostLeftUl li a.active::before {
  content: '';
  position: absolute;
  left: 0;
  top: 0;
  height: 100%;
  width: 3px;
  background-color: #007bff;
}
.inspiration-placeholder {
  padding: 20px;
  text-align: center;
  border: 2px dashed #dee2e6;
  border-radius: 8px;
  margin-top: 20px;
}

.inspiration-placeholder p {
  margin: 0;
  color: #6c757d;
  font-size: 14px;
}

.sidebar-content {
  display: none;
}

#inspirationContent {
  display: block;
}
.pdf-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);  /* Two columns */
  gap:10px;
  max-width: 1200px;  /* Maximum width for the container */
  margin: 0 auto;     /* Center the grid */
}

.pdf-item {
  height: 170px;
  border: 1px solid #ddd;
  border-radius: 8px;
  overflow: hidden;
  transition: transform 0.2s;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.pdf-preview {
  height: 100%;
  position: relative;
  cursor: pointer;
}

.pdf-preview img {
  width: 100%;
  height: 150px;
  object-fit: cover;
}

.pdf-info {
  padding: 10px;
  background: rgba(0, 0, 0, 0.7);
  color: white;
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
}

.pdf-actions {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.pdf-likes {
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 5px;
}

.download-btn {
  padding: 2px 8px;
  font-size: 12px;
}
.visualizer_buttons_left{
  display:flex!important;
  align-items: center;
  gap: 10px;
}
/* Responsive behavior for smaller screens */
@media (max-width: 768px) {
  .pdf-grid {
      grid-template-columns: 1fr;  /* Single column on mobile */
  }
}


    </style>
    <style>
      .effects-grid {
          display: grid;
          grid-template-columns: repeat(2, 1fr);
          gap: 15px;
          padding: 15px;
      }
      
      .effect-item {
          border: 1px solid #ddd;
          border-radius: 8px;
          overflow: hidden;
          cursor: pointer;
          transition: transform 0.2s;
      }
      
      .effect-item:hover {
          transform: scale(1.05);
      }
      
      .effect-preview {
          position: relative;
      }
      
      .effect-preview img {
          width: 100%;
          height: 120px;
          object-fit: cover;
      }
      
      .effect-name {
          position: absolute;
          bottom: 0;
          left: 0;
          right: 0;
          background: rgba(0, 0, 0, 0.7);
          color: white;
          padding: 5px;
          text-align: center;
      }
      
      /* Effect-specific styles */
      .effect-item[data-effect="grayscale"] img {
          filter: grayscale(100%);
      }
      
      .effect-item[data-effect="sepia"] img {
          filter: sepia(100%);
      }
      
      .effect-item[data-effect="invert"] img {
          filter: invert(100%);
      }
      
      .effect-item[data-effect="brightness"] img {
          filter: brightness(150%);
      }

      /* Add this to your existing CSS */
.right-sidebar-specific {
  position: relative;
  background: #fff;
  margin-right: 10px;
  margin-left: 10px;
  border-radius: 20px;
  width: 250px;
  min-width: 250px; /* Add this to prevent collapse */
  transition: all 0.3s ease;
  display: flex !important;
  flex-direction: column;
  flex-shrink: 0; /* Add this to prevent shrinking */
}

.right-sidebar-specific .sidebar-content {
  padding: 20px;
  opacity: 1;
  transition: opacity 0.3s ease;
  display: block !important;
}

.right-sidebar-specific.collapsed {
  width: 46px;
  min-width: 46px;
}

.right-sidebar-specific.collapsed .sidebar-content {
  opacity: 0;
  pointer-events: none;
}

/* Layer toggle specific styles */
.right-sidebar-specific .layer-toggles {
  margin-top: 20px;
  opacity: 1;
  transition: opacity 0.3s ease;
  display: block !important;
}

.right-sidebar-specific .layer-toggle-item {
  display: flex;
  align-items: center;
  margin-bottom: 10px;
  padding: 8px;
  background: #f8f9fa;
  border-radius: 8px;
}


.favorite-btn .bi-heart-fill {
  color: red;
}

.favorite-btn .fav-count {
  font-size: 0.8em;
  margin-left: 4px;
}

.color-palette {
  min-height: 150px;
}


      </style>
      
      <style>
        .mockups-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            padding: 15px;
        }
        
        .mockup-item {
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
            transition: transform 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .mockup-item:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        
        .mockup-item img {
            width: 100%;
            height: auto;
            object-fit: cover;
            display: block;
        }
        
        .mockup-info {
            padding: 10px;
            background: #f8f9fa;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .mockup-name {
            font-size: 14px;
            font-weight: 500;
        }
        
        .apply-mockup-btn {
            padding: 3px 8px;
            font-size: 12px;
        }
        
        @media (max-width: 576px) {
            .mockups-grid {
                grid-template-columns: 1fr;
            }
        }
        </style>
        
        <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Add mockups button handler to the existing navigation structure
            const mockupsButton = document.getElementById('mockupsButton');
            if (mockupsButton) {
                mockupsButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    
                    // Set this button as active
                    const navButtons = document.querySelectorAll('.mostLeftUl li a');
                    navButtons.forEach(button => {
                        button.classList.remove('active');
                    });
                    this.classList.add('active');
                    
                    // Make sure secondaryColumn is visible
                    const secondaryColumn = document.getElementById('secondaryColumn');
                    secondaryColumn.style.display = 'flex';
                    
                    // Hide all content sections inside secondaryColumn
                    const contentSections = document.querySelectorAll('#secondaryColumn .sidebar-content');
                    contentSections.forEach(content => {
                        if (content) content.style.display = 'none';
                    });
                    
                    // Show the mockups content
                    const mockupsContent = document.getElementById('mockupsContent');
                    if (mockupsContent) {
                        mockupsContent.style.display = 'block';
                    }
                    
                    // If the sidebar is collapsed, uncollapse it
                    if (secondaryColumn.classList.contains('collapsed')) {
                        const toggleButton = secondaryColumn.querySelector('button');
                        toggleSidebar('secondaryColumn', toggleButton);
                    }
                });
            }
            
            // Add click handlers for the mockup apply buttons

            

        });
        </script>  
  </head>

  <body>
    <div id="loading-screen">
      <div class="spinner"></div>
    </div>
    <!-- Header -->
    <header
      class="text-dark p-2 px-3 d-flex align-items-center justify-content-between ms-auto me-auto"
    >
      <!-- Left: Icon -->
      <div class="header-logo">
        <i class="bi bi-palette"></i>
      </div>

      <!-- Center: Search Bar -->
      {% comment %}
      <div class="flex-grow-1 mx-3">
        <input type="text" class="form-control" placeholder="Search" />
      </div>
      {% endcomment %}

      <!-- Right: Profile Picture with Dropdown -->
      <div class="dropdown">
        <a
          href="#"
          class="d-flex align-items-center text-dark text-decoration-none"
          id="profileDropdown"
          data-bs-toggle="dropdown"
          aria-expanded="false"
        >
          <i class="bi bi-person-bounding-box"></i>
          <span class="ms-2">{{ user.username }}</span>
          <i class="bi bi-caret-down-fill ms-1"></i>
        </a>
        <ul
          class="dropdown-menu dropdown-menu-end text-small shadow"
          aria-labelledby="profileDropdown"
        >
          <li><a class="dropdown-item" href="#">Profile</a></li>
          <li><a class="dropdown-item" href="#">Settings</a></li>
          <li><hr class="dropdown-divider" /></li>
          <li><a class="dropdown-item" href="#">Logout</a></li>
        </ul>
      </div>
    </header>


    <!-- Main Content Area  -->
    <main class="d-flex">
      <!-- Left Sidebar -->
      <div
        id="leftMostColumn"
        class="sidebar d-flex flex-column"
        style="flex: 0 0 150px"
      >
        <button
          class="btn btn-primary btn-sm m-2 d-flex align-items-center"
          onclick="toggleSidebar('leftMostColumn', this)"
        >
          <i class="bi bi-caret-left-fill ms-auto"></i>
        </button>
        <ul class="mostLeftUl">
          <li>
            <a href="#" id="inspirationButton">
              <i class="bi bi-brightness-alt-high me-2 mx-1"></i>
              <span class="textSpan">Inspiration</span>
            </a>
          </li>
          <li>
            <a href="#" id="trendingButton">
              <i class="bi bi-graph-up-arrow mx-1"></i>
              <span class="textSpan">Trending</span>
            </a>
          </li>
          <li>
            <a href="#" id="effectsButton">
              <i class="bi bi-magic mx-1"></i>
              <span class="textSpan">Effects</span>
            </a>
          </li>
         {% comment %} <li>
            <a href="#" id="favoriteButton">
              <i class="bi bi-star mx-1"></i>
              <span class="textSpan">Favourite</span>
            </a>
          </li>  {% endcomment %}
          <li>
            <a href="#" id="baseColorButton">
              <i class="bi bi-palette mx-1"></i>
              <span class="textSpan">Base Color</span>
            </a>
          </li>
          <li>
            <a href="#" id="ssCollectionButton">
              <i class="bi bi-collection mx-1"></i>
              <span class="textSpan">SS Collection</span>
            </a>
          </li>
          <li>
            <a href="#" id="awCollectionButton">
              <i class="bi bi-collection mx-1"></i>
              <span class="textSpan">AW Collection</span>
            </a>
          </li>
          <li>
            <a href="#" id="mockupsButton">
              <i class="bi bi-brush-fill mx-1"></i>
              <span class="textSpan">mockups</span>
            </a>
          </li>
        </ul>
      </div>


        <div id="secondaryColumn" class="sidebar d-flex flex-column" style="flex: 0 0 310px">
          <button class="btn-sm m-2 d-flex align-items-center nav-btn" onclick="toggleSidebar('secondaryColumn', this)" style="border: none; background: #fff">
              <i class="bi bi-caret-left-fill ms-auto"></i>
          </button>
          
          <!-- Trending Content -->
     
          <div class="sidebar-content" id="trendingContent" style="display: none;">
            <h4 class="ms-auto me-auto">Trending Palette</h4>
            <hr />
            <div class="layer-toggles d-flex gap-3 justify-content-center flex-wrap">
              {% if layers|length == 1 %}
              {% for i in "0123456789" %}
                  <div class="layer-toggle-item d-flex flex-column gap-2">
                      <div id="trending_colorPalette_{{ forloop.counter0 }}" class="color-palette d-flex flex-column"></div>
                      <div class="d-flex align-items-center justify-content-between w-100">
                          <button id="shufflePalette_{{ forloop.counter0 }}" class="btn btn-sm btn-primary">
                              <i class="bi bi-shuffle"></i>
                          </button>
                          <button type="button" 
                                  id="trending_fav_btn_{{ forloop.counter0 }}" 
                                  class="btn favorite-btn {% if is_favorite %}active{% endif %}"
                                  data-palette-type="TR"
                                  data-colors-id="{{ forloop.counter0 }}"
                                  onclick="toggleFavorite(this, 'trending')">
                              <i class="bi {% if is_favorite %}bi-heart-fill{% else %}bi-heart{% endif %}"></i>
                              <span class="fav-count">{{ favorites_count|default:0 }}</span>
                          </button>
                          <!-- Fix: Ensure button ID matches what our JS will look for -->
                          <button type="button" id="applyButton_{{ forloop.counter0 }}" class="btn btn-success">
                              <i class="bi bi-magic"></i>
                          </button>
                      </div>
                  </div>
              {% endfor %}
          {% else %}
          
                    {% for layer in layers %}
                        <div class="layer-toggle-item d-flex flex-column gap-2">
                            <div id="trending_colorPalette_{{ forloop.counter }}" class="color-palette d-flex flex-column"></div>
                            <div class="d-flex align-items-center justify-content-between w-100">
                                <button id="shufflePalette_{{ forloop.counter }}" class="btn btn-sm btn-primary">
                                    <i class="bi bi-shuffle"></i>
                                </button>
                                <button type="button" 
                                        id="trending_fav_btn_{{ forloop.counter }}" 
                                        class="btn favorite-btn"
                                        data-palette-type="TR"
                                        data-colors-id="{{ forloop.counter }}"
                                        onclick="toggleFavorite(this, 'trending')">
                                    <i class="bi bi-heart"></i>
                                    <span class="fav-count">0</span>
                                </button>
                                <button type="button" id="applyButton_{{ forloop.counter }}" class="btn btn-success">
                                    <i class="bi bi-magic"></i>
                                </button>
                            </div>
                        </div>
                    {% endfor %}
                {% endif %}
            </div>
        </div>
    
        <div class="sidebar-content m-4" id="inspirationContent">
          <h4 class="ms-auto me-auto">Inspirations</h4>
          <div class="inspiration-content">
              <div class="pdf-grid">

              </div>
          </div>
      </div>
      <div class="sidebar-content" id="effectsContent" style="display: none;">
        <h4 class="ms-auto me-auto">Effects</h4>
        <div class="effects-grid">
            <div class="effect-item" data-effect="grayscale">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Grayscale">
                    <div class="effect-name">Grayscale</div>
                </div>
            </div>
            <div class="effect-item" data-effect="sepia">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Sepia">
                    <div class="effect-name">Sepia</div>
                </div>
            </div>
            <div class="effect-item" data-effect="brightness">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Brightness">
                    <div class="effect-name">Brightness</div>
                </div>
            </div>
            <div class="effect-item" data-effect="contrast">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Contrast">
                    <div class="effect-name">Contrast</div>
                </div>
            </div>
            <div class="effect-item" data-effect="blur">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Blur">
                    <div class="effect-name">Blur</div>
                </div>
            </div>
            <div class="effect-item" data-effect="sharpen">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Sharpen">
                    <div class="effect-name">Sharpen</div>
                </div>
            </div>
            <div class="effect-item" data-effect="vintage">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Vintage">
                    <div class="effect-name">Vintage</div>
                </div>
            </div>
            <div class="effect-item" data-effect="colorize">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Colorize">
                    <div class="effect-name">Colorize</div>
                </div>
            </div>
            <div class="effect-item" data-effect="duotone">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Duotone">
                    <div class="effect-name">Duotone</div>
                </div>
            </div>
            <div class="effect-item" data-effect="noise">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Noise">
                    <div class="effect-name">Noise</div>
                </div>
            </div>
            <div class="effect-item" data-effect="vignette">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Vignette">
                    <div class="effect-name">Vignette</div>
                </div>
            </div>
            <div class="effect-item" data-effect="posterize">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Posterize">
                    <div class="effect-name">Posterize</div>
                </div>
            </div>
            <div class="effect-item" data-effect="saturation">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Saturation">
                    <div class="effect-name">Saturation</div>
                </div>
            </div>
        </div>
    </div>
     <!-- SS Collection Content -->
     <div class="sidebar-content" id="ssCollectionContent" style="display: none;">
      <h4 class="ms-auto me-auto">SS Collection</h4>
      <hr />
      <div class="layer-toggles d-flex gap-3 justify-content-center flex-wrap">
          {% if layers|length == 1 %}
              {% for i in "0123456789" %}
                  <div class="layer-toggle-item d-flex flex-column gap-2">
                      <div id="ss_colorPalette_{{ forloop.counter0 }}" class="color-palette d-flex flex-column"></div>
                      <div class="d-flex align-items-center justify-content-between w-100">
                          <button id="ss_shufflePalette_{{ forloop.counter0 }}" class="btn btn-sm btn-primary">
                              <i class="bi bi-shuffle"></i>
                          </button>
                          <button type="button" 
                                  id="ss_fav_btn_{{ forloop.counter0 }}" 
                                  class="btn favorite-btn"
                                  data-palette-type="SS"
                                  data-colors-id="{{ forloop.counter0 }}"
                                  onclick="toggleFavorite(this, 'ss')">
                              <i class="bi bi-heart"></i>
                              <span class="fav-count">0</span>
                          </button>
                          <button type="button" id="ss_applyButton_{{ forloop.counter }}" class="btn btn-success">
                              <i class="bi bi-magic"></i>
                          </button>
                      </div>
                  </div>
              {% endfor %}
          {% else %}
              {% for layer in layers %}
                  <div class="layer-toggle-item d-flex flex-column gap-2">
                      <div id="ss_colorPalette_{{ forloop.counter }}" class="color-palette d-flex flex-column"></div>
                      <div class="d-flex align-items-center justify-content-between w-100">
                          <button id="ss_shufflePalette_{{ forloop.counter }}" class="btn btn-sm btn-primary">
                              <i class="bi bi-shuffle"></i>
                          </button>
                          <button type="button" 
                                  id="ss_fav_btn_{{ forloop.counter }}" 
                                  class="btn favorite-btn"
                                  data-palette-type="SS"
                                  data-colors-id="{{ forloop.counter }}"
                                  onclick="toggleFavorite(this, 'ss')">
                              <i class="bi bi-heart"></i>
                              <span class="fav-count">0</span>
                          </button>
                          <button type="button" id="ss_applyButton_{{ forloop.counter }}" class="btn btn-success">
                              <i class="bi bi-magic"></i>
                          </button>
                      </div>
                  </div>
              {% endfor %}
          {% endif %}
      </div>
  </div>
  

<div class="sidebar-content" id="favCollectionContent" style="display: none;">
  <h4 class="ms-auto me-auto">Favourite Collection</h4>
  <hr />
  <div class="layer-toggles d-flex gap-3 justify-content-center flex-wrap">
      
    {% for layer in layers %}

    <div class="layer-toggle-item d-flex flex-column gap-2">
        <div id="fav_colorPalette_{{ forloop.counter }}" class="color-palette d-flex flex-column"></div>
        <div class="d-flex align-items-center justify-content-between w-100">
          <button id="fav_shufflePalette_{{ forloop.counter }}" class="btn btn-sm btn-primary">
            <i class="bi bi-shuffle"></i>
        </button>
        
        <button type="button" id="" class="btn">
          <i class="bi bi-heart"></i>
      </button>
        <button type="button" id="ss_applyButton_{{ forloop.counter }}" class="btn btn-success">
            <i class="bi bi-magic"></i>
        </button>
        </div>
    </div>
    {% endfor %}
</div>
</div> 
<!-- Base Color Content -->
<!-- Base Color Content -->
<div class="sidebar-content" id="baseColorContent" style="display: none;">
  <h4 class="ms-auto me-auto">Base Colors</h4>
  <div class="base-colors-grid">
    <!-- Color blocks will be generated here -->
  </div>

  <!-- Hidden palettes section - modified to support 70 palettes -->
  <div class="base-palettes-section" style="display: none;">
    <hr/>
    <div class="base-palettes-container">
      <!-- The palette containers will be generated dynamically via JavaScript -->
    </div>
  </div>
</div>

<!-- AW Collection Content -->
<div class="sidebar-content" id="awCollectionContent" style="display: none;">
  <h4 class="ms-auto me-auto">AW Collection</h4>
  <hr />
  <div class="layer-toggles d-flex gap-3 justify-content-center flex-wrap">
      {% if layers|length == 1 %}
          {% for i in "0123456789" %}
              <div class="layer-toggle-item d-flex flex-column gap-2">
                  <div id="aw_colorPalette_{{ forloop.counter0 }}" class="color-palette d-flex flex-column"></div>
                  <div class="d-flex align-items-center justify-content-between w-100">
                      <button id="aw_shufflePalette_{{ forloop.counter0 }}" class="btn btn-sm btn-primary">
                          <i class="bi bi-shuffle"></i>
                      </button>
                      <button type="button" 
                              id="aw_fav_btn_{{ forloop.counter0 }}" 
                              class="btn favorite-btn"
                              data-palette-type="AW"
                              data-colors-id="{{ forloop.counter0 }}"
                              onclick="toggleFavorite(this, 'aw')">
                          <i class="bi bi-heart"></i>
                          <span class="fav-count">0</span>
                      </button>
                      <button type="button" id="aw_applyButton_{{ forloop.counter }}" class="btn btn-success">
                          <i class="bi bi-magic"></i>
                      </button>
                  </div>
              </div>
          {% endfor %}
      {% else %}
          {% for layer in layers %}
              <div class="layer-toggle-item d-flex flex-column gap-2">
                  <div id="aw_colorPalette_{{ forloop.counter }}" class="color-palette d-flex flex-column"></div>
                  <div class="d-flex align-items-center justify-content-between w-100">
                      <button id="aw_shufflePalette_{{ forloop.counter }}" class="btn btn-sm btn-primary">
                          <i class="bi bi-shuffle"></i>
                      </button>
                      <button type="button" 
                              id="aw_fav_btn_{{ forloop.counter }}" 
                              class="btn favorite-btn"
                              data-palette-type="AW"
                              data-colors-id="{{ forloop.counter }}"
                              onclick="toggleFavorite(this, 'aw')">
                          <i class="bi bi-heart"></i>
                          <span class="fav-count">0</span>
                      </button>
                      <button type="button" id="aw_applyButton_{{ forloop.counter }}" class="btn btn-success">
                          <i class="bi bi-magic"></i>
                      </button>
                  </div>
              </div>
          {% endfor %}
      {% endif %}
  </div>
</div>

<div class="sidebar-content" id="mockupsContent" style="display: none;">
    <h4 class="ms-auto me-auto">Mockups</h4>
    <div class="mockups-grid">
        <div class="mockup-item" data-mockup-id="1">
            <img <img src="{% static 'images/shirt-mask.png' %}" > >
            <div class="mockup-info">
                <span class="mockup-name">T-Shirt Design</span>
                <button class="btn btn-sm btn-primary apply-mockup-btn">Apply</button>
            </div>
        </div>
        <div class="mockup-item" data-mockup-id="2">
            <img src="{% static "images/cushion-mask.png" %}" alt="Hoodie Mockup">
            <div class="mockup-info">
                <span class="mockup-name">Cushion Design</span>
                <button class="btn btn-sm btn-primary apply-mockup-btn">Apply</button>
            </div>
        </div>
        <div class="mockup-item" data-mockup-id="3">
            <img src="{% static "images/leggings-mask.png" %}" alt="Hat Mockup">
            <div class="mockup-info">
                <span class="mockup-name">legging Design</span>
                <button class="btn btn-sm btn-primary apply-mockup-btn">Apply</button>
            </div>
        </div>
        <div class="mockup-item" data-mockup-id="4">
            <img src="{% static "images/kids-t-mask.png" %}" alt="Hat Mockup">
           
            <div class="mockup-info">
                <span class="mockup-name">kids t Design</span>
                <button class="btn btn-sm btn-primary apply-mockup-btn">Apply</button>
            </div>
        </div>
        <div class="mockup-item" data-mockup-id="5">
            <img src="{% static "images/kaftan-mask.png" %}" alt="Hat Mockup">
           
            <div class="mockup-info">
                <span class="mockup-name">kafton Design</span>
                <button class="btn btn-sm btn-primary apply-mockup-btn">Apply</button>
            </div>
        </div>
        <div class="mockup-item" data-mockup-id="6">
            <img src="{% static "images/bottle-mask.png" %}" alt="Hat Mockup">
           
            <div class="mockup-info">
                <span class="mockup-name">bottle Design</span>
                <button class="btn btn-sm btn-primary apply-mockup-btn">Apply</button>
            </div>
        </div>
        <div class="mockup-item" data-mockup-id="7">
            <img src="{% static "images/dress-mask.png" %}" alt="Hat Mockup">
           
            <div class="mockup-info">
                <span class="mockup-name">dress Design</span>
                <button class="btn btn-sm btn-primary apply-mockup-btn">Apply</button>
            </div>
        </div>
        <div class="mockup-item" data-mockup-id="8">
            <img src="{% static "images/girls-hoody-mask.png" %}" alt="Hat Mockup">
           
            <div class="mockup-info">
                <span class="mockup-name">Hoodie</span>
                <button class="btn btn-sm btn-primary apply-mockup-btn">Apply</button>
            </div>
        </div>
    </div>
</div>
      </div>


      <!-- Main Content -->
      <div id="mainContent" class="content">
        <div class="d-flex align-items-center justify-content-between">
          <h2 class="fs-4 fw-bold">Workspace</h2>
          <div class="zoom-controls">
            <label for="zoomSlider" class="me-2">Zoom:</label>
            <input
              type="range"
              id="zoomSlider"
              class="zoom-slider"
              min="5"
              max="150"
              value="5"
              step="1"
            />
          </div>
        </div>
        <hr />

        <div class="zoom-wrapper" id="zoomWrapper">
          <div class="canvas-container">
            {% for layer in layers %}
            <div
              class="layer"
              id="layer_{{ forloop.counter }}"
              style="top: {{ layer.layer_position_from_top }}px; left: {{ layer.layer_position_from_left }}px;"
              {% if layer.ml_label is not None %}data-ml-label="{{ layer.ml_label }}"{% endif %}
            >
              <canvas 
                id="layer_canvas_{{ forloop.counter }}" 
                data-original-src="{{ layer.path }}"
                data-original-width="{{ layer.original_width }}"
                data-original-height="{{ layer.original_height }}"
              ></canvas>
              <!-- Removed the visible ml-label-indicator div -->
            </div>
            {% endfor %}
          </div>
        </div>
      </div>

      <!-- Right Sidebar -->
      <div
        id="rightSidebar"
        class="sidebar1 d-flex flex-column toolbar scrollable-toolbar"
        style="flex: 0 0 250px"
      >
        <button
          class="btn-sm m-2 d-flex align-items-center"
          onclick="toggleSidebar('rightSidebar', this)"
          style="border: none; background: #fff"
        >
          <i class="bi bi-caret-right-fill ms-auto"></i>
        </button>
        <div class="sidebar-content1 m-4">
          <h4 class="ms-auto me-auto mb-3">Layers</h4>

          <div class="layer-toggles mt-4">
            {% for layer in layers %}
            <div class="layer-toggle-item">
              <img
                id="thumbnail_{{ forloop.counter }}"
                class="thumbnail"
                src=""
                alt="Layer Thumbnail"
              />
              <span class="layer-name">{{ layer.name }}</span>
              <input
                type="checkbox"
                id="toggleLayer{{ forloop.counter }}"
                checked
                onchange="toggleLayer({{ forloop.counter }})"
              />
            </div>
            {% endfor %}
          </div>
        </div>
      </div>
      <div id="contextMenu" class="cp_light">
        <div
          id="layerNameDisplay"
          style="font-weight: bold; margin-bottom: 5px"
        ></div>
        <div class="option" onclick="showLayerInfo()">Edit</div>
      </div>
      <!-- Color Picker Modal -->
      <div
        class="modal fade"
        id="colorPickerModal"
        tabindex="-1"
        role="dialog"
        aria-labelledby="colorPickerModalLabel"
        aria-hidden="true"
        data-backdrop="false"
      >
        <div class="modal-dialog" role="document">
          <div class="modal-content">
            <div class="modal-header">
              <h5 class="modal-title" id="colorPickerModalLabel">
                Select Layer Color
              </h5>
              <div style="text-align: center; margin-bottom: 20px">
                <label for="color-count-slider">Number of Colors: </label>
                <input
                  type="range"
                  id="color-count-slider"
                  min="1"
                  max="15"
                  value="15"
                  oninput="updateColorCountDisplay()"
                />
                <span id="color-count-display">15</span>
              </div>
            </div>
            <div class="modal-body">
              <div
                class="color-picker-container pickr-container"
                id="color-pickers"
              ></div>
              <button
                id="generatePallateColorsBtn"
                class="btn btn-warning mt-2"
                onclick="generatePallateColors()"
              >
                Generate New Colors
              </button>
            </div>
            <div class="modal-footer">
              <button
                type="button"
                class="btn btn-secondary"
                data-dismiss="modal"
                onclick="hideModal()"
              >
                Close
              </button>
            </div>
          </div>
        </div>
      </div>
    </main>

  <!-- Footer -->
<footer class="bg-light text-center py-2 mt-auto visualizer_toolbar d-flex align-items-center justify-content-center gap-4">
     
  <div id="visualizer_buttons_left ">
    <div class="d-flex align-items-center gap-2">
      <div class="upload-wrapper">
        <form id="uploadForm" method="post" enctype="multipart/form-data">
            {% csrf_token %}
            <input type="file" id="fileInput" name="tiff_file" accept=".tif" style="display: none;">
            <button type="button" class="btn btn-outline-dark upload-btn m-0 p-2 px-3 bg-linear-blue" onclick="document.getElementById('fileInput').click();">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-cloud-upload" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M4.406 1.342A5.53 5.53 0 0 1 8 0c2.69 0 4.923 2 5.166 4.579C14.758 4.804 16 6.137 16 7.773 16 9.569 14.502 11 12.687 11H10a.5.5 0 0 1 0-1h2.688C13.979 10 15 8.988 15 7.773c0-1.216-1.02-2.228-2.313-2.228h-.5v-.5C12.188 2.825 10.328 1 8 1a4.53 4.53 0 0 0-2.941 1.1c-.757.652-1.153 1.438-1.153 2.055v.448l-.445.049C2.064 4.805 1 5.952 1 7.318 1 8.785 2.23 10 3.781 10H6a.5.5 0 0 1 0 1H3.781C1.708 11 0 9.366 0 7.318c0-1.763 1.266-3.223 2.942-3.593.143-.863.698-1.723 1.464-2.383"/>
                    <path fill-rule="evenodd" d="M7.646 4.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 5.707V14.5a.5.5 0 0 1-1 0V5.707L5.354 7.854a.5.5 0 1 1-.708-.708z"/>
                </svg>
                Upload
            </button>
        </form>
    </div>

    
    <div class="image-adjustments">
      <button type="button" class="btn shadow-lg " id="adjustmentToggle">
        <svg width="19" height="19" viewBox="0 0 34 33" fill="none" xmlns="http://www.w3.org/2000/svg">
          <g clip-path="url(#clip0_384_2340)">
            <path
              d="M32.186 15.2545H13.3887C12.7572 12.7733 10.2339 11.2738 7.75261 11.9053C6.10713 12.3241 4.82225 13.609 4.40344 15.2545H1.90915C1.26599 15.2545 0.744629 15.7759 0.744629 16.419C0.744629 17.0622 1.26599 17.5835 1.90915 17.5835H4.40351C5.035 20.0647 7.55836 21.5641 10.0396 20.9326C11.6851 20.5138 12.97 19.2289 13.3888 17.5835H32.186C32.8291 17.5835 33.3505 17.0621 33.3505 16.4189C33.3505 15.7758 32.8291 15.2545 32.186 15.2545ZM8.89611 18.748C7.60987 18.748 6.56715 17.7053 6.56715 16.419C6.56715 15.1328 7.60987 14.09 8.89611 14.09C10.1824 14.09 11.2251 15.1328 11.2251 16.419C11.2251 17.7053 10.1824 18.748 8.89611 18.748Z"
              fill="#3C4CD1" />
            <path
              d="M32.1862 3.60947H28.5274C27.8959 1.12828 25.3726 -0.371188 22.8913 0.260301C21.2458 0.679109 19.9609 1.96399 19.5421 3.60947H1.90939C1.26623 3.60947 0.744873 4.13084 0.744873 4.77399C0.744873 5.41715 1.26623 5.93851 1.90939 5.93851H19.5421C20.1736 8.4197 22.697 9.91917 25.1782 9.28768C26.8237 8.86887 28.1086 7.58399 28.5274 5.93851H32.1862C32.8294 5.93851 33.3507 5.41715 33.3507 4.77399C33.3507 4.13084 32.8294 3.60947 32.1862 3.60947ZM24.0348 7.10296C22.7486 7.10296 21.7058 6.06023 21.7058 4.77399C21.7058 3.48775 22.7486 2.44502 24.0348 2.44502C25.3211 2.44502 26.3638 3.48775 26.3638 4.77399C26.3638 6.06023 25.3211 7.10296 24.0348 7.10296Z"
              fill="#3C4CD1" />
            <path
              d="M32.186 26.8993H26.1981C25.5667 24.4181 23.0433 22.9186 20.562 23.5501C18.9165 23.9689 17.6317 25.2538 17.2129 26.8993H1.90915C1.26599 26.8993 0.744629 27.4206 0.744629 28.0637C0.744629 28.7068 1.26599 29.2282 1.90915 29.2282H17.2129C17.8444 31.7094 20.3678 33.2089 22.849 32.5774C24.4945 32.1586 25.7794 30.8737 26.1982 29.2282H32.186C32.8291 29.2282 33.3505 28.7069 33.3505 28.0637C33.3505 27.4206 32.8291 26.8993 32.186 26.8993ZM21.7055 30.3928C20.4193 30.3928 19.3766 29.35 19.3766 28.0638C19.3766 26.7775 20.4193 25.7348 21.7055 25.7348C22.9918 25.7348 24.0345 26.7775 24.0345 28.0638C24.0345 29.35 22.9918 30.3928 21.7055 30.3928Z"
              fill="#3C4CD1" />
          </g>
          <defs>
            <clipPath id="clip0_384_2340">
              <rect width="32.6059" height="32.6059" fill="white" transform="translate(0.744873 0.115967)" />
            </clipPath>
          </defs>
        </svg>
      </button>
      <div id="adjustmentPanel" class="adjustment-panel" style="display: none;">
          <div class="sliders-container"></div>
      </div>
    </div>
    

   
    </div>
  </div>

  <div id="visualizer_palette" class="palette-wrapper">
      <!-- Left Scroll Button -->
      <button id="scroll-left" class="btn btn-outline-info"><</button>
      <div class="palette-selector has-btns is-sortable has-picker is-lockable is-sortable has-picker is-lockable scroll-container" style="height: 100%;" data-colors="10">
          <div class="color-picker-container mt-1 rounded-2" style="width: fit-content;overflow: hidden;" id="image-color-pickers"></div>
      </div>
      <button id="scroll-right" class="btn btn-outline-info">></button>
  </div>
  <button type="button" class="btn btn-success2 shadow-lg">
    <svg width="20" height="20" viewBox="0 0 33 33" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path
        d="M19.3118 12.7204C20.2116 11.807 21.2664 11.3242 22.3622 11.3242H26.2204L24.7538 12.7908C24.6119 12.9327 24.4993 13.1012 24.4225 13.2867C24.3457 13.4721 24.3061 13.6708 24.3061 13.8716C24.3061 14.0723 24.3457 14.271 24.4225 14.4565C24.4993 14.6419 24.6119 14.8104 24.7538 14.9523C25.0404 15.239 25.4292 15.4 25.8346 15.4C26.0353 15.4 26.234 15.3605 26.4195 15.2837C26.6049 15.2068 26.7734 15.0943 26.9153 14.9523L30.9911 10.8766C31.133 10.7347 31.2456 10.5662 31.3224 10.3807C31.3992 10.1953 31.4388 9.99654 31.4388 9.79583C31.4388 9.59511 31.3992 9.39635 31.3224 9.21091C31.2456 9.02547 31.133 8.85698 30.9911 8.71505L26.9153 4.63932C26.7734 4.49739 26.6049 4.38481 26.4195 4.308C26.234 4.23118 26.0353 4.19165 25.8346 4.19165C25.6338 4.19165 25.4351 4.23118 25.2497 4.308C25.0642 4.38481 24.8957 4.49739 24.7538 4.63932C24.6119 4.78125 24.4993 4.94974 24.4225 5.13518C24.3457 5.32062 24.3061 5.51937 24.3061 5.72009C24.3061 5.92081 24.3457 6.11956 24.4225 6.305C24.4993 6.49044 24.6119 6.65893 24.7538 6.80086L26.2204 8.26742H22.3622C20.0744 8.26742 17.9771 9.41812 16.468 11.3292C17.1472 12.3407 17.6686 13.4496 18.0142 14.6179C18.3375 13.9172 18.7761 13.2758 19.3118 12.7204Z"
        fill="#3C4CD1" />
      <path
        d="M12.3627 20.1175C11.4628 21.0308 10.408 21.5136 9.31225 21.5136H3.41829C3.01294 21.5136 2.62418 21.6746 2.33755 21.9613C2.05092 22.2479 1.88989 22.6367 1.88989 23.042C1.88989 23.4474 2.05092 23.8361 2.33755 24.1228C2.62418 24.4094 3.01294 24.5704 3.41829 24.5704H9.31225C11.6 24.5704 13.6974 23.4197 15.2065 21.5086C14.5272 20.4972 14.0058 19.3883 13.66 18.22C13.3368 18.9206 12.8983 19.562 12.3627 20.1175Z"
        fill="#3C4CD1" />
      <path
        d="M26.9156 17.8854C26.7737 17.7434 26.6052 17.6309 26.4197 17.554C26.2343 17.4772 26.0355 17.4377 25.8348 17.4377C25.6341 17.4377 25.4354 17.4772 25.2499 17.554C25.0645 17.6309 24.896 17.7434 24.7541 17.8854C24.6121 18.0273 24.4995 18.1958 24.4227 18.3812C24.3459 18.5667 24.3064 18.7654 24.3064 18.9661C24.3064 19.1669 24.3459 19.3656 24.4227 19.551C24.4995 19.7365 24.6121 19.905 24.7541 20.0469L26.2207 21.5135H22.3625C21.2667 21.5135 20.2119 21.0307 19.3121 20.1173C18.3449 19.1357 17.6439 17.7197 17.3383 16.1302C16.4479 11.5006 13.1475 8.26733 9.31225 8.26733H3.41829C3.01294 8.26733 2.62418 8.42836 2.33755 8.71499C2.05092 9.00162 1.88989 9.39038 1.88989 9.79573C1.88989 10.2011 2.05092 10.5898 2.33755 10.8765C2.62418 11.1631 3.01294 11.3241 3.41829 11.3241H9.31225C10.408 11.3241 11.4628 11.8069 12.3627 12.7203C13.3298 13.7019 14.0307 15.1179 14.3364 16.7074C15.2268 21.3369 18.5272 24.5703 22.3625 24.5703H26.2207L24.7541 26.0368C24.4674 26.3235 24.3064 26.7122 24.3064 27.1176C24.3064 27.523 24.4674 27.9117 24.7541 28.1984C25.0407 28.485 25.4295 28.646 25.8348 28.646C26.2402 28.646 26.629 28.485 26.9156 28.1984L30.9913 24.1226C31.1333 23.9807 31.2459 23.8122 31.3227 23.6268C31.3995 23.4413 31.439 23.2426 31.439 23.0419C31.439 22.8412 31.3995 22.6424 31.3227 22.457C31.2459 22.2715 31.1333 22.103 30.9913 21.9611L26.9156 17.8854Z"
        fill="#3C4CD1" />
    </svg>
</button>


<div class="harmony-container">
  <button type="button" class="btn shadow-lg" id="harmonyButton">
    <svg width="20" height="20" viewBox="0 0 34 33" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path
        d="M7.69539 17.8844C6.91996 17.8844 6.46696 17.0055 6.91804 16.3738L9.19939 13.18L7.93224 8.66352C7.73201 7.94992 8.38976 7.28364 9.11004 7.48571L13.6265 8.75287L16.8203 6.47152C17.4513 6.02094 18.3309 6.47266 18.3309 7.24887V11.3504L22.0167 14.0551C22.6998 14.5563 22.4375 15.6362 21.601 15.7687L20.2474 15.9831L31.9226 26.3235C33.5103 27.7129 33.5925 30.1613 32.1001 31.6535C30.6084 33.1454 28.1582 33.0626 26.7737 31.4803L16.4296 19.8007L16.2153 21.1543C16.0828 21.9906 15.0027 22.2532 14.5016 21.57L11.7969 17.8843H7.69539V17.8844ZM28.2078 30.2179C28.8759 30.9815 30.0421 31.0098 30.7492 30.3026C31.4508 29.6011 31.4362 28.4367 30.6601 27.7575L22.3717 20.4168L20.8633 21.9252L28.2078 30.2179ZM19.5943 20.4923L20.9388 19.1478L17.8028 16.3703L16.9517 16.5051L16.8168 17.3563L19.5943 20.4923ZM13.0509 16.3639L14.6866 18.5929C16.1333 9.45991 13.753 24.4867 15.1732 15.5207C15.238 15.112 15.5586 14.7914 15.9673 14.7267C16.6508 14.6184 18.4071 14.3402 19.0395 14.24L16.8105 12.6043C16.5652 12.4244 16.4204 12.1384 16.4204 11.8342V9.10505L14.3646 10.5736C14.129 10.7418 13.8299 10.7943 13.5512 10.716L10.2311 9.78445L11.1626 13.1046C11.2408 13.3833 11.1884 13.6823 11.0202 13.9179L9.5517 15.9737H12.2808C12.585 15.9738 12.871 16.1186 13.0509 16.3639Z"
        fill="#3C4CD1" />
      <path
        d="M4.5745 3.55524H4.00133V4.12841C4.00133 4.65598 3.57361 5.0837 3.04604 5.0837C2.51847 5.0837 2.09076 4.65598 2.09076 4.12841V3.55524H1.51759C0.990013 3.55524 0.5623 3.12753 0.5623 2.59995C0.5623 2.07238 0.990013 1.64467 1.51759 1.64467H2.09076V1.0715C2.09076 0.543924 2.51847 0.116211 3.04604 0.116211C3.57361 0.116211 4.00133 0.543924 4.00133 1.0715V1.64467H4.5745C5.10207 1.64467 5.52979 2.07238 5.52979 2.59995C5.52979 3.12753 5.10214 3.55524 4.5745 3.55524Z"
        fill="#3C4CD1" />
      <path
        d="M14.8284 4.638H14.2552V5.21117C14.2552 5.73875 13.8275 6.16646 13.2999 6.16646C12.7724 6.16646 12.3447 5.73875 12.3447 5.21117V4.638H11.7715C11.2439 4.638 10.8162 4.21029 10.8162 3.68272C10.8162 3.15514 11.2439 2.72743 11.7715 2.72743H12.3447V2.15426C12.3447 1.62669 12.7724 1.19897 13.2999 1.19897C13.8275 1.19897 14.2552 1.62669 14.2552 2.15426V2.72743H14.8284C15.356 2.72743 15.7837 3.15514 15.7837 3.68272C15.7837 4.21029 15.356 4.638 14.8284 4.638Z"
        fill="#3C4CD1" />
      <path
        d="M5.08409 14.3818C5.08409 14.9094 4.65638 15.3371 4.12881 15.3371C3.60123 15.3371 3.17352 14.9094 3.17352 14.3818V13.8087H2.60035C2.07278 13.8087 1.64506 13.3809 1.64506 12.8534C1.64506 12.3258 2.07278 11.8981 2.60035 11.8981H3.17352V11.3249C3.17352 10.7973 3.60123 10.3696 4.12881 10.3696C4.65638 10.3696 5.08409 10.7973 5.08409 11.3249V11.8981H5.65726C6.18484 11.8981 6.61255 12.3258 6.61255 12.8534C6.61255 13.3809 6.18484 13.8087 5.65726 13.8087H5.08409V14.3818Z"
        fill="#3C4CD1" />
      <path
        d="M1.51759 21.0687H2.09076V20.4956C2.09076 19.968 2.51847 19.5403 3.04604 19.5403C3.57361 19.5403 4.00133 19.968 4.00133 20.4956V21.0687H4.5745C5.10207 21.0687 5.52979 21.4965 5.52979 22.024C5.52979 22.5516 5.10207 22.9793 4.5745 22.9793H4.00133V23.5525C4.00133 24.0801 3.57361 24.5078 3.04604 24.5078C2.51847 24.5078 2.09076 24.0801 2.09076 23.5525V22.9793H1.51759C0.990013 22.9793 0.5623 22.5516 0.5623 22.024C0.5623 21.4965 0.990013 21.0687 1.51759 21.0687Z"
        fill="#3C4CD1" />
      <path
        d="M23.9988 3.55524H23.4256V4.12841C23.4256 4.65598 22.9979 5.0837 22.4704 5.0837C21.9428 5.0837 21.5151 4.65598 21.5151 4.12841V3.55524H20.9419C20.4143 3.55524 19.9866 3.12753 19.9866 2.59995C19.9866 2.07238 20.4143 1.64467 20.9419 1.64467H21.5151V1.0715C21.5151 0.543924 21.9428 0.116211 22.4704 0.116211C22.9979 0.116211 23.4256 0.543924 23.4256 1.0715V1.64467H23.9988C24.5264 1.64467 24.9541 2.07238 24.9541 2.59995C24.9541 3.12753 24.5265 3.55524 23.9988 3.55524Z"
        fill="#3C4CD1" />
      <path
        d="M27.53 7.569L23.9636 9.60694C23.5076 9.86761 22.9232 9.71164 22.6602 9.25151C22.3985 8.79342 22.5576 8.20993 23.0157 7.94812L26.5821 5.91017C27.04 5.64849 27.6236 5.80758 27.8855 6.2656C28.1472 6.72376 27.988 7.30725 27.53 7.569Z"
        fill="#3C4CD1" />
      <path
        d="M29.6047 13.2993C29.5196 13.2993 29.8828 13.3415 25.4091 12.7823C24.8855 12.7169 24.5142 12.2394 24.5797 11.7159C24.6451 11.1923 25.1227 10.8204 25.6461 10.8865L29.722 11.396C30.2455 11.4614 30.6169 11.9389 30.5513 12.4624C30.491 12.9456 30.0795 13.2993 29.6047 13.2993Z"
        fill="#3C4CD1" />
      <path
        d="M8.3946 22.5692C8.65641 22.1111 9.23996 21.9519 9.69799 22.2137C10.156 22.4755 10.3152 23.059 10.0534 23.5171L8.01548 27.0835C7.83913 27.3921 7.51682 27.5651 7.18521 27.5651C6.46435 27.5651 5.989 26.7791 6.35666 26.1356L8.3946 22.5692Z"
        fill="#3C4CD1" />
      <path
        d="M12.1622 24.133C12.6859 24.0673 13.1632 24.439 13.2286 24.9624L13.7381 29.0383C13.8092 29.6067 13.3665 30.1121 12.789 30.1121C12.3143 30.1121 11.9027 29.7585 11.8424 29.2752L11.3329 25.1993C11.2673 24.6759 11.6387 24.1984 12.1622 24.133Z"
        fill="#3C4CD1" />
    </svg>
      Generate
  </button>
  <div class="harmony-menu" id="harmonyMenu" style="display: none;">
      <div class="menu-item" data-harmony="Monochromatic">Monochromatic</div>
      <div class="menu-item" data-harmony="Analogous">Analogous</div>
      <div class="menu-item" data-harmony="Complementary">Complementary</div>
      <div class="menu-item" data-harmony="Split Complementary">Split Complementary</div>
      <div class="menu-item" data-harmony="Triadic">Triadic</div>
      <div class="menu-item" data-harmony="Tetradic">Tetradic</div>
      <div class="menu-item" data-harmony="Square">Square</div>
  </div>
</div>

<div class="harmony-menu" id="harmonyMenu" style="display: none;">
  <div class="menu-item" data-harmony="Monochromatic">Monochromatic</div>
  <div class="menu-item" data-harmony="Analogous">Analogous</div>
  <div class="menu-item" data-harmony="Complementary">Complementary</div>
  <div class="menu-item" data-harmony="Split Complementary">Split Complementary</div>
  <div class="menu-item" data-harmony="Triadic">Triadic</div>
  <div class="menu-item" data-harmony="Tetradic">Tetradic</div>
  <div class="menu-item" data-harmony="Square">Square</div>
</div>

  <div id="visualizer_buttons" class="rounded-2 d-flex bg-linear-blue">
      <button type="button" class="btn btn-success4">
        <svg width="22" height="22" viewBox="0 0 33 32" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path
            d="M23.2749 28.3968C22.9097 28.803 22.4518 29.115 21.9402 29.3062C21.4286 29.4974 20.8784 29.5623 20.3363 29.4952H6.07123C3.57168 29.4952 2.50497 28.4285 2.50497 25.929V6.90888C2.50497 4.40932 3.57168 3.34261 6.07123 3.34261H14.3925V6.90888C14.2994 7.71194 14.3892 8.52565 14.655 9.28915C14.9207 10.0526 15.3557 10.7462 15.9274 11.3178C16.499 11.8895 17.1925 12.3244 17.956 12.5902C18.7195 12.856 19.5332 12.9457 20.3363 12.8527H23.9026V16.4189C23.9026 16.7342 24.0278 17.0366 24.2507 17.2595C24.4737 17.4824 24.7761 17.6077 25.0913 17.6077C25.4066 17.6077 25.709 17.4824 25.9319 17.2595C26.1548 17.0366 26.2801 16.7342 26.2801 16.4189V11.6639C26.2802 11.5078 26.2495 11.3532 26.1896 11.2091C26.1298 11.0649 26.042 10.934 25.9314 10.8239L16.4213 1.3138C16.3112 1.20317 16.1803 1.11541 16.0361 1.05557C15.892 0.995725 15.7374 0.96498 15.5813 0.965102H6.07123C5.26818 0.872024 4.45446 0.961736 3.69097 1.22753C2.92748 1.49332 2.23397 1.92831 1.66231 2.49996C1.09066 3.07161 0.655674 3.76512 0.389882 4.52862C0.12409 5.29211 0.0343773 6.10582 0.127455 6.90888V25.929C0.0343773 26.732 0.12409 27.5457 0.389882 28.3092C0.655674 29.0727 1.09066 29.7662 1.66231 30.3379C2.23397 30.9095 2.92748 31.3445 3.69097 31.6103C4.45446 31.8761 5.26818 31.9658 6.07123 31.8728H20.3363C21.2537 31.9506 22.1762 31.8025 23.0231 31.4414C23.87 31.0802 24.6155 30.5171 25.1944 29.8012C25.3806 29.5466 25.4581 29.2285 25.4098 28.9169C25.3615 28.6052 25.1913 28.3255 24.9368 28.1393C24.6823 27.953 24.3642 27.8756 24.0525 27.9239C23.7408 27.9722 23.4611 28.1423 23.2749 28.3968ZM16.77 6.90888V5.02431L22.2209 10.4751H20.3363C17.8367 10.4751 16.77 9.40844 16.77 6.90888ZM32.2714 23.599L29.1014 26.769C28.8761 26.979 28.578 27.0933 28.27 27.0879C27.9621 27.0825 27.6682 26.9577 27.4504 26.7399C27.2326 26.5221 27.1079 26.2283 27.1024 25.9203C27.097 25.6123 27.2113 25.3143 27.4213 25.0889L28.5609 23.9477H17.1663C16.851 23.9477 16.5486 23.8225 16.3257 23.5995C16.1028 23.3766 15.9775 23.0742 15.9775 22.759C15.9775 22.4437 16.1028 22.1413 16.3257 21.9184C16.5486 21.6954 16.851 21.5702 17.1663 21.5702H28.5609L27.4213 20.429C27.2113 20.2036 27.097 19.9056 27.1024 19.5976C27.1079 19.2897 27.2326 18.9958 27.4504 18.778C27.6682 18.5602 27.9621 18.4355 28.27 18.43C28.578 18.4246 28.8761 18.5389 29.1014 18.7489L32.2714 21.9189C32.3809 22.0302 32.4681 22.1615 32.5282 22.3056C32.6179 22.5227 32.6415 22.7615 32.5958 22.992C32.5501 23.2224 32.4372 23.4326 32.2714 23.599Z"
            fill="white" />
        </svg>
      </button>

  </div>
</footer>

<style>
.upload-wrapper {
  position: relative;
  display: inline-block;
  line-height: 0;
}
#fileInput {
  display: none;
}
#uploadForm {
  margin: 0 !important;
  padding: 0 !important;
  display: inline-block;
  line-height: 0;
}
button {
  margin: 0 !important;
  line-height: 1;
}
</style>

<script>
document.getElementById('fileInput').onchange = function() {
  if (this.files.length > 0) {
      document.getElementById('uploadForm').submit();
  }
};
</script>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script>

      </script>
    <script>


      document.addEventListener('DOMContentLoaded', function() {
        const trendingButton = document.getElementById('trendingButton');
        const secondaryColumn = document.getElementById('secondaryColumn');
    
        // Initially hide the secondary column
        secondaryColumn.style.display = 'none';
    
        trendingButton.addEventListener('click', function(e) {
            e.preventDefault();
            
            // Toggle the secondary column
            if (secondaryColumn.style.display === 'none') {
                secondaryColumn.style.display = 'flex';
                // If the sidebar is collapsed, uncollapse it
                if (secondaryColumn.classList.contains('collapsed')) {
                    const toggleButton = secondaryColumn.querySelector('button');
                    toggleSidebar('secondaryColumn', toggleButton);
                }
            } else {
                secondaryColumn.style.display = 'none';
            }
        });
    });


      // Function to toggle sidebar collapsed state and change the icon
      function toggleSidebar(id, button) {
        const sidebar = document.getElementById(id);
        const icon = button.querySelector("i");
        const mostLeftUl = sidebar.querySelectorAll(
          ".mostLeftUl li a .textSpan"
        );
        mostLeftUl.forEach((span) => {
          if (span.style.display === "none") {
            span.style.display = "inline"; // Show the span
          } else {
            span.style.display = "none"; // Hide the span
          }
        });

        sidebar.classList.toggle("collapsed");

        // Update the icon based on the collapse state
        if (sidebar.classList.contains("collapsed")) {

          icon.classList.remove("bi-caret-left-fill", "bi-caret-right-fill");
          icon.classList.add("bi-caret-right-fill");
          //mostLeftUl.style.display = "none";
        } else {

          icon.classList.remove("bi-caret-left-fill", "bi-caret-right-fill");
          icon.classList.add("bi-caret-left-fill");
          //mostLeftUl.style.display = "inline";
        }
      }
      function hideModal(){
        $('#colorPickerModal').modal('hide');
      }

      document.addEventListener('DOMContentLoaded', function() {
        const secondaryColumn = document.getElementById('secondaryColumn');
        const navButtons = document.querySelectorAll('.mostLeftUl li a');
        const inspirationButton = document.getElementById('inspirationButton');
        const contents = {
            trendingContent: document.getElementById('trendingContent'),
            inspirationContent: document.getElementById('inspirationContent'),
            ssCollectionContent: document.getElementById('ssCollectionContent'),
            awCollectionContent: document.getElementById('awCollectionContent'),
            baseColorContent: document.getElementById('baseColorContent'),
            effectsContent: document.getElementById('effectsContent')
        };
    
        // Function to show content
        function showContent(contentId) {
            // Hide all content sections
            Object.values(contents).forEach(content => {
                if (content) content.style.display = 'none';
            });
            
            // Show the selected content
            const selectedContent = document.getElementById(contentId);
            if (selectedContent) selectedContent.style.display = 'block';
        }
    
        // Function to handle active state
        function setActiveButton(activeButton) {
            navButtons.forEach(button => {
                button.classList.remove('active');
            });
            activeButton.classList.add('active');
        }
    
        // Effect application logic
        const effectItems = document.querySelectorAll('.effect-item');
        effectItems.forEach(item => {
            item.addEventListener('click', function() {
                const effect = this.dataset.effect;
                applyEffectToLayers(effect);
            });
        });
    
        // Initialize base colors
        generateBaseColors();
    
        // Add click handlers for all navigation buttons
        navButtons.forEach(button => {
            button.addEventListener('click', function(e) {
                e.preventDefault();
                setActiveButton(this);
                
                // Handle different sections
                const contentMap = {
                    'trendingButton': 'trendingContent',
                    'inspirationButton': 'inspirationContent',
                    'effectsButton': 'effectsContent',
                    'ssCollectionButton': 'ssCollectionContent',
                    'awCollectionButton': 'awCollectionContent',
                    'baseColorButton': 'baseColorContent',
                    'favoriteButton':'favCollectionContent'
                };
    
                const contentId = contentMap[this.id];
                
                if (contentId) {
                    secondaryColumn.style.display = 'flex';
                    showContent(contentId);
                    
                    // Special handling for base color content
                    if (this.id === 'baseColorButton') {
                        const basePalettesSection = document.querySelector('.base-palettes-section');
                        if (basePalettesSection) {
                            basePalettesSection.style.display = selectedBaseColor ? 'block' : 'none';
                        }
                    }
                } else {
                    // Hide secondary column for other buttons (favorite, etc.)
                    secondaryColumn.style.display = 'none';
                }
                
                // If the sidebar is collapsed, uncollapse it
                if (secondaryColumn.classList.contains('collapsed')) {
                    const toggleButton = secondaryColumn.querySelector('button');
                    toggleSidebar('secondaryColumn', toggleButton);
                }
            });
        });
    
        // Set initial state
        window.onload = function() {
            // Show Inspiration content by default
            secondaryColumn.style.display = 'flex';
            showContent('inspirationContent');
            setActiveButton(inspirationButton);
        };
    });
    const layerStates = {
      editedImages: {},
      originalImages: {},
      currentStates: {}, // Add this to track current states
      history: {}, // Add this to track state history
      maxHistoryLength: 10, // Maximum number of states to keep in history
  
      saveEditedState: function(layerIndex) {
          const canvas = document.getElementById(`layer_canvas_${layerIndex}`);
          if (canvas) {
              const dataUrl = canvas.toDataURL();
              this.editedImages[layerIndex] = dataUrl;
              
              // Add to history
              if (!this.history[layerIndex]) {
                  this.history[layerIndex] = [];
              }
              
              this.history[layerIndex].push(dataUrl);
              
              // Keep history within size limit
              if (this.history[layerIndex].length > this.maxHistoryLength) {
                  this.history[layerIndex].shift();
              }
              
              // Update current state
              this.currentStates[layerIndex] = dataUrl;
          }
      },
  
      saveOriginalState: function(layerIndex) {
          const canvas = document.getElementById(`layer_canvas_${layerIndex}`);
          if (canvas) {
              const dataUrl = canvas.toDataURL();
              this.originalImages[layerIndex] = dataUrl;
              
              // Initialize history with original state
              this.history[layerIndex] = [dataUrl];
              this.currentStates[layerIndex] = dataUrl;
          }
      },
  
      getEditedState: function(layerIndex) {
          return this.editedImages[layerIndex];
      },
  
      getOriginalState: function(layerIndex) {
          return this.originalImages[layerIndex];
      },
  
      getCurrentState: function(layerIndex) {
          return this.currentStates[layerIndex] || this.originalImages[layerIndex];
      },
  
      hasEditedState: function(layerIndex) {
          return !!this.editedImages[layerIndex];
      },
  
      hasOriginalState: function(layerIndex) {
          return !!this.originalImages[layerIndex];
      },
  
      // New methods for state management
      undoLastChange: function(layerIndex) {
          if (this.history[layerIndex] && this.history[layerIndex].length > 1) {
              this.history[layerIndex].pop(); // Remove current state
              const previousState = this.history[layerIndex][this.history[layerIndex].length - 1];
              this.currentStates[layerIndex] = previousState;
              this.applyState(layerIndex, previousState);
              return true;
          }
          return false;
      },
  
      resetToOriginal: function(layerIndex) {
          if (this.hasOriginalState(layerIndex)) {
              this.history[layerIndex] = [this.originalImages[layerIndex]];
              this.currentStates[layerIndex] = this.originalImages[layerIndex];
              this.applyState(layerIndex, this.originalImages[layerIndex]);
              return true;
          }
          return false;
      },
  
      applyState: function(layerIndex, state) {
          const canvas = document.getElementById(`layer_canvas_${layerIndex}`);
          if (canvas && state) {
              const ctx = canvas.getContext('2d');
              const img = new Image();
              img.onload = function() {
                  ctx.clearRect(0, 0, canvas.width, canvas.height);
                  ctx.drawImage(img, 0, 0);
              };
              img.src = state;
          }
      },
  
      // Method to check if we can undo
      canUndo: function(layerIndex) {
          return this.history[layerIndex] && this.history[layerIndex].length > 1;
      },
  
      // Method to get state history
      getHistory: function(layerIndex) {
          return this.history[layerIndex] || [];
      },
  
      // Method to clear all states for a layer
      clearStates: function(layerIndex) {
          delete this.editedImages[layerIndex];
          delete this.currentStates[layerIndex];
          this.history[layerIndex] = [];
          if (this.originalImages[layerIndex]) {
              this.history[layerIndex] = [this.originalImages[layerIndex]];
              this.currentStates[layerIndex] = this.originalImages[layerIndex];
          }
      },
  
      // Method to save intermediate state
      saveIntermediateState: function(layerIndex) {
          const canvas = document.getElementById(`layer_canvas_${layerIndex}`);
          if (canvas) {
              const dataUrl = canvas.toDataURL();
              if (!this.history[layerIndex]) {
                  this.history[layerIndex] = [];
              }
              this.history[layerIndex].push(dataUrl);
              this.currentStates[layerIndex] = dataUrl;
              
              // Keep history within size limit
              if (this.history[layerIndex].length > this.maxHistoryLength) {
                  this.history[layerIndex].shift();
              }
          }
      },
  
      // Method to restore to a specific state in history
      restoreToState: function(layerIndex, stateIndex) {
          if (this.history[layerIndex] && this.history[layerIndex][stateIndex]) {
              const state = this.history[layerIndex][stateIndex];
              this.currentStates[layerIndex] = state;
              this.applyState(layerIndex, state);
              // Trim history to this point
              this.history[layerIndex] = this.history[layerIndex].slice(0, stateIndex + 1);
              return true;
          }
          return false;
      }
  };

{% comment %} effect js  {% endcomment %}

document.addEventListener('DOMContentLoaded', function() {
  // Add effects button handler
  const effectsButton = document.getElementById('effectsButton');
  if (effectsButton) {
      effectsButton.addEventListener('click', function(e) {
          e.preventDefault();
          secondaryColumn.style.display = 'flex';
          showContent('effectsContent');
          if (secondaryColumn.classList.contains('collapsed')) {
              const toggleButton = secondaryColumn.querySelector('button');
              toggleSidebar('secondaryColumn', toggleButton);
          }
      });
  }

  // Effect application logic
  const effectItems = document.querySelectorAll('.effect-item');
  effectItems.forEach(item => {
      item.addEventListener('click', function() {
          const effect = this.dataset.effect;
          applyEffectToLayers(effect);
      });
  });
});

function applyEffectToLayers(effect) {
  const totalLayers = document.querySelectorAll('[id^="layer_canvas_"]').length;
  
  for (let layer = 1; layer <= totalLayers; layer++) {
      const colorButton = document.querySelector(`.color-picker[data-layer-index="${layer-1}"]`);
      if (colorButton && colorButton.dataset.locked === 'true') {
          console.log(`Layer ${layer} is locked, skipping effect`);
          continue;
      }

      const canvas = document.getElementById(`layer_canvas_${layer}`);
      if (!canvas) continue;

      const ctx = canvas.getContext('2d');
      if (!ctx) continue;

      if (!layerStates.hasOriginalState(layer)) {
          layerStates.saveOriginalState(layer);
      }

      switch(effect) {
          case 'grayscale':
              applyGrayscale(ctx, canvas.width, canvas.height);
              break;
          case 'sepia':
              applySepia(ctx, canvas.width, canvas.height);
              break;
          case 'brightness':
              applyBrightness(ctx, canvas.width, canvas.height, 1.5);
              break;
          case 'contrast':
              applyContrast(ctx, canvas.width, canvas.height, 1.5);
              break;
          case 'blur':
              applyBlur(ctx, canvas.width, canvas.height);
              break;
          case 'sharpen':
              applySharpen(ctx, canvas.width, canvas.height);
              break;
          case 'vintage':
              applyVintage(ctx, canvas.width, canvas.height);
              break;
          case 'colorize':
              applyColorize(ctx, canvas.width, canvas.height, '#ff6b6b');
              break;
          case 'duotone':
              applyDuotone(ctx, canvas.width, canvas.height, '#ff6b6b', '#4ecdc4');
              break;
          case 'noise':
              applyNoise(ctx, canvas.width, canvas.height, 20);
              break;
          case 'vignette':
              applyVignette(ctx, canvas.width, canvas.height);
              break;
          case 'posterize':
              applyPosterize(ctx, canvas.width, canvas.height, 4);
              break;
          case 'saturation':
              applySaturation(ctx, canvas.width, canvas.height, 1.5);
              break;
      }

      layerStates.saveEditedState(layer);
  }
}

function applyGrayscale(ctx, width, height) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  
  for (let i = 0; i < data.length; i += 4) {
      const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
      data[i] = avg;     // Red
      data[i + 1] = avg; // Green
      data[i + 2] = avg; // Blue
  }
  
  ctx.putImageData(imageData, 0, 0);
}

function applySepia(ctx, width, height) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  
  for (let i = 0; i < data.length; i += 4) {
      const r = data[i];
      const g = data[i + 1];
      const b = data[i + 2];
      
      data[i] = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189));
      data[i + 1] = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168));
      data[i + 2] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131));
  }
  
  ctx.putImageData(imageData, 0, 0);
}

function applyBrightness(ctx, width, height, factor) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  
  for (let i = 0; i < data.length; i += 4) {
      data[i] = Math.min(255, data[i] * factor);
      data[i + 1] = Math.min(255, data[i + 1] * factor);
      data[i + 2] = Math.min(255, data[i + 2] * factor);
  }
  
  ctx.putImageData(imageData, 0, 0);
}

function applyContrast(ctx, width, height, factor) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  
  for (let i = 0; i < data.length; i += 4) {
      for (let j = 0; j < 3; j++) {
          data[i + j] = ((data[i + j] - 128) * factor) + 128;
      }
  }
  
  ctx.putImageData(imageData, 0, 0);
}

function applyBlur(ctx, width, height) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  const kernel = [
      [1/9, 1/9, 1/9],
      [1/9, 1/9, 1/9],
      [1/9, 1/9, 1/9]
  ];
  
  const result = new Uint8ClampedArray(data.length);
  
  for (let y = 1; y < height - 1; y++) {
      for (let x = 1; x < width - 1; x++) {
          for (let c = 0; c < 3; c++) {
              let sum = 0;
              for (let ky = -1; ky <= 1; ky++) {
                  for (let kx = -1; kx <= 1; kx++) {
                      const idx = ((y + ky) * width + (x + kx)) * 4 + c;
                      sum += data[idx] * kernel[ky + 1][kx + 1];
                  }
              }
              result[(y * width + x) * 4 + c] = sum;
          }
          result[(y * width + x) * 4 + 3] = data[(y * width + x) * 4 + 3];
      }
  }
  
  imageData.data.set(result);
  ctx.putImageData(imageData, 0, 0);
}

function applySharpen(ctx, width, height) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  const kernel = [
      [0, -1, 0],
      [-1, 5, -1],
      [0, -1, 0]
  ];
  
  const result = new Uint8ClampedArray(data.length);
  
  for (let y = 1; y < height - 1; y++) {
      for (let x = 1; x < width - 1; x++) {
          for (let c = 0; c < 3; c++) {
              let sum = 0;
              for (let ky = -1; ky <= 1; ky++) {
                  for (let kx = -1; kx <= 1; kx++) {
                      const idx = ((y + ky) * width + (x + kx)) * 4 + c;
                      sum += data[idx] * kernel[ky + 1][kx + 1];
                  }
              }
              result[(y * width + x) * 4 + c] = Math.min(255, Math.max(0, sum));
          }
          result[(y * width + x) * 4 + 3] = data[(y * width + x) * 4 + 3];
      }
  }
  
  imageData.data.set(result);
  ctx.putImageData(imageData, 0, 0);
}

function applyVintage(ctx, width, height) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  
  for (let i = 0; i < data.length; i += 4) {
      const r = data[i];
      const g = data[i + 1];
      const b = data[i + 2];
      
      data[i] = r * 0.9 + 20;
      data[i + 1] = g * 0.7 + 20;
      data[i + 2] = b * 0.5 + 30;
  }
  
  ctx.putImageData(imageData, 0, 0);
}

function applyColorize(ctx, width, height, color) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  
  // Convert hex color to RGB
  const r = parseInt(color.substr(1,2), 16);
  const g = parseInt(color.substr(3,2), 16);
  const b = parseInt(color.substr(5,2), 16);
  
  for (let i = 0; i < data.length; i += 4) {
      const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
      data[i] = avg * (r / 255);
      data[i + 1] = avg * (g / 255);
      data[i + 2] = avg * (b / 255);
  }
  
  ctx.putImageData(imageData, 0, 0);
}

function applyDuotone(ctx, width, height, color1, color2) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  
  // Convert hex colors to RGB
  const r1 = parseInt(color1.substr(1,2), 16);
  const g1 = parseInt(color1.substr(3,2), 16);
  const b1 = parseInt(color1.substr(5,2), 16);
  
  const r2 = parseInt(color2.substr(1,2), 16);
  const g2 = parseInt(color2.substr(3,2), 16);
  const b2 = parseInt(color2.substr(5,2), 16);
  
  for (let i = 0; i < data.length; i += 4) {
      const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
      const t = avg / 255;
      
      data[i] = r1 + (r2 - r1) * t;
      data[i + 1] = g1 + (g2 - g1) * t;
      data[i + 2] = b1 + (b2 - b1) * t;
  }
  
  ctx.putImageData(imageData, 0, 0);
}

function applyNoise(ctx, width, height, amount) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  
  for (let i = 0; i < data.length; i += 4) {
      const noise = (Math.random() - 0.5) * amount;
      data[i] = Math.min(255, Math.max(0, data[i] + noise));
      data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + noise));
      data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + noise));
  }
  
  ctx.putImageData(imageData, 0, 0);
}

function applyVignette(ctx, width, height) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  const centerX = width / 2;
  const centerY = height / 2;
  const radius = Math.sqrt(centerX * centerX + centerY * centerY);
  
  for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
          const idx = (y * width + x) * 4;
          const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
          const vignette = 1 - Math.pow(distance / radius, 2);
          
          data[idx] *= vignette;
          data[idx + 1] *= vignette;
          data[idx + 2] *= vignette;
      }
  }
  
  ctx.putImageData(imageData, 0, 0);
}

function applyPosterize(ctx, width, height, levels) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  const step = 255 / (levels - 1);
  
  for (let i = 0; i < data.length; i += 4) {
      data[i] = Math.round(data[i] / step) * step;
      data[i + 1] = Math.round(data[i + 1] / step) * step;
      data[i + 2] = Math.round(data[i + 2] / step) * step;
  }
  
  ctx.putImageData(imageData, 0, 0);
}

function applySaturation(ctx, width, height, factor) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  
  for (let i = 0; i < data.length; i += 4) {
      const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
      data[i] = avg + (data[i] - avg) * factor;
      data[i + 1] = avg + (data[i + 1] - avg) * factor;
      data[i + 2] = avg + (data[i + 2] - avg) * factor;
  }
  
  ctx.putImageData(imageData, 0, 0);
}
{% comment %} effect js end  {% endcomment %}


{% comment %} for pdf {% endcomment %}
// Function to download PDF
function loadInspirationContent() {
  const inspirationContent = document.getElementById('inspirationContent');

  // Show loading state
  inspirationContent.innerHTML = '<div class="text-center"><div class="spinner-border" role="status"></div></div>';

  fetch('inspiration-pdfs/') // Update this URL to match your URL configuration
      .then(response => response.json())
      .then(data => {
          let htmlContent = `
              <h4 class="ms-auto me-auto">Inspirations</h4>
              <div class="inspiration-content">
                  <div class="pdf-grid">
          `;

          data.pdfs.forEach(pdf => {
              htmlContent += `
                  <div class="pdf-item">
                      <div class="pdf-preview" data-pdf-id="${pdf.id}">
                          <img src="${pdf.preview_image}" alt="${pdf.title}">
                          <div class="pdf-info">
                              <span class="pdf-name">${pdf.title}</span>
                              <div class="pdf-actions">
                                  <span class="pdf-likes">
                                      <i class="bi ${pdf.liked ? 'bi-heart-fill' : 'bi-heart'}"></i> 
                                      <span class="likes-count">${pdf.likes_count}</span>
                                  </span>
                                  <button class="btn btn-sm btn-primary download-btn">
                                      <i class="bi bi-download"></i>
                                  </button>
                              </div>
                          </div>
                      </div>
                  </div>
              `;
          });

          htmlContent += `
                  </div>
              </div>
          `;

          inspirationContent.innerHTML = htmlContent;
          initializePDFEvents(); // Call this after adding the content
      })
      .catch(error => {
          console.error('Error:', error);
          inspirationContent.innerHTML = '<div class="alert alert-danger">Error loading PDFs</div>';
      });
}

function toggleLike(pdfId, element) {
  fetch('inspiration-pdfs/', {
      method: 'POST',
      headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'X-CSRFToken': getCookie('csrftoken'),
      },
      body: `pdf_id=${pdfId}`
  })
  .then(response => response.json())
  .then(data => {
      // Update the like button and count based on the response
      element.className = data.liked ? 'bi bi-heart-fill' : 'bi-heart';
      element.closest('.pdf-likes').querySelector('.likes-count').textContent = data.likes_count;
  })
  .catch(error => console.error('Error:', error));
}

function getCookie(name) {
  let cookieValue = null;
  if (document.cookie && document.cookie !== '') {
      const cookies = document.cookie.split(';');
      for (let i = 0; i < cookies.length; i++) {
          const cookie = cookies[i].trim();
          if (cookie.substring(0, name.length + 1) === (name + '=')) {
              cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
              break;
          }
      }
  }
  return cookieValue;
}

function downloadPDF(pdfUrl, title) {
  fetch(pdfUrl)
      .then(response => response.blob())
      .then(blob => {
          const url = window.URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = title;
          document.body.appendChild(a);
          a.click();
          window.URL.revokeObjectURL(url);
          document.body.removeChild(a);
      })
      .catch(error => {
          console.error('Error downloading PDF:', error);
          alert('Error downloading the PDF');
      });
}

function initializePDFEvents() {
  document.querySelectorAll('.pdf-likes i').forEach(element => {
      element.addEventListener('click', function(e) {
          e.stopPropagation();
          const pdfId = this.closest('.pdf-preview').dataset.pdfId;
          toggleLike(pdfId, this);
      });
  });

  document.querySelectorAll('.download-btn').forEach(button => {
      button.addEventListener('click', function(e) {
          e.stopPropagation();
          const pdfPreview = this.closest('.pdf-preview');
          const pdfUrl = pdfPreview.dataset.pdfUrl; // Make sure to add this data attribute in your HTML
          const title = pdfPreview.querySelector('.pdf-name').textContent;
          downloadPDF(pdfUrl, title);
      });
  });
}

// Call this function when the page loads
loadInspirationContent();

// Call this function when inspiration button is clicked
document.getElementById('inspirationButton').addEventListener('click', function(e) {
  e.preventDefault();
  loadInspirationContent();
});
{% comment %} end pdf  {% endcomment %}

{% comment %} for base color  {% endcomment %}


// Function to convert RGB to HSV
function rgbToHsvBase(r, g, b) {
  r = r / 255;
  g = g / 255;
  b = b / 255;
  
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const diff = max - min;
  
  let h = 0;
  let s = max === 0 ? 0 : diff / max;
  let v = max;
  
  if (max === min) {
      h = 0;
  } else if (max === r) {
      h = (60 * ((g - b) / diff) + 360) % 360;
  } else if (max === g) {
      h = (60 * ((b - r) / diff) + 120) % 360;
  } else {
      h = (60 * ((r - g) / diff) + 240) % 360;
  }
  
  return [h, s, v];
}

function getColorName(rgb) {
  const [r, g, b] = rgb;
  
  function getHueName(h) {
      if (h < 15 || h >= 345) return "Red";
      if (h >= 15 && h < 45) return "Orange";
      if (h >= 45 && h < 75) return "Yellow";
      if (h >= 75 && h < 165) return "Green";
      if (h >= 165 && h < 195) return "Cyan";
      if (h >= 195 && h < 255) return "Blue";
      if (h >= 255 && h < 285) return "Purple";
      if (h >= 285 && h < 345) return "Pink";
  }

  function getShadePrefix(s, v) {
      if (v < 0.2) return "Dark";
      if (v > 0.8) return "Light";
      if (s < 0.2) return "Gray";
      if (s > 0.8) return "Vivid";
      return "";
  }

  // Convert RGB to HSV
  const rNorm = r / 255;
  const gNorm = g / 255;
  const bNorm = b / 255;
  const max = Math.max(rNorm, gNorm, bNorm);
  const min = Math.min(rNorm, gNorm, bNorm);
  const diff = max - min;

  // Calculate Hue
  let h = 0;
  if (max !== min) {
      if (max === rNorm) {
          h = (60 * ((gNorm - bNorm) / diff) + 360) % 360;
      } else if (max === gNorm) {
          h = (60 * ((bNorm - rNorm) / diff) + 120) % 360;
      } else {
          h = (60 * ((rNorm - gNorm) / diff) + 240) % 360;
      }
  }

  // Calculate Saturation
  const s = max === 0 ? 0 : diff / max;

  // Value
  const v = max;

  // Special cases for grayscale
  if (s < 0.1) {
      if (v < 0.2) return "Black";
      if (v < 0.4) return "Dark Gray";
      if (v < 0.6) return "Gray";
      if (v < 0.8) return "Light Gray";
      return "White";
  }

  const hueName = getHueName(h);
  const shadePrefix = getShadePrefix(s, v);

  return shadePrefix ? `${shadePrefix} ${hueName}` : hueName;
}

const style = document.createElement('style');
style.textContent = `
.base-colors-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 10px;
  padding: 15px;
}

.base-color-block {
  {% comment %} aspect-ratio: 3/1; {% endcomment %}
  border-radius: 8px;
  cursor: pointer;
  transition: transform 0.2s;
  border: 1px solid #ddd;
  position: relative;
  display: flex;
  align-items: center;
  padding: 10px;
  height: 8rem
}

.base-color-block:hover {
  transform: scale(1.02);
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.color-name {
  color: white;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
  font-size: 14px;
  font-weight: bold;
}

.base-palettes-section {
  margin-top: 20px;
  display: none;
}
`;
document.head.appendChild(style);

// Simplified background color selection function
function showBackgroundColorSelector(baseColor, originalColors) {
  // Create a simplified modal container
  const modalOverlay = document.createElement('div');
  modalOverlay.className = 'bg-selector-overlay';
  modalOverlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 9999;
  `;
  
  // Create modal content - improved responsiveness
  const modalContent = document.createElement('div');
  modalContent.className = 'bg-selector-content';
  modalContent.style.cssText = `
    background-color: white;
    border-radius: 8px;
    padding: 20px;
    max-width: 90%;
    width: 500px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.3);
    max-height: 90vh;
    overflow-y: auto;
  `;
  
  // Add header
  const header = document.createElement('div');
  header.style.cssText = `
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
  `;
  
  const title = document.createElement('h3');
  title.textContent = 'Select Background Color';
  title.style.cssText = `
    margin: 0;
    font-size: calc(1rem + 0.5vw);
  `;
  
  const closeButton = document.createElement('button');
  closeButton.innerHTML = '&times;';
  closeButton.style.cssText = `
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
    padding: 0 8px;
  `;
  
  header.appendChild(title);
  header.appendChild(closeButton);
  modalContent.appendChild(header);
  
  // Add description
  const description = document.createElement('p');
  description.textContent = 'Choose which color from your image should be treated as the background color:';
  description.style.cssText = `
    margin-bottom: 15px;
    font-size: 0.95rem;
  `;
  modalContent.appendChild(description);
  
  // Colors container - improved for mobile
  const colorsContainer = document.createElement('div');
  colorsContainer.style.cssText = `
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
    gap: 10px;
    justify-content: center;
    margin: 15px 0;
  `;
  
  // Add color swatches
  let selectedIndex = 0; // Default to first color
  
  originalColors.forEach((color, index) => {
    const colorSwatch = document.createElement('div');
    colorSwatch.style.cssText = `
      width: 100%;
      aspect-ratio: 1;
      background-color: rgb(${color.join(',')});
      border: ${index === 0 ? '3px solid #007bff' : '2px solid #ddd'};
      border-radius: 4px;
      cursor: pointer;
      transition: transform 0.2s, border 0.2s;
      position: relative;
    `;
    
    // Add index label
    const indexLabel = document.createElement('div');
    indexLabel.textContent = index + 1;
    indexLabel.style.cssText = `
      position: absolute;
      bottom: -8px;
      right: -8px;
      background-color: #333;
      color: white;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
    `;
    colorSwatch.appendChild(indexLabel);
    
    // Add class for identifying swatches
    colorSwatch.className = 'bg-color-swatch';
    colorSwatch.dataset.index = index;
    
    // If this is the first color, mark as selected
    if (index === 0) {
      colorSwatch.classList.add('selected-bg');
    }
    
    // Add click handler
    colorSwatch.addEventListener('click', () => {
      // Update selected index
      selectedIndex = index;
      
      // Update visual styling
      document.querySelectorAll('.bg-color-swatch').forEach(swatch => {
        swatch.style.border = '2px solid #ddd';
        swatch.classList.remove('selected-bg');
        swatch.style.transform = 'scale(1)';
      });
      
      colorSwatch.style.border = '3px solid #007bff';
      colorSwatch.classList.add('selected-bg');
      colorSwatch.style.transform = 'scale(1.05)';
    });
    
    colorsContainer.appendChild(colorSwatch);
  });
  
  modalContent.appendChild(colorsContainer);
  
  // Buttons container - improved for mobile
  const buttonsContainer = document.createElement('div');
  buttonsContainer.style.cssText = `
    display: flex;
    justify-content: space-between;
    margin-top: 20px;
    gap: 10px;
  `;
  
  // Cancel button
  const cancelButton = document.createElement('button');
  cancelButton.textContent = 'Cancel';
  cancelButton.style.cssText = `
    padding: 8px 16px;
    border: 1px solid #ddd;
    background-color: white;
    border-radius: 4px;
    cursor: pointer;
    flex: 1;
    min-height: 44px;
  `;
  
  // Confirm button
  const confirmButton = document.createElement('button');
  confirmButton.textContent = 'Apply';
  confirmButton.style.cssText = `
    padding: 8px 16px;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    flex: 1;
    min-height: 44px;
  `;
  
  buttonsContainer.appendChild(cancelButton);
  buttonsContainer.appendChild(confirmButton);
  modalContent.appendChild(buttonsContainer);
  
  // Add modal to page
  modalOverlay.appendChild(modalContent);
  document.body.appendChild(modalOverlay);
  
  // Return a promise that resolves when the user makes a selection
  return new Promise((resolve, reject) => {
    // Handle close button
    closeButton.addEventListener('click', () => {
      document.body.removeChild(modalOverlay);
      resolve(0); // Default to first color if closed
    });
    
    // Handle cancel button
    cancelButton.addEventListener('click', () => {
      document.body.removeChild(modalOverlay);
      resolve(0); // Default to first color if canceled
    });
    
    // Handle confirm button
    confirmButton.addEventListener('click', () => {
      document.body.removeChild(modalOverlay);
      resolve(selectedIndex);
    });
    
    // Handle clicking outside the modal
    modalOverlay.addEventListener('click', (e) => {
      if (e.target === modalOverlay) {
        document.body.removeChild(modalOverlay);
        resolve(0); // Default to first color if clicked outside
      }
    });
  });
}

 // Modified selectBaseColor function
// Add this style block to your CSS to make the grid of palettes look better
const paletteGridStyles = document.createElement('style');
paletteGridStyles.textContent = `
  .base-palettes-section .layer-toggles {
    display: grid !important;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)) !important;
    gap: 15px !important;
    justify-content: start !important;
    width: 100%;
  }
  
  .layer-toggle-item {
    width: 100%;
    margin-bottom: 15px;
  }
  
  .color-palette {
    width: 100%;
    min-height: 220px;
  }
  
  /* Make the palette container take full width within its grid cell */
  .palette-clickable-container {
    width: 100%;
    margin: 0 auto;
  }
  
  /* Make the preview container expand to fit width */
  .palette-preview-container {
    width: 100%;
    height: 200px;
  }
  
  /* Ensure palette number always visible */
  .palette-number {
    z-index: 5;
    background-color: rgba(0,0,0,0.7);
    font-weight: bold;
  }
  
  /* Add some extra breathing room */
  .base-palettes-section {
    margin-bottom: 40px;
  }
`;
document.head.appendChild(paletteGridStyles);


function generateBaseColorPalettes(baseColor, backgroundColorIndex = 0) {
  // Conversion utilities
  function rgbToHex(r, g, b) {
    return '#' + [r, g, b].map(x => {
      const hex = x.toString(16);
      return hex.length === 1 ? '0' + hex : hex;
    }).join('');
  }

  function rgbToHsl(r, g, b) {
    r /= 255;
    g /= 255;
    b /= 255;

    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;

    if (max === min) {
      h = s = 0;
    } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

      switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
      }
      h /= 6;
    }

    return [h * 360, s * 100, l * 100];
  }

  function hslToRgb(h, s, l) {
    h /= 360;
    s /= 100;
    l /= 100;

    let r, g, b;

    if (s === 0) {
      r = g = b = l;
    } else {
      const hue2rgb = (p, q, t) => {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1/6) return p + (q - p) * 6 * t;
        if (t < 1/2) return q;
        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
      };

      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;

      r = hue2rgb(p, q, h + 1/3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1/3);
    }

    return [
      Math.round(r * 255),
      Math.round(g * 255),
      Math.round(b * 255)
    ];
  }

  function randomInRange(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  // Get the original colors from various sources
  let distinctColors = [];
  let originalBackgroundColor = null;

  try {
    // Get colors from various sources (unchanged)
    if (window.originalColors && Array.isArray(window.originalColors) && window.originalColors.length > 0) {
      console.log("Using originalColors with background index:", backgroundColorIndex);
      distinctColors = [...window.originalColors];
      
      if (backgroundColorIndex >= 0 && backgroundColorIndex < distinctColors.length) {
        originalBackgroundColor = [...distinctColors[backgroundColorIndex]];
      }
    } 
    else if (localStorage.getItem('distinctColorsArrayColorPallet')) {
      try {
        const storedColorsString = localStorage.getItem('distinctColorsArrayColorPallet');
        const storedColors = JSON.parse(storedColorsString);

        if (Array.isArray(storedColors) && storedColors.length > 0) {
          distinctColors = storedColors.filter(color =>
            Array.isArray(color) &&
            color.length === 3 &&
            color.every(val => typeof val === 'number' && !isNaN(val))
          );
        }
      } catch (parseError) {
        console.error("Error parsing colors from localStorage:", parseError);
      }
    }
    else if (window.distinctColorsArrayColorPallet &&
             Array.isArray(window.distinctColorsArrayColorPallet) &&
             window.distinctColorsArrayColorPallet.length > 0) {

      distinctColors = window.distinctColorsArrayColorPallet.filter(color =>
        Array.isArray(color) &&
        color.length === 3 &&
        color.every(val => typeof val === 'number' && !isNaN(val))
      );
    }

    if (distinctColors.length === 0) {
      distinctColors = [
        [230, 140, 30],  // Orange
        [50, 80, 200],   // Blue
        [60, 180, 70],   // Green
        [240, 220, 40],  // Yellow
        [150, 60, 180],  // Purple
        [255, 0, 255]    // Magenta
      ];
    }
  } catch (e) {
    console.error("Error retrieving distinct colors:", e);
    distinctColors = [
      [230, 140, 30], [50, 80, 200], [60, 180, 70],
      [240, 220, 40], [150, 60, 180], [255, 0, 255]
    ];
  }

  // Get the base color's HSL values
  const baseHsl = rgbToHsl(...baseColor);
  
  try {
    // Get harmony scheme from the parameters or use default
    const harmonyScheme = baseColor.harmonyScheme || 'normal';
    const shadeType = baseColor.shadeType || 'regular';
    
    // STEP 1: Create a version of the selected base color with adjusted shade
    const adjustedBaseColor = [...baseColor]; // Start with the original base color
    
    // Apply shade adjustment to the base color
    if (shadeType === 'faint') {
      // For faint: keep hue, reduce saturation, increase lightness
      const faintHsl = [...baseHsl];
      faintHsl[1] = Math.max(10, baseHsl[1] * 0.8); // Reduce saturation slightly
      faintHsl[2] = Math.min(95, Math.max(70, baseHsl[2] * 1.3)); // Increase lightness
      
      // Only convert if changes were made
      if (faintHsl[1] !== baseHsl[1] || faintHsl[2] !== baseHsl[2]) {
        const rgbColor = hslToRgb(...faintHsl);
        adjustedBaseColor[0] = rgbColor[0];
        adjustedBaseColor[1] = rgbColor[1];
        adjustedBaseColor[2] = rgbColor[2];
      }
    } 
    else if (shadeType === 'dark') {
      // For dark: keep hue, possibly increase saturation, decrease lightness
      const darkHsl = [...baseHsl];
      darkHsl[1] = Math.min(100, baseHsl[1] * 1.1); // Slightly increase saturation
      darkHsl[2] = Math.max(10, Math.min(35, baseHsl[2] * 0.6)); // Decrease lightness
      
      // Only convert if changes were made
      if (darkHsl[1] !== baseHsl[1] || darkHsl[2] !== baseHsl[2]) {
        const rgbColor = hslToRgb(...darkHsl);
        adjustedBaseColor[0] = rgbColor[0];
        adjustedBaseColor[1] = rgbColor[1];
        adjustedBaseColor[2] = rgbColor[2];
      }
    }
    // For 'regular', we keep the color as is
    
    // STEP 2: Create palettes based on the adjusted base color
    const basePalettes = [];
    const paletteCount = 12; // Generate 12 palettes for each combination

    // Function to group colors by their perceptual distance for better harmony mapping
    function groupColorsByHarmony(colors, bgIndex, harmonyType) {
      // First convert all to HSL for easier comparison
      const colorsHSL = colors.map(color => rgbToHsl(...color));
      
      // Get background/base color HSL
      const bgColorHSL = colorsHSL[bgIndex];
      
      // Create groups based on harmony type
      const groups = [];
      
      switch(harmonyType) {
        case 'monochromatic':
          // Just one group - all colors
          groups.push([...Array(colors.length).keys()]);
          break;
          
        case 'complementary':
          // Two groups - those closer to base hue and those closer to complement
          const compHue = (bgColorHSL[0] + 180) % 360;
          
          const baseGroup = [];
          const compGroup = [];
          
          colorsHSL.forEach((color, index) => {
            // Skip background color - it's always in the base group
            if (index === bgIndex) {
              baseGroup.push(index);
              return;
            }
            
            // Calculate angular distance to base and complement
            const distToBase = Math.min(
              Math.abs(color[0] - bgColorHSL[0]),
              360 - Math.abs(color[0] - bgColorHSL[0])
            );
            
            const distToComp = Math.min(
              Math.abs(color[0] - compHue),
              360 - Math.abs(color[0] - compHue)
            );
            
            // Assign to closest group
            if (distToBase <= distToComp) {
              baseGroup.push(index);
            } else {
              compGroup.push(index);
            }
          });
          
          groups.push(baseGroup);
          groups.push(compGroup);
          break;
          
        case 'analogous':
          // Three groups - base and analogous on either side
          const analog1 = (bgColorHSL[0] - 30 + 360) % 360;
          const analog2 = (bgColorHSL[0] + 30) % 360;
          
          const analogGroup1 = [];
          const baseAnalogGroup = [];
          const analogGroup2 = [];
          
          colorsHSL.forEach((color, index) => {
            if (index === bgIndex) {
              baseAnalogGroup.push(index);
              return;
            }
            
            // Calculate distance to each analogous center
            const distToBase = Math.min(
              Math.abs(color[0] - bgColorHSL[0]),
              360 - Math.abs(color[0] - bgColorHSL[0])
            );
            
            const distToAnalog1 = Math.min(
              Math.abs(color[0] - analog1),
              360 - Math.abs(color[0] - analog1)
            );
            
            const distToAnalog2 = Math.min(
              Math.abs(color[0] - analog2),
              360 - Math.abs(color[0] - analog2)
            );
            
            // Find the smallest distance
            const minDist = Math.min(distToBase, distToAnalog1, distToAnalog2);
            
            if (minDist === distToAnalog1) {
              analogGroup1.push(index);
            } else if (minDist === distToBase) {
              baseAnalogGroup.push(index);
            } else {
              analogGroup2.push(index);
            }
          });
          
          groups.push(analogGroup1);
          groups.push(baseAnalogGroup);
          groups.push(analogGroup2);
          break;
          
        case 'splitComplementary':
          // Three groups - base and two split complements
          const splitComp1 = (bgColorHSL[0] + 150) % 360;
          const splitComp2 = (bgColorHSL[0] + 210) % 360;
          
          const baseSplitGroup = [];
          const splitGroup1 = [];
          const splitGroup2 = [];
          
          colorsHSL.forEach((color, index) => {
            if (index === bgIndex) {
              baseSplitGroup.push(index);
              return;
            }
            
            // Calculate distance to each split complementary center
            const distToBase = Math.min(
              Math.abs(color[0] - bgColorHSL[0]),
              360 - Math.abs(color[0] - bgColorHSL[0])
            );
            
            const distToSplit1 = Math.min(
              Math.abs(color[0] - splitComp1),
              360 - Math.abs(color[0] - splitComp1)
            );
            
            const distToSplit2 = Math.min(
              Math.abs(color[0] - splitComp2),
              360 - Math.abs(color[0] - splitComp2)
            );
            
            // Find the smallest distance
            const minDist = Math.min(distToBase, distToSplit1, distToSplit2);
            
            if (minDist === distToBase) {
              baseSplitGroup.push(index);
            } else if (minDist === distToSplit1) {
              splitGroup1.push(index);
            } else {
              splitGroup2.push(index);
            }
          });
          
          groups.push(baseSplitGroup);
          groups.push(splitGroup1);
          groups.push(splitGroup2);
          break;
          
        case 'triadic':
          // Three groups - three colors spaced 120° apart
          const triad1 = (bgColorHSL[0] + 120) % 360;
          const triad2 = (bgColorHSL[0] + 240) % 360;
          
          const baseTriadGroup = [];
          const triadGroup1 = [];
          const triadGroup2 = [];
          
          colorsHSL.forEach((color, index) => {
            if (index === bgIndex) {
              baseTriadGroup.push(index);
              return;
            }
            
            // Calculate distance to each triad center
            const distToBase = Math.min(
              Math.abs(color[0] - bgColorHSL[0]),
              360 - Math.abs(color[0] - bgColorHSL[0])
            );
            
            const distToTriad1 = Math.min(
              Math.abs(color[0] - triad1),
              360 - Math.abs(color[0] - triad1)
            );
            
            const distToTriad2 = Math.min(
              Math.abs(color[0] - triad2),
              360 - Math.abs(color[0] - triad2)
            );
            
            // Find the smallest distance
            const minDist = Math.min(distToBase, distToTriad1, distToTriad2);
            
            if (minDist === distToBase) {
              baseTriadGroup.push(index);
            } else if (minDist === distToTriad1) {
              triadGroup1.push(index);
            } else {
              triadGroup2.push(index);
            }
          });
          
          groups.push(baseTriadGroup);
          groups.push(triadGroup1);
          groups.push(triadGroup2);
          break;
          
        case 'tetradic':
          // Four groups - four colors in a rectangle on the color wheel
          const tetra1 = (bgColorHSL[0] + 90) % 360;
          const tetra2 = (bgColorHSL[0] + 180) % 360;
          const tetra3 = (bgColorHSL[0] + 270) % 360;
          
          const baseTetraGroup = [];
          const tetraGroup1 = [];
          const tetraGroup2 = [];
          const tetraGroup3 = [];
          
          colorsHSL.forEach((color, index) => {
            if (index === bgIndex) {
              baseTetraGroup.push(index);
              return;
            }
            
            // Calculate distance to each tetradic center
            const distToBase = Math.min(
              Math.abs(color[0] - bgColorHSL[0]),
              360 - Math.abs(color[0] - bgColorHSL[0])
            );
            
            const distToTetra1 = Math.min(
              Math.abs(color[0] - tetra1),
              360 - Math.abs(color[0] - tetra1)
            );
            
            const distToTetra2 = Math.min(
              Math.abs(color[0] - tetra2),
              360 - Math.abs(color[0] - tetra2)
            );
            
            const distToTetra3 = Math.min(
              Math.abs(color[0] - tetra3),
              360 - Math.abs(color[0] - tetra3)
            );
            
            // Find the smallest distance
            const minDist = Math.min(distToBase, distToTetra1, distToTetra2, distToTetra3);
            
            if (minDist === distToBase) {
              baseTetraGroup.push(index);
            } else if (minDist === distToTetra1) {
              tetraGroup1.push(index);
            } else if (minDist === distToTetra2) {
              tetraGroup2.push(index);
            } else {
              tetraGroup3.push(index);
            }
          });
          
          groups.push(baseTetraGroup);
          groups.push(tetraGroup1);
          groups.push(tetraGroup2);
          groups.push(tetraGroup3);
          break;
          
        case 'square':
          // Same as tetradic but with equal spacing (90° apart)
          const square1 = (bgColorHSL[0] + 90) % 360;
          const square2 = (bgColorHSL[0] + 180) % 360;
          const square3 = (bgColorHSL[0] + 270) % 360;
          
          const baseSquareGroup = [];
          const squareGroup1 = [];
          const squareGroup2 = [];
          const squareGroup3 = [];
          
          colorsHSL.forEach((color, index) => {
            if (index === bgIndex) {
              baseSquareGroup.push(index);
              return;
            }
            
            // Calculate distance to each square center
            const distToBase = Math.min(
              Math.abs(color[0] - bgColorHSL[0]),
              360 - Math.abs(color[0] - bgColorHSL[0])
            );
            
            const distToSquare1 = Math.min(
              Math.abs(color[0] - square1),
              360 - Math.abs(color[0] - square1)
            );
            
            const distToSquare2 = Math.min(
              Math.abs(color[0] - square2),
              360 - Math.abs(color[0] - square2)
            );
            
            const distToSquare3 = Math.min(
              Math.abs(color[0] - square3),
              360 - Math.abs(color[0] - square3)
            );
            
            // Find the smallest distance
            const minDist = Math.min(distToBase, distToSquare1, distToSquare2, distToSquare3);
            
            if (minDist === distToBase) {
              baseSquareGroup.push(index);
            } else if (minDist === distToSquare1) {
              squareGroup1.push(index);
            } else if (minDist === distToSquare2) {
              squareGroup2.push(index);
            } else {
              squareGroup3.push(index);
            }
          });
          
          groups.push(baseSquareGroup);
          groups.push(squareGroup1);
          groups.push(squareGroup2);
          groups.push(squareGroup3);
          break;
          
        case 'normal':
        default:
          // Normal mode - maintain original relationships
          // Each color will be treated individually, preserving its relationship to base
          colorsHSL.forEach((_, index) => {
            groups.push([index]); // Each color in its own group
          });
          break;
      }
      
      return groups;
    }

    // Function to get target hue based on harmony and group
    function getHarmonyHue(baseHue, harmonyType, groupIndex) {
      switch(harmonyType) {
        case 'monochromatic':
          return baseHue; // Same hue for all
          
        case 'complementary':
          return groupIndex === 0 ? baseHue : (baseHue + 180) % 360;
          
        case 'analogous':
          if (groupIndex === 0) return (baseHue - 30 + 360) % 360;
          if (groupIndex === 1) return baseHue;
          return (baseHue + 30) % 360;
          
        case 'splitComplementary':
          if (groupIndex === 0) return baseHue;
          if (groupIndex === 1) return (baseHue + 150) % 360;
          return (baseHue + 210) % 360;
          
        case 'triadic':
          if (groupIndex === 0) return baseHue;
          if (groupIndex === 1) return (baseHue + 120) % 360;
          return (baseHue + 240) % 360;
          
        case 'tetradic':
        case 'square':
          if (groupIndex === 0) return baseHue;
          if (groupIndex === 1) return (baseHue + 90) % 360;
          if (groupIndex === 2) return (baseHue + 180) % 360;
          return (baseHue + 270) % 360;
          
        default:
          return baseHue;
      }
    }

    for (let paletteIndex = 0; paletteIndex < paletteCount; paletteIndex++) {
      // Create a working copy of distinctColors
      let workingColors = [...distinctColors];
      
      // Get the adjusted base color's HSL
      const baseColorHSL = rgbToHsl(...adjustedBaseColor);
      
      // If we have a background color, replace it with our adjusted base color
      if (backgroundColorIndex >= 0 && backgroundColorIndex < workingColors.length) {
        workingColors[backgroundColorIndex] = [...adjustedBaseColor];
      }
      
      // Convert all working colors to HSL
      const workingColorsHSL = workingColors.map(color => rgbToHsl(...color));
      
      // Group colors based on harmony type for better correlation
      const colorGroups = groupColorsByHarmony(
        workingColors, 
        backgroundColorIndex, 
        harmonyScheme
      );
      
      // Process each group separately to maintain better correlation
      colorGroups.forEach((group, groupIndex) => {
        // Get the target hue for this group
        const targetHue = getHarmonyHue(baseColorHSL[0], harmonyScheme, groupIndex);
        
        // Process each color in the group
        group.forEach(colorIndex => {
          // Skip the background color - it's already set to the adjusted base color
          if (colorIndex === backgroundColorIndex) return;
          
          const originalHSL = workingColorsHSL[colorIndex];
          let newHSL = [...originalHSL];
          
          if (harmonyScheme === 'normal') {
            // For normal mode, maintain the exact relationship with the original colors
            // Calculate the relative relationship from original background to this color
            const bgOriginalHSL = rgbToHsl(...distinctColors[backgroundColorIndex]);
            
            // Calculate hue difference (accounting for the circular nature of hue)
            let hueDiff = originalHSL[0] - bgOriginalHSL[0];
            if (hueDiff > 180) hueDiff -= 360;
            if (hueDiff < -180) hueDiff += 360;
            
            // Calculate ratios for saturation and lightness
            const satRatio = originalHSL[1] / Math.max(1, bgOriginalHSL[1]);
            const lightRatio = originalHSL[2] / Math.max(1, bgOriginalHSL[2]);
            
            // Apply these relationships to the new base color
            newHSL[0] = (baseColorHSL[0] + hueDiff + 360) % 360;
            newHSL[1] = Math.min(100, Math.max(5, baseColorHSL[1] * satRatio));
            newHSL[2] = Math.min(95, Math.max(5, baseColorHSL[2] * lightRatio));
            
            // Apply small variations based on palette index
            const hueVar = (paletteIndex % 5) - 2; // -2 to +2 degrees variation
            newHSL[0] = (newHSL[0] + hueVar + 360) % 360;
            
            // Small saturation and lightness variations
            const satVar = 0.95 + (paletteIndex % 3) * 0.05; // 0.95-1.05
            const lightVar = 0.95 + (paletteIndex % 3) * 0.05; // 0.95-1.05
            
            newHSL[1] = Math.min(100, Math.max(5, newHSL[1] * satVar));
            newHSL[2] = Math.min(95, Math.max(5, newHSL[2] * lightVar));
          } else {
            // For harmony modes, we want to maintain the relationship WITHIN EACH GROUP
            // Calculate the original relationship in the group
            
            // First, find the "reference" color in the original image for this group
            // This helps maintain the relationships within each color family
            let referenceIndex = backgroundColorIndex;
            if (group.length > 1 && group[0] !== backgroundColorIndex) {
              referenceIndex = group[0];
            }
            
            const referenceHSL = workingColorsHSL[referenceIndex];
            
            // Calculate this color's relationship to the reference
            // For hue: we're replacing it with the target hue, but need to maintain small differences
            let hueDiff = originalHSL[0] - referenceHSL[0];
            if (hueDiff > 180) hueDiff -= 360;
            if (hueDiff < -180) hueDiff += 360;
            
            // For saturation and lightness: maintain the ratio
            const satRatio = originalHSL[1] / Math.max(1, referenceHSL[1]);
            const lightRatio = originalHSL[2] / Math.max(1, referenceHSL[2]);
            
            // Apply the relationship to the target hue
            // Here we use a smaller hue difference to keep colors more focused around the target hue
            // This prevents too much deviation while still maintaining some variety
            const scaledHueDiff = hueDiff * 0.3; // Scale down the hue difference 
            newHSL[0] = (targetHue + scaledHueDiff + 360) % 360;
            
            // Maintain saturation and lightness relationships
            // For the reference color (typically base), get its transformed values
            let referenceSaturation, referenceLightness;
            
            if (referenceIndex === backgroundColorIndex) {
              // If reference is background, use the adjusted base color's values
              referenceSaturation = baseColorHSL[1];
              referenceLightness = baseColorHSL[2];
            } else {
              // Otherwise, get the values from the current working colors
              const currentReferenceHSL = rgbToHsl(...workingColors[referenceIndex]);
              referenceSaturation = currentReferenceHSL[1];
              referenceLightness = currentReferenceHSL[2];
            }
            
            // Apply the relationship
            newHSL[1] = Math.min(100, Math.max(5, referenceSaturation * satRatio));
            newHSL[2] = Math.min(95, Math.max(5, referenceLightness * lightRatio));
            
            // Apply small variations based on palette index for more diversity
            const hueVar = (paletteIndex % 5) - 2; // -2 to +2 degrees variation
            const satVar = 0.95 + (paletteIndex % 3) * 0.05; // 0.95-1.05
            const lightVar = 0.95 + (paletteIndex % 3) * 0.05; // 0.95-1.05
            
            newHSL[0] = (newHSL[0] + hueVar + 360) % 360;
            newHSL[1] = Math.min(100, Math.max(5, newHSL[1] * satVar));
            newHSL[2] = Math.min(95, Math.max(5, newHSL[2] * lightVar));
          }
          
          // Apply shade adjustments
          if (shadeType === 'faint') {
            // For faint shades: ensure lightness is at least 65%
            newHSL[2] = Math.max(newHSL[2], 65);
          } else if (shadeType === 'dark') {
            // For dark shades: ensure lightness is at most 40%
            newHSL[2] = Math.min(newHSL[2], 40);
          }
          
          // Convert back to RGB and update the working color
          workingColors[colorIndex] = hslToRgb(...newHSL);
        });
      });
      
      // Ensure we have enough colors (at least 6)
      while (workingColors.length < 6) {
        // For additional colors, derive from existing ones while maintaining harmony
        // Choose a source color, preferably not the background
        let sourceIndex = workingColors.length % workingColors.length;
        if (sourceIndex === backgroundColorIndex) {
          sourceIndex = (sourceIndex + 1) % workingColors.length;
        }
        
        const sourceHSL = rgbToHsl(...workingColors[sourceIndex]);
        
        // Create a new color with small variations
        // But keep it in the same general harmony family
        const newHSL = [...sourceHSL];
        
        // Small hue variation that stays within the harmony
        if (harmonyScheme === 'monochromatic') {
          // For monochromatic: keep the same hue, vary saturation and lightness
          newHSL[1] = Math.min(100, Math.max(5, sourceHSL[1] + randomInRange(-15, 15)));
          newHSL[2] = Math.min(95, Math.max(5, sourceHSL[2] + randomInRange(-15, 15)));
        } else {
          // For other harmonies: small hue variation to stay in the same family
          newHSL[0] = (newHSL[0] + randomInRange(-10, 10) + 360) % 360;
          newHSL[1] = Math.min(100, Math.max(5, sourceHSL[1] + randomInRange(-10, 10)));
          newHSL[2] = Math.min(95, Math.max(5, sourceHSL[2] + randomInRange(-10, 10)));
        }
        
        // Apply shade adjustments
        if (shadeType === 'faint') {
          newHSL[2] = Math.max(newHSL[2], 65);
        } else if (shadeType === 'dark') {
          newHSL[2] = Math.min(newHSL[2], 40);
        }
        
        workingColors.push(hslToRgb(...newHSL));
      }
      
      // Add the palette info
      Object.defineProperty(workingColors, 'info', {
        value: { 
          category: shadeType,
          harmonyScheme: harmonyScheme
        },
        enumerable: false
      });
      
      basePalettes.push(workingColors);
    }
    
    return basePalettes;
    
  } catch (e) {
    console.error("Error generating base color variants:", e);
    
    // Provide fallback palettes that maintain color family correlation
    const basePalettes = [];
    const fallbackShadeType = baseColor.shadeType || 'regular';
    const fallbackHarmonyScheme = baseColor.harmonyScheme || 'normal';
    
    // Create at least 6 palettes with better color correlation
    for (let i = 0; i < 12; i++) {
      let fallbackPalette = [];
      
      // Get base color in HSL for easier manipulation
      const baseHsl = rgbToHsl(...baseColor);
      
      // Create a palette with the base color in the background position
      for (let j = 0; j < Math.max(6, distinctColors.length); j++) {
        if (j === backgroundColorIndex) {
          // Adjust the base color based on shade category, but STAY IN THE SAME COLOR FAMILY
          let adjustedHsl = [...baseHsl];
          
          if (fallbackShadeType === "faint") {
            // For faint: maintain hue, reduce saturation, increase lightness
            adjustedHsl[1] = Math.max(10, baseHsl[1] * (0.7 + (i * 0.05)));
            adjustedHsl[2] = Math.min(95, 70 + (i % 20));
          } 
          else if (fallbackShadeType === "dark") {
            // For dark: maintain hue, possibly increase saturation, decrease lightness
            adjustedHsl[1] = Math.min(100, baseHsl[1] * (1.0 + (i * 0.05)));
            adjustedHsl[2] = Math.max(5, 35 - (i % 25));
          }
          else {
            // For regular: maintain hue, make small saturation/lightness adjustments
            const variation = (i % 10) - 5; // -5 to +5
            adjustedHsl[1] = Math.min(100, Math.max(10, baseHsl[1] + variation));
            adjustedHsl[2] = Math.min(80, Math.max(30, baseHsl[2] + variation));
          }
          
          fallbackPalette.push(hslToRgb(...adjustedHsl));
        } else if (j < distinctColors.length) {
          // For other colors, preserve their relationship to the base color
          const originalColor = distinctColors[j];
          const originalHsl = rgbToHsl(...originalColor);
          
          // Calculate the color's relationship to the base color
          const hueDiff = ((originalHsl[0] - baseHsl[0] + 540) % 360) - 180; // -180 to +180
          const satRatio = originalHsl[1] / Math.max(1, baseHsl[1]);
          const lightRatio = originalHsl[2] / Math.max(1, baseHsl[2]);
          
          // New color based on harmony scheme
          let newHue = baseHsl[0];
          
          if (fallbackHarmonyScheme === 'monochromatic') {
            // Keep the same hue
            newHue = baseHsl[0];
          } else if (fallbackHarmonyScheme === 'analogous') {
            // Use analogous hues
            const analogousOffset = [-30, -15, 0, 15, 30];
            newHue = (baseHsl[0] + analogousOffset[j % analogousOffset.length] + 360) % 360;
          } else if (fallbackHarmonyScheme === 'complementary') {
            // Base and complement
            newHue = (baseHsl[0] + (j % 2 === 0 ? 0 : 180) + 360) % 360;
          } else if (fallbackHarmonyScheme === 'splitComplementary') {
            // Base, and two colors 150° and 210° from base
            if (j % 3 === 0) newHue = baseHsl[0];
            else if (j % 3 === 1) newHue = (baseHsl[0] + 150 + 360) % 360;
            else newHue = (baseHsl[0] + 210 + 360) % 360;
          } else if (fallbackHarmonyScheme === 'triadic') {
            // Three colors 120° apart
            newHue = (baseHsl[0] + (j % 3) * 120 + 360) % 360;
          } else if (fallbackHarmonyScheme === 'tetradic' || fallbackHarmonyScheme === 'square') {
            // Four colors 90° apart
            newHue = (baseHsl[0] + (j % 4) * 90 + 360) % 360;
          } else {
            // Normal - maintain relative hue relationships
            newHue = (baseHsl[0] + hueDiff + 360) % 360;
          }
          
          // Apply shade type adjustments
          let newSat = baseHsl[1] * satRatio;
          let newLight = baseHsl[2] * lightRatio;
          
          if (fallbackShadeType === "faint") {
            newLight = Math.max(newLight, 65); // Ensure it's faint
          } else if (fallbackShadeType === "dark") {
            newLight = Math.min(newLight, 40); // Ensure it's dark
          }
          
          // Keep values in valid ranges
          newSat = Math.min(100, Math.max(0, newSat));
          newLight = Math.min(100, Math.max(0, newLight));
          
          fallbackPalette.push(hslToRgb(newHue, newSat, newLight));
        } else {
          // For extra colors (if needed), create variations that follow the harmony pattern
          const baseIndex = j % distinctColors.length;
          const existingColor = fallbackPalette[baseIndex];
          const existingHsl = rgbToHsl(...existingColor);
          
          // Create a variation
          const newHsl = [...existingHsl];
          newHsl[1] = Math.min(100, Math.max(5, existingHsl[1] + randomInRange(-10, 10)));
          newHsl[2] = Math.min(95, Math.max(5, existingHsl[2] + randomInRange(-10, 10)));
          
          fallbackPalette.push(hslToRgb(...newHsl));
        }
      }
      
      // Add the palette info
      Object.defineProperty(fallbackPalette, 'info', {
        value: { 
          category: fallbackShadeType,
          harmonyScheme: fallbackHarmonyScheme
        },
        enumerable: false
      });
      
      basePalettes.push(fallbackPalette);
    }
    
    return basePalettes;
  }
}


async function selectBaseColor(color) {
  try {
    // Invalidate the cache when a new base color is selected
    if (window.palettePreviewCache && window.palettePreviewCache['base']) {
      // Clear all cached previews for base palettes
      window.palettePreviewCache['base'] = {};
    }
    
    // Remove any existing filter container
    const filterContainer = document.querySelector('.base-color-filters');
    if (filterContainer) {
      filterContainer.remove();
    }
    
    // Get color name
    const colorName = getColorName(color);
    
    // RGB to HEX conversion function
    function rgbToHex(r, g, b) {
      return '#' + [r, g, b].map(x => {
        const hex = x.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      }).join('');
    }
    
    // Check for ML label in the layers
    let mlLabel = null;
    const layerElement = document.querySelector('.layer[data-ml-label]');
    if (layerElement) {
      mlLabel = parseInt(layerElement.dataset.mlLabel, 10);
      console.log("Found ML label:", mlLabel);
    }
    
    // Process based on ML label
    if (mlLabel !== null) {
      if (mlLabel === 1) {
        // ML label 1: Image doesn't support base color selection
        alert("This image doesn't support base color selection based on our analysis. The image structure may be too complex for effective color mapping.");
        // Reset the view and return early
        resetBaseColorView();
        return;
      } 
      else if (mlLabel === 2) {
        // ML label 2: Image has complicated colors, warn user
        const shouldContinue = confirm("This image has a complicated color structure. Base color selection may produce unexpected results. Would you like to proceed anyway?");
        
        if (!shouldContinue) {
          resetBaseColorView();
          return; // User chose not to continue
        }
        // Otherwise continue with normal flow...
      }
      // For label 0, proceed normally without any warnings
    }
    
    // FIRST: Ensure window.originalColors is set from distinctColorsArrayColorPallet
    if (!window.originalColors || !Array.isArray(window.originalColors) || window.originalColors.length === 0) {
      // Try to get colors from window variable
      if (window.distinctColorsArrayColorPallet && 
          Array.isArray(window.distinctColorsArrayColorPallet) && 
          window.distinctColorsArrayColorPallet.length > 0) {
        
        window.originalColors = [...window.distinctColorsArrayColorPallet];
        console.log("Set window.originalColors from window.distinctColorsArrayColorPallet:", window.originalColors);
      }
      // Or try localStorage if window variable isn't available
      else if (localStorage.getItem('distinctColorsArrayColorPallet')) {
        try {
          const colorsString = localStorage.getItem('distinctColorsArrayColorPallet');
          const parsedColors = JSON.parse(colorsString);
          
          if (Array.isArray(parsedColors) && parsedColors.length > 0) {
            window.originalColors = parsedColors;
            console.log("Set window.originalColors from localStorage:", window.originalColors);
          }
        } catch (e) {
          console.error("Error parsing distinctColorsArrayColorPallet from localStorage:", e);
        }
      }
      
      // Make sure the colors are valid RGB arrays
      if (window.originalColors) {
        window.originalColors = window.originalColors.filter(color => 
          Array.isArray(color) && 
          color.length === 3 && 
          color.every(component => typeof component === 'number' && !isNaN(component))
        );
      }
    }

    // Determine which color should be the background color
    let backgroundColorIndex = null; 
    
    // If we have original colors from an image, ask if user wants to select background
    if (window.originalColors && Array.isArray(window.originalColors) && window.originalColors.length > 0) {
      // Create a simple confirmation dialog
      const wantsToSelectBG = await new Promise(resolve => {
        // Create confirmation modal
        const confirmModal = document.createElement('div');
        confirmModal.className = 'bg-select-confirm-overlay';
        confirmModal.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0,0,0,0.7);
          display: flex;
          justify-content: center;
          align-items: center;
          z-index: 9999;
        `;
        
        const confirmContent = document.createElement('div');
        confirmContent.className = 'bg-select-confirm-content';
        confirmContent.style.cssText = `
          background-color: white;
          border-radius: 8px;
          padding: 20px;
          max-width: 90%;
          width: 400px;
          box-shadow: 0 4px 6px rgba(0,0,0,0.3);
          text-align: center;
        `;
        
        const confirmTitle = document.createElement('h4');
        confirmTitle.textContent = 'Background Color Selection';
        confirmTitle.style.marginBottom = '15px';
        
        const confirmText = document.createElement('p');
        confirmText.textContent = 'Would you like to choose which color from your image should be treated as the background color?';
        
        const buttonContainer = document.createElement('div');
        buttonContainer.style.cssText = `
          display: flex;
          justify-content: center;
          gap: 15px;
          margin-top: 20px;
        `;
        
        const yesButton = document.createElement('button');
        yesButton.textContent = 'Yes, select background';
        yesButton.style.cssText = `
          padding: 8px 16px;
          background-color: #007bff;
          color: white;
          border: none;
          border-radius: 4px;
          cursor: pointer;
        `;
        
        const noButton = document.createElement('button');
        noButton.textContent = 'No, use default';
        noButton.style.cssText = `
          padding: 8px 16px;
          border: 1px solid #ddd;
          background-color: white;
          border-radius: 4px;
          cursor: pointer;
        `;
        
        yesButton.addEventListener('click', () => {
          document.body.removeChild(confirmModal);
          resolve(true);
        });
        
        noButton.addEventListener('click', () => {
          document.body.removeChild(confirmModal);
          resolve(false);
        });
        
        buttonContainer.appendChild(noButton);
        buttonContainer.appendChild(yesButton);
        
        confirmContent.appendChild(confirmTitle);
        confirmContent.appendChild(confirmText);
        confirmContent.appendChild(buttonContainer);
        confirmModal.appendChild(confirmContent);
        
        document.body.appendChild(confirmModal);
      });

      console.log("Original colors available:", window.originalColors);
      console.log("Is array?", Array.isArray(window.originalColors));
      console.log("Length:", window.originalColors ? window.originalColors.length : 0);
      
      // If user wants to select background color, show the selector
      if (wantsToSelectBG) {
        console.log("Showing background color selector...");
        backgroundColorIndex = await showBackgroundColorSelector(color, window.originalColors);
        console.log(`User selected background color index: ${backgroundColorIndex}`);
      } else {
        // User didn't want to select, so find the best matching color as background
        // We'll look for the brightest color or closest to white as default background
        let maxBrightness = -1;
        window.originalColors.forEach((c, idx) => {
          // Simple brightness formula: (R+G+B)/3
          const brightness = (c[0] + c[1] + c[2]) / 3;
          if (brightness > maxBrightness) {
            maxBrightness = brightness;
            backgroundColorIndex = idx;
          }
        });
        console.log(`Using brightest color as background (index: ${backgroundColorIndex})`);
      }
    } else {
      console.log("No original colors available, using null for background index");
    }
    
    // Now that we have the background color index, proceed with UI updates
    
    // Hide the base colors grid
    const baseColorsGrid = document.querySelector('.base-colors-grid');
    baseColorsGrid.style.display = 'none';

    // Show the palettes section
    const basePalettesSection = document.querySelector('.base-palettes-section');
    if (basePalettesSection) {
      basePalettesSection.style.display = 'block';
    } else {
      console.error("Could not find .base-palettes-section element");
      return;
    }

    // Change the header text to indicate selected color
    const headerElement = document.querySelector('#baseColorContent h4');
    if (headerElement) {
      const hexColor = rgbToHex(color[0], color[1], color[2]);
      headerElement.textContent = `Palettes with ${colorName} (${hexColor})`;
    }

    // Add a back button next to the header if it doesn't exist
    if (!document.querySelector('.back-to-base-colors')) {
      const backButton = document.createElement('button');
      backButton.className = 'btn btn-sm btn-outline-secondary back-to-base-colors ms-2';
      backButton.innerHTML = '<i class="bi bi-arrow-left"></i> Back to Colors';
      backButton.onclick = resetBaseColorView;

      if (headerElement && headerElement.parentElement) {
        headerElement.parentElement.insertBefore(backButton, headerElement.nextSibling);
      }
    }

    // Store the selected base color
    window.selectedBaseColor = color;
    window.selectedBackgroundColorIndex = backgroundColorIndex;
    
    // Initialize palette storage
    window.basePaletteColors = {};
    window.basePaletteColors.shadeCategories = {};
    window.basePaletteColors.harmonySchemes = {};
    
    // Define harmony schemes
    const harmonySchemes = [
      'normal', 'monochromatic', 'analogous', 'complementary', 
      'splitComplementary', 'triadic', 'tetradic', 'square'
    ];
    
    // Define shade types
    const shadeTypes = ['faint', 'regular', 'dark'];
    
    // Generate palettes for each combination of harmony scheme and shade type
    let paletteIndex = 0;
    
    for (const harmonyScheme of harmonySchemes) {
      for (const shadeType of shadeTypes) {
        // Add harmony and shade info to the color object
        const colorWithInfo = [...color];
        colorWithInfo.harmonyScheme = harmonyScheme;
        colorWithInfo.shadeType = shadeType;
        
        // Generate 12 palettes for this combination
        const palettes = generateBaseColorPalettes(colorWithInfo, backgroundColorIndex);
        
        // Store generated palettes
        for (let i = 0; i < palettes.length; i++) {
          // Store the palette colors
          window.basePaletteColors[paletteIndex] = [...palettes[i]];
          
          // Store the category information
          window.basePaletteColors.shadeCategories[paletteIndex] = shadeType;
          window.basePaletteColors.harmonySchemes[paletteIndex] = harmonyScheme;
          
          paletteIndex++;
        }
      }
    }

    // Store in localStorage for persistence
    try {
      localStorage.setItem('basePaletteColors', JSON.stringify(window.basePaletteColors));
    } catch (e) {
      console.warn("Could not store basePaletteColors in localStorage:", e);
    }

    // Initialize preview cache if needed
    if (!window.palettePreviewCache) {
      window.palettePreviewCache = {};
    }
    if (!window.palettePreviewCache['base']) {
      window.palettePreviewCache['base'] = {};
    }

    // Create preview canvases if they don't exist
    if (!window.previewCanvases) {
      window.previewCanvases = {};
      
      // Generate a smaller version of the original image for preview
      const originalCanvas = document.getElementById('layer_canvas_1');
      if (originalCanvas) {
        const previewCanvas = document.createElement('canvas');
        previewCanvas.width = 200;
        previewCanvas.height = 200;
        const previewCtx = previewCanvas.getContext('2d', { willReadFrequently: true });
        
        // Draw the original image scaled down
        previewCtx.drawImage(originalCanvas, 0, 0, 200, 200);
        
        // Store the preview canvas data URL for future use
        window.previewCanvases['original'] = previewCanvas.toDataURL();
      }
    }
    
    // Create the filters with dropdowns
    createBaseColorDropdownFilters(color);
    
    // Function to prepare display colors
    function prepareDisplayColors(colors) {
      try {
        // Make sure all colors are valid
        const validColors = colors.filter(color =>
          Array.isArray(color) &&
          color.length === 3 &&
          color.every(val => typeof val === 'number' && !isNaN(val))
        );

        // If no valid colors, return a basic palette
        if (validColors.length === 0) {
          console.warn("No valid colors for display, using basic palette");
          return [
            [...color], // Use selected color as first
            [0, 255, 0], [0, 0, 255],
            [255, 255, 0], [255, 0, 255], [0, 255, 255]
          ];
        }

        // Always preserve the first color (selected color)
        let displayColors = [validColors[0]];

        const FIXED_DISPLAY_COUNT = 6; // Fixed number for display consistency

        // If we have more than FIXED_DISPLAY_COUNT colors, use a subset for display
        if (validColors.length > FIXED_DISPLAY_COUNT) {
          // Select remaining display colors evenly distributed to maintain sequence
          const step = (validColors.length - 1) / (FIXED_DISPLAY_COUNT - 1);
          for (let i = 1; i < FIXED_DISPLAY_COUNT; i++) {
            const idx = Math.min(Math.floor(1 + (i - 1) * step), validColors.length - 1);
            displayColors.push(validColors[idx]);
          }
        } else if (validColors.length < FIXED_DISPLAY_COUNT) {
          // Add remaining colors
          for (let i = 1; i < validColors.length; i++) {
            displayColors.push(validColors[i]);
          }

          // If still not enough, duplicate some colors to reach FIXED_DISPLAY_COUNT
          while (displayColors.length < FIXED_DISPLAY_COUNT) {
            const idx = displayColors.length % validColors.length;
            displayColors.push([...validColors[idx]]);
          }
        } else {
          // We have exactly FIXED_DISPLAY_COUNT colors
          displayColors = [...validColors];
        }

        return displayColors;
      } catch (e) {
        console.error("Error preparing display colors:", e);
        // Return a fallback set of colors
        return [
          [...color], // Use selected color as first
          [0, 255, 0], [0, 0, 255],
          [255, 255, 0], [255, 0, 255], [0, 255, 255]
        ];
      }
    }

    // Function to display a modal with all colors in the palette
    function showFullPaletteModal(palette, collection, paletteIndex) {
      // Create and append modal elements if they don't exist
      let modal = document.getElementById('full-palette-modal');

      if (!modal) {
        modal = document.createElement('div');
        modal.id = 'full-palette-modal';
        modal.classList.add('full-palette-modal');

        const modalContent = document.createElement('div');
        modalContent.classList.add('full-palette-modal-content');

        const closeBtn = document.createElement('span');
        closeBtn.classList.add('close-palette-modal');
        closeBtn.innerHTML = '&times;';

        const modalTitle = document.createElement('h3');
        modalTitle.classList.add('palette-modal-title');

        const colorsContainer = document.createElement('div');
        colorsContainer.classList.add('all-colors-container');

        modalContent.appendChild(closeBtn);
        modalContent.appendChild(modalTitle);
        modalContent.appendChild(colorsContainer);
        modal.appendChild(modalContent);

        document.body.appendChild(modal);

        // Add event listener to close button
        closeBtn.addEventListener('click', function() {
          modal.style.display = 'none';
        });

        // Close modal when clicking outside content
        window.addEventListener('click', function(event) {
          if (event.target === modal) {
            modal.style.display = 'none';
          }
        });
      }

      // Update modal content with current palette
      const modalTitle = modal.querySelector('.palette-modal-title');
      const colorsContainer = modal.querySelector('.all-colors-container');

      // Get palette category and harmony if available
      let category = "Regular";
      let harmony = "Normal";
      
      if (window.basePaletteColors) {
        if (window.basePaletteColors.shadeCategories && 
            window.basePaletteColors.shadeCategories[paletteIndex]) {
          category = window.basePaletteColors.shadeCategories[paletteIndex].charAt(0).toUpperCase() 
                  + window.basePaletteColors.shadeCategories[paletteIndex].slice(1);
        }
        
        if (window.basePaletteColors.harmonySchemes && 
            window.basePaletteColors.harmonySchemes[paletteIndex]) {
          // Format harmony scheme for display (e.g., "splitComplementary" -> "Split Complementary")
          const harmonyRaw = window.basePaletteColors.harmonySchemes[paletteIndex];
          harmony = harmonyRaw.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
          if (harmony === "Normal") harmony = "Standard";
        }
      }

      modalTitle.textContent = `Full Palette (${collection.toUpperCase()} #${paletteIndex+1} - ${category}, ${harmony})`;
      colorsContainer.innerHTML = '';

      // Add all colors to the modal
      palette.forEach((color, index) => {
        const colorBox = document.createElement('div');
        colorBox.classList.add('full-palette-color');
        colorBox.style.backgroundColor = `rgb(${color.join(',')})`;

        // Convert RGB to HEX for display
        const hexColor = rgbToHex(color[0], color[1], color[2]);

        // Add color information - using HEX code only
        const colorInfo = document.createElement('div');
        colorInfo.classList.add('color-info');
        colorInfo.textContent = `Color ${index+1}: ${hexColor}`;

        // Add tooltip with HEX code only
        colorBox.title = hexColor;

        colorBox.appendChild(colorInfo);
        colorsContainer.appendChild(colorBox);
      });

      // Show the modal
      modal.style.display = 'block';
    }
    
    // Function to generate a preview of the palette applied to the image
    async function generatePreview(previewCanvas, paletteColors, paletteIndex) {
      try {
        // Mark the container as not ready (ensure loading indicator shows)
        const container = previewCanvas.closest('.palette-clickable-container');
        if (container) {
          container.classList.remove('preview-ready');
        }
        
        // Check cache first - expanded cache check
        if (window.palettePreviewCache && 
            window.palettePreviewCache['base'] && 
            window.palettePreviewCache['base'][paletteIndex]) {
            
            // Use cached preview
            const cachedPreview = window.palettePreviewCache['base'][paletteIndex];
            const ctx = previewCanvas.getContext('2d', { willReadFrequently: true });
            
            // Clear with white background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
            
            return new Promise((resolve) => {
              const img = new Image();
              img.onload = () => {
                // Calculate proportional dimensions to maintain aspect ratio
                const scale = Math.min(
                    previewCanvas.width / img.width,
                    previewCanvas.height / img.height
                );
                
                const scaledWidth = img.width * scale;
                const scaledHeight = img.height * scale;
                
                // Center the image
                const x = (previewCanvas.width - scaledWidth) / 2;
                const y = (previewCanvas.height - scaledHeight) / 2;
                
                // Draw the image with proper aspect ratio
                ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
                
                // Mark preview as ready to hide the loading indicator
                if (container) {
                  container.classList.add('preview-ready');
                }
                resolve();
              };
              img.onerror = () => {
                // Draw fallback and mark as ready
                drawFallbackPreview(previewCanvas);
                if (container) {
                  container.classList.add('preview-ready');
                }
                resolve();
              };
              img.src = cachedPreview;
            });
        }
            
            // No cache, create new preview
            // Get the original image
            const originalCanvas = document.getElementById('layer_canvas_1');
            
            if (!originalCanvas) {
              console.error('No original canvas found for preview');
              drawFallbackPreview(previewCanvas);
              if (container) {
                container.classList.add('preview-ready');
              }
              return;
            }
            
            // Clear the preview canvas with white background
            const ctx = previewCanvas.getContext('2d', { willReadFrequently: true });
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
            
            // Calculate dimensions that maintain aspect ratio
            const originalAspect = originalCanvas.width / originalCanvas.height;
            let previewWidth, previewHeight, offsetX = 0, offsetY = 0;
            
            if (originalAspect > 1) {
              // Image is wider than tall
              previewWidth = previewCanvas.width;
              previewHeight = previewWidth / originalAspect;
              offsetY = (previewCanvas.height - previewHeight) / 2;
            } else {
              // Image is taller than wide
              previewHeight = previewCanvas.height;
              previewWidth = previewHeight * originalAspect;
              offsetX = (previewCanvas.width - previewWidth) / 2;
            }
            
            // Create a temporary canvas for the original image at preview size
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = previewWidth;
            tempCanvas.height = previewHeight;
            const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
            
            // Draw original image to temp canvas maintaining aspect ratio
            tempCtx.drawImage(originalCanvas, 0, 0, previewWidth, previewHeight);
            
            // Now get the temp canvas data for processing
            const imageData = tempCtx.getImageData(0, 0, previewWidth, previewHeight);
            
            // Find original colors from the image
            const originalColors = await getDistinctColors(imageData, 30, 50);
            
            if (!originalColors || originalColors.length === 0) {
              console.error('No original colors found for preview');
              // Still draw the original image with correct aspect ratio
              ctx.drawImage(tempCanvas, offsetX, offsetY);
              
              // Mark preview as ready
              if (container) {
                container.classList.add('preview-ready');
              }
              return;
            }
            
            // Create color mappings
            const colorMappings = [];
            
            // Special handling for background color
            if (backgroundColorIndex !== null && 
                backgroundColorIndex >= 0 && 
                backgroundColorIndex < originalColors.length) {
                
                // Map colors with special consideration for the background color
                for (let i = 0; i < originalColors.length; i++) {
                    if (i === backgroundColorIndex) {
                        // For the background color index, map to the selected base color (first in palette)
                        colorMappings.push({
                            originalColor: originalColors[i],
                            targetColor: paletteColors[0]
                        });
                    } else {
                        // For other colors, map to rest of palette
                        const targetIndex = (i < backgroundColorIndex) ? i + 1 : i;
                        const paletteIndex = targetIndex % paletteColors.length;
                        
                        colorMappings.push({
                            originalColor: originalColors[i],
                            targetColor: paletteColors[paletteIndex]
                        });
                    }
                }
            } else {
                // Regular mapping if no background color is specified
                for (let i = 0; i < Math.min(originalColors.length, paletteColors.length); i++) {
                    colorMappings.push({
                        originalColor: originalColors[i],
                        targetColor: paletteColors[i % paletteColors.length]
                    });
                }
            }
            
            // Use a simplified processor for the preview
            const colorProcessor = new ColorProcessor();
            const imageUrl = tempCanvas.toDataURL();
            
            // Process the preview
            const processedImageUrl = await colorProcessor.applyMultipleColorMappings(
                imageUrl,
                colorMappings
            );
            
            // Load the processed image back to the preview canvas
            return new Promise((resolve) => {
              const resultImg = new Image();
              resultImg.onload = () => {
                // Draw the processed image with the correct positioning
                ctx.drawImage(resultImg, offsetX, offsetY, previewWidth, previewHeight);
                
                // Cache the generated preview
                if (!window.palettePreviewCache) {
                    window.palettePreviewCache = {};
                }
                if (!window.palettePreviewCache['base']) {
                    window.palettePreviewCache['base'] = {};
                }
                window.palettePreviewCache['base'][paletteIndex] = previewCanvas.toDataURL();
                
                // Mark preview as ready to hide loading indicator
                if (container) {
                  container.classList.add('preview-ready');
                }
                resolve();
              };
              resultImg.onerror = () => {
                console.error("Error loading processed preview");
                drawFallbackPreview(previewCanvas);
                if (container) {
                  container.classList.add('preview-ready');
                }
                resolve();
              };
              resultImg.src = processedImageUrl;
            });
            
          } catch (error) {
            console.error("Error generating preview:", error);
            drawFallbackPreview(previewCanvas);
            const container = previewCanvas.closest('.palette-clickable-container');
            if (container) {
              container.classList.add('preview-ready');
            }
          }
        }

    // Helper function to draw fallback preview
    function drawFallbackPreview(canvas) {
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#f5f5f5';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#999';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = '14px sans-serif';
      ctx.fillText('Preview unavailable', canvas.width/2, canvas.height/2);
    }

    // Create or update palette containers - we need to ensure we have enough containers
    const palettesContainer = document.querySelector('.base-palettes-container');
    if (palettesContainer) {
      // Clear existing containers
      palettesContainer.innerHTML = '';

      // Calculate total palettes (all combinations of harmonies × shades × 12 palettes each)
      const TOTAL_PALETTES = harmonySchemes.length * shadeTypes.length * 12;
      
      // Create containers for all our palettes
      for (let i = 0; i < TOTAL_PALETTES; i++) {
        const paletteRow = document.createElement('div');
        paletteRow.className = 'row mb-4 palette-row';
        
        // Add data attributes for shade category and harmony scheme if available
        if (window.basePaletteColors) {
          if (window.basePaletteColors.shadeCategories && 
              window.basePaletteColors.shadeCategories[i]) {
            paletteRow.dataset.shadeCategory = window.basePaletteColors.shadeCategories[i];
          }
          
          if (window.basePaletteColors.harmonySchemes && 
              window.basePaletteColors.harmonySchemes[i]) {
            paletteRow.dataset.harmonyScheme = window.basePaletteColors.harmonySchemes[i];
          }
        }
        
        const paletteCol = document.createElement('div');
        paletteCol.className = 'col-12';
        paletteRow.appendChild(paletteCol);
        
        const paletteCard = document.createElement('div');
        paletteCard.className = 'card shadow-sm h-100';
        paletteCol.appendChild(paletteCard);
        
        const cardBody = document.createElement('div');
        cardBody.className = 'card-body';
        paletteCard.appendChild(cardBody);
        
        const paletteContainer = document.createElement('div');
        paletteContainer.id = `base_colorPalette_${i}`;
        paletteContainer.className = 'color-palette-container';
        cardBody.appendChild(paletteContainer);
        
        const paletteNumber = document.createElement('div');
        paletteNumber.className = 'palette-number';
        paletteNumber.textContent = `${i + 1}`;
        cardBody.appendChild(paletteNumber);
        
        const buttonsContainer = document.createElement('div');
        buttonsContainer.className = 'btn-group w-100 mt-2';
        buttonsContainer.setAttribute('role', 'group');
        cardBody.appendChild(buttonsContainer);
        
        const shuffleButton = document.createElement('button');
        shuffleButton.id = `base_shufflePalette_${i}`;
        shuffleButton.className = 'btn btn-outline-secondary btn-sm';
        shuffleButton.innerHTML = '<i class="bi bi-shuffle"></i> Shuffle';
        shuffleButton.type = 'button';
        buttonsContainer.appendChild(shuffleButton);
        
        const applyButton = document.createElement('button');
        applyButton.id = `base_applyButton_${i}`;
        applyButton.className = 'btn btn-primary btn-sm';
        applyButton.innerHTML = '<i class="bi bi-check2-circle"></i> Apply';
        applyButton.type = 'button';
        buttonsContainer.appendChild(applyButton);
        
        palettesContainer.appendChild(paletteRow);
      }
    }

    // Display the generated palettes with previews
    for (let i = 0; i < Object.keys(window.basePaletteColors).length; i++) {
      if (i === 'shadeCategories' || i === 'harmonySchemes') continue;
      
      const paletteContainer = document.getElementById(`base_colorPalette_${i}`);
      if (!paletteContainer) continue;

      paletteContainer.innerHTML = '';

      // Get the generated palette
      const paletteColors = window.basePaletteColors[i];
      if (!paletteColors) continue;

      // Create container for the palette that will be clickable as a whole
      const clickableContainer = document.createElement('div');
      clickableContainer.classList.add('palette-clickable-container');
      paletteContainer.appendChild(clickableContainer);

      // Add data attribute to store the palette index
      clickableContainer.dataset.paletteIndex = i;
      clickableContainer.dataset.collection = 'base';
      
      // Get and store shade category and harmony scheme
      let shadeCategory = 'regular';
      let harmonyScheme = 'normal';
      
      if (window.basePaletteColors.shadeCategories && window.basePaletteColors.shadeCategories[i]) {
        shadeCategory = window.basePaletteColors.shadeCategories[i];
        clickableContainer.dataset.shadeCategory = shadeCategory;
      }
      
      if (window.basePaletteColors.harmonySchemes && window.basePaletteColors.harmonySchemes[i]) {
        harmonyScheme = window.basePaletteColors.harmonySchemes[i];
        clickableContainer.dataset.harmonyScheme = harmonyScheme;
      }
      
      // Add shade tag - visual indicator of palette type
      const shadeTags = document.createElement('div');
      shadeTags.className = 'scheme-tags';
      
      // Add shade tag
      const shadeTag = document.createElement('span');
      shadeTag.className = 'shade-tag';
      shadeTag.textContent = shadeCategory.charAt(0).toUpperCase() + shadeCategory.slice(1);
      shadeTags.appendChild(shadeTag);
      
      // Add harmony tag
      const harmonyTag = document.createElement('span');
      harmonyTag.className = 'harmony-tag';
      
      // Format harmony scheme for display
      let harmonyDisplay = harmonyScheme;
      if (harmonyScheme === 'splitComplementary') {
        harmonyDisplay = 'Split Comp.';
      } else if (harmonyScheme === 'monochromatic') {
        harmonyDisplay = 'Monochrome';
      } else if (harmonyScheme === 'complementary') {
        harmonyDisplay = 'Complement';
      } else if (harmonyScheme === 'analogous') {
        harmonyDisplay = 'Analogous';
      } else if (harmonyScheme === 'triadic') {
        harmonyDisplay = 'Triadic';
      } else if (harmonyScheme === 'tetradic') {
        harmonyDisplay = 'Tetradic';
      } else if (harmonyScheme === 'square') {
        harmonyDisplay = 'Square';
      } else if (harmonyScheme === 'normal') {
        harmonyDisplay = 'Standard';
      }
      
      harmonyTag.textContent = harmonyDisplay;
      shadeTags.appendChild(harmonyTag);
      
      clickableContainer.appendChild(shadeTags);
      
      // NEW: Add preview image container
      const previewContainer = document.createElement('div');
      previewContainer.classList.add('palette-preview-container');
      clickableContainer.appendChild(previewContainer);
      
      // Create small preview canvas
      const previewCanvas = document.createElement('canvas');
      previewCanvas.width = 200;
      previewCanvas.height = 200;
      previewCanvas.classList.add('palette-preview-canvas');
      previewContainer.appendChild(previewCanvas);
      
      // Generate the preview using the full palette
      generatePreview(previewCanvas, paletteColors, i);

      // Add click handler to use the FULL palette when clicked
      clickableContainer.addEventListener('click', function() {
        try {
          const paletteIndex = parseInt(this.dataset.paletteIndex, 10);

          console.log(`Palette clicked: base[${paletteIndex}]`);

          // Call processPallet with 'base' collection and paletteIndex
          if (typeof window.processPallet === 'function') {
            const fullPalette = window.basePaletteColors[paletteIndex];
            if (fullPalette && fullPalette.length > 0) {
              window.processPallet(null, 1, null, 0, null, fullPalette, 'base', paletteIndex);
            } else {
              console.error(`No full palette found in basePaletteColors[${paletteIndex}]`);
            }
          }
        } catch (e) {
          console.error("Error in palette click handler:", e);
        }
      });
      
      // NEW: Display the representative colors underneath the preview
      const swatchContainer = document.createElement('div');
      swatchContainer.classList.add('swatch-container');
      clickableContainer.appendChild(swatchContainer);

      // Prepare display colors - consistent count for all palettes
      const displayColors = prepareDisplayColors(paletteColors);

      // Display color swatches
      displayColors.forEach((color, idx) => {
        const swatch = document.createElement('div');
        swatch.classList.add('color-swatch');
        swatch.style.backgroundColor = `rgb(${color.join(',')})`;

        // Convert RGB to HEX for tooltip
        const hexColor = rgbToHex(color[0], color[1], color[2]);

        // Just show the HEX value in the tooltip
        swatch.title = hexColor;

        // Add special class for base swatches if needed
        swatch.classList.add('base-swatch');

        swatchContainer.appendChild(swatch);
      });

      // Add "Show All" button
      const showAllButton = document.createElement('div');
      showAllButton.classList.add('show-all-colors-btn');
      showAllButton.innerHTML = '+';
      showAllButton.title = 'Show all colors in palette';
      clickableContainer.appendChild(showAllButton);

      // Add event listener to show all colors in a modal
      showAllButton.addEventListener('click', function(e) {
        e.stopPropagation(); // Prevent triggering the parent container's click

        const fullPalette = window.basePaletteColors[i];
        if (!fullPalette || fullPalette.length === 0) {
          console.error('No full palette found to display');
          return;
        }

        showFullPaletteModal(fullPalette, 'base', i);
      });
    }

    // Add event listeners for shuffle buttons
    document.querySelectorAll('[id^="base_shufflePalette_"]').forEach(button => {
      const paletteIndex = parseInt(button.id.split('_').pop(), 10);

      // Remove existing click listeners
      const newButton = button.cloneNode(true);
      button.parentNode.replaceChild(newButton, button);

      newButton.addEventListener('click', async function(e) {
        e.stopPropagation(); // Prevent triggering palette selection

        try {
          // Get current shade category and harmony scheme for this palette
          let shadeCategory = 'regular';
          let harmonyScheme = 'normal';
          
          if (window.basePaletteColors && window.basePaletteColors.shadeCategories &&
              window.basePaletteColors.shadeCategories[paletteIndex]) {
            shadeCategory = window.basePaletteColors.shadeCategories[paletteIndex];
          }
          
          if (window.basePaletteColors && window.basePaletteColors.harmonySchemes &&
              window.basePaletteColors.harmonySchemes[paletteIndex]) {
            harmonyScheme = window.basePaletteColors.harmonySchemes[paletteIndex];
          }
          
          // Add harmony and shade info to the color object
          const colorWithInfo = [...color];
          colorWithInfo.harmonyScheme = harmonyScheme;
          colorWithInfo.shadeType = shadeCategory;
          
          // Generate a new shuffled palette that maintains the shade and harmony types
          const newPalette = generateBaseColorPalettes(colorWithInfo, backgroundColorIndex)[0];

          // Store the new palette
          window.basePaletteColors[paletteIndex] = [...newPalette];
          
          // Update shade category and harmony scheme
          if (!window.basePaletteColors.shadeCategories) {
            window.basePaletteColors.shadeCategories = {};
          }
          window.basePaletteColors.shadeCategories[paletteIndex] = shadeCategory;
          
          if (!window.basePaletteColors.harmonySchemes) {
            window.basePaletteColors.harmonySchemes = {};
          }
          window.basePaletteColors.harmonySchemes[paletteIndex] = harmonyScheme;

          // Update localStorage
          try {
            localStorage.setItem('basePaletteColors', JSON.stringify(window.basePaletteColors));
          } catch (e) {
            console.warn("Could not update basePaletteColors in localStorage:", e);
          }

          // Update the display
          const paletteContainer = document.getElementById(`base_colorPalette_${paletteIndex}`);
          if (!paletteContainer) return;

          paletteContainer.innerHTML = '';

          // Create clickable container
          const clickableContainer = document.createElement('div');
          clickableContainer.classList.add('palette-clickable-container');
          paletteContainer.appendChild(clickableContainer);

          // Store data
          clickableContainer.dataset.paletteIndex = paletteIndex;
          clickableContainer.dataset.collection = 'base';
          clickableContainer.dataset.shadeCategory = shadeCategory;
          clickableContainer.dataset.harmonyScheme = harmonyScheme;
          
          // Add scheme tags
          const shadeTags = document.createElement('div');
          shadeTags.className = 'scheme-tags';
          
          // Add shade tag
          const shadeTag = document.createElement('span');
          shadeTag.className = 'shade-tag';
          shadeTag.textContent = shadeCategory.charAt(0).toUpperCase() + shadeCategory.slice(1);
          shadeTags.appendChild(shadeTag);
          
          // Add harmony tag
          const harmonyTag = document.createElement('span');
          harmonyTag.className = 'harmony-tag';
          
          // Format harmony scheme for display
          let harmonyDisplay = harmonyScheme;
          if (harmonyScheme === 'splitComplementary') {
            harmonyDisplay = 'Split Comp.';
          } else if (harmonyScheme === 'monochromatic') {
            harmonyDisplay = 'Monochrome';
          } else if (harmonyScheme === 'complementary') {
            harmonyDisplay = 'Complement';
          } else if (harmonyScheme === 'analogous') {
            harmonyDisplay = 'Analogous';
          } else if (harmonyScheme === 'triadic') {
            harmonyDisplay = 'Triadic';
          } else if (harmonyScheme === 'tetradic') {
            harmonyDisplay = 'Tetradic';
          } else if (harmonyScheme === 'square') {
            harmonyDisplay = 'Square';
          } else if (harmonyScheme === 'normal') {
            harmonyDisplay = 'Standard';
          }
          
          harmonyTag.textContent = harmonyDisplay;
          shadeTags.appendChild(harmonyTag);
          
          clickableContainer.appendChild(shadeTags);
          
          // NEW: Add preview image container
          const previewContainer = document.createElement('div');
          previewContainer.classList.add('palette-preview-container');
          clickableContainer.appendChild(previewContainer);
          
          // Create small preview canvas
          const previewCanvas = document.createElement('canvas');
          previewCanvas.width = 200;
          previewCanvas.height = 200;
          previewCanvas.classList.add('palette-preview-canvas');
          previewContainer.appendChild(previewCanvas);
          
          // Generate the preview using the new palette
          await generatePreview(previewCanvas, newPalette, paletteIndex);
          
          // NEW: Add swatch container
          const swatchContainer = document.createElement('div');
          swatchContainer.classList.add('swatch-container');
          clickableContainer.appendChild(swatchContainer);

          // Add click handler
          clickableContainer.addEventListener('click', function() {
            try {
              const paletteIndex = parseInt(this.dataset.paletteIndex, 10);
              
              console.log(`Palette clicked: base[${paletteIndex}]`);
              
              // Get the FULL palette from storage
              const fullPalette = window.basePaletteColors[paletteIndex];
              
              if (!fullPalette || fullPalette.length === 0) {
                console.error(`No palette found for base[${paletteIndex}]`);
                return;
              }
              
              // Call processPallet with the FULL palette
              if (typeof window.processPallet === 'function') {
                window.processPallet(null, 1, null, 0, null, fullPalette, 'base', paletteIndex);
              }
            } catch (e) {
              console.error("Error in palette click handler:", e);
            }
          });
          
          // Prepare display colors
          const displayColors = prepareDisplayColors(newPalette);
          
          // Add color swatches
          displayColors.forEach((color, idx) => {
            const swatch = document.createElement('div');
            swatch.classList.add('color-swatch');
            swatch.style.backgroundColor = `rgb(${color.join(',')})`;

            // Convert RGB to HEX for tooltip
            const hexColor = rgbToHex(color[0], color[1], color[2]);

            // Just show the HEX value in tooltip
            swatch.title = hexColor;

            swatch.classList.add('base-swatch');
            swatchContainer.appendChild(swatch);
          });

          // Add "Show All" button
          const showAllButton = document.createElement('div');
          showAllButton.classList.add('show-all-colors-btn');
          showAllButton.innerHTML = '+';
          showAllButton.title = 'Show all colors in palette';
          clickableContainer.appendChild(showAllButton);

          showAllButton.addEventListener('click', function(e) {
            e.stopPropagation();
            showFullPaletteModal(window.basePaletteColors[paletteIndex], 'base', paletteIndex);
          });

        } catch (e) {
          console.error("Error in shuffle button handler:", e);
        }
      });
    });

    // Add event listeners for apply buttons
    document.querySelectorAll('[id^="base_applyButton_"]').forEach(button => {
      const paletteIndex = parseInt(button.id.split('_').pop(), 10);

      // Remove existing click listeners
      const newButton = button.cloneNode(true);
      button.parentNode.replaceChild(newButton, button);

      newButton.addEventListener('click', function(e) {
        e.stopPropagation(); // Prevent triggering palette selection

        try {
          // Get the full palette array
          const fullPalette = window.basePaletteColors[paletteIndex];
          
          if (!fullPalette || fullPalette.length === 0) {
            console.error(`No palette found for base[${paletteIndex}]`);
            return;
          }
          
          console.log(`Applying palette ${paletteIndex} with ${fullPalette.length} colors`);
          
          // Pass the actual palette array to processPallet
          if (typeof window.processPallet === 'function') {
            window.processPallet(null, 1, null, 0, null, fullPalette, 'base', paletteIndex);
          }
        } catch (e) {
          console.error("Error in apply button handler:", e);
        }
      });
    });
    
    // Set up lazy loading for palette previews
    setupLazyLoadingForPalettes();
    
    // Add the necessary CSS if it doesn't exist
    if (!document.getElementById('palette-preview-styles')) {
      const styleElement = document.createElement('style');
      styleElement.id = 'palette-preview-styles';
      styleElement.textContent = `
        .palette-clickable-container {
            display: flex;
            flex-direction: column;
            cursor: pointer;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transition: transform 0.2s, box-shadow 0.2s;
            position: relative;
            width: 200px;
            margin-bottom: 15px;
        }
        
        .palette-clickable-container:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        
        .palette-preview-container {
            width: 200px;
            height: 200px;
            overflow: hidden;
            position: relative;
            background-color: white;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .palette-preview-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.7);
            z-index: 1;
        }
        
        .palette-preview-container::after {
            content: 'Loading...';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #666;
            z-index: 2;
        }
        
        .preview-ready .palette-preview-container::before,
        .preview-ready .palette-preview-container::after {
            display: none;
        }
        
        .palette-preview-canvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        
        .swatch-container {
            display: flex;
            justify-content: space-around;
            padding: 5px;
            background-color: #f5f5f5;
            border-top: 1px solid #ddd;
        }
        
        .color-swatch {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 1px solid #ddd;
            margin: 0 2px;
        }
        
        .ss-swatch {
            border-color: #d0d0ff;
        }
        
        .aw-swatch {
            border-color: #ffd0d0;
        }
        
        .base-swatch {
            border-color: #d0ffd0;
        }
        
        .show-all-colors-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 25px;
            height: 25px;
            background-color: rgba(255,255,255,0.8);
            color: #333;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-weight: bold;
            z-index: 3;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        
        .show-all-colors-btn:hover {
            background-color: rgba(255,255,255,0.95);
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        
        .full-palette-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.7);
        }
        
        .full-palette-modal-content {
            background-color: #fff;
            margin: 10% auto;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            width: 80%;
            max-width: 600px;
            position: relative;
        }
        
        .close-palette-modal {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .palette-modal-title {
            text-align: center;
            margin-bottom: 20px;
            color: #333;
        }
        
        .all-colors-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
        }
        
        .full-palette-color {
            width: 80px;
            height: 80px;
            border-radius: 8px;
            position: relative;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .color-info {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: rgba(0,0,0,0.6);
            color: white;
            font-size: 10px;
            padding: 3px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .full-palette-color:hover .color-info {
            opacity: 1;
        }
        
        .palette-number {
            position: absolute;
            top: 5px;
            left: 5px;
            background-color: rgba(0,0,0,0.6);
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            z-index: 3;
        }
        
        .scheme-tags {
            position: absolute;
            top: 5px;
            right: 34px;
            display: flex;
            gap: 4px;
            z-index: 3;
        }
        
        .shade-tag, .harmony-tag {
            background-color: rgba(0,0,0,0.6);
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            white-space: nowrap;
        }
        
        .harmony-tag {
            background-color: rgba(60,60,120,0.8);
        }
        
        .base-color-filters {
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            align-items: center;
        }
        
        .filter-dropdown {
            min-width: 140px;
        }
        
        .filter-dropdown select {
            width: 100%;
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid #ced4da;
            background-color: white;
        }
      `;
      document.head.appendChild(styleElement);
    }
  } catch (error) {
    console.error("Error in selectBaseColor:", error);
  }
}

// Create base color dropdown filters
function createBaseColorDropdownFilters(baseColor) {
  // Remove any existing filter container
  const existingFilters = document.querySelector('.base-color-filters');
  if (existingFilters) {
    existingFilters.remove();
  }
  
  // Create filter container
  const filterContainer = document.createElement('div');
  filterContainer.className = 'base-color-filters';
  
  // Create filter label for harmony
  const harmonyLabel = document.createElement('div');
  harmonyLabel.className = 'filter-label';
  harmonyLabel.textContent = 'Harmony:';
  
  // Create harmony dropdown
  const harmonyDropdown = document.createElement('div');
  harmonyDropdown.className = 'filter-dropdown harmony-dropdown';
  
  const harmonySelect = document.createElement('select');
  harmonySelect.id = 'harmony-filter';
  harmonySelect.className = 'form-select';
  
  // Add harmony options
  const harmonyOptions = [
    { value: 'all', label: 'All Harmonies' },
    { value: 'normal', label: 'Standard' },
    { value: 'monochromatic', label: 'Monochromatic' },
    { value: 'analogous', label: 'Analogous' },
    { value: 'complementary', label: 'Complementary' },
    { value: 'splitComplementary', label: 'Split Complementary' },
    { value: 'triadic', label: 'Triadic' },
    { value: 'tetradic', label: 'Tetradic' },
    { value: 'square', label: 'Square' }
  ];
  
  harmonyOptions.forEach(option => {
    const optionElement = document.createElement('option');
    optionElement.value = option.value;
    optionElement.textContent = option.label;
    harmonySelect.appendChild(optionElement);
  });
  
  harmonyDropdown.appendChild(harmonySelect);
  
  // Create filter label for shade
  const shadeLabel = document.createElement('div');
  shadeLabel.className = 'filter-label';
  shadeLabel.textContent = 'Shade:';
  
  // Create shade dropdown
  const shadeDropdown = document.createElement('div');
  shadeDropdown.className = 'filter-dropdown shade-dropdown';
  
  const shadeSelect = document.createElement('select');
  shadeSelect.id = 'shade-filter';
  shadeSelect.className = 'form-select';
  
  // Add shade options
  const shadeOptions = [
    { value: 'all', label: 'All Shades' },
    { value: 'faint', label: 'Faint' },
    { value: 'regular', label: 'Regular' },
    { value: 'dark', label: 'Dark' }
  ];
  
  shadeOptions.forEach(option => {
    const optionElement = document.createElement('option');
    optionElement.value = option.value;
    optionElement.textContent = option.label;
    shadeSelect.appendChild(optionElement);
  });
  
  shadeDropdown.appendChild(shadeSelect);
  
  // Add event listeners to dropdowns
  harmonySelect.addEventListener('change', function() {
    applyFilters(this.value, shadeSelect.value, baseColor);
  });
  
  shadeSelect.addEventListener('change', function() {
    applyFilters(harmonySelect.value, this.value, baseColor);
  });
  
  // Add all elements to filter container
  filterContainer.appendChild(harmonyLabel);
  filterContainer.appendChild(harmonyDropdown);
  filterContainer.appendChild(shadeLabel);
  filterContainer.appendChild(shadeDropdown);
  
  // Add filter container before the palettes container
  const palettesSection = document.querySelector('.base-palettes-section');
  if (palettesSection) {
    const palettesContainer = palettesSection.querySelector('.base-palettes-container');
    palettesSection.insertBefore(filterContainer, palettesContainer);
  }
}

// Apply filters to the displayed palettes
function applyFilters(harmonyFilter, shadeFilter, baseColor) {
  console.log(`Applying filters - Harmony: ${harmonyFilter}, Shade: ${shadeFilter}`);
  
  // Get all palette rows
  const paletteRows = document.querySelectorAll('.palette-row');
  let visibleCount = 0;
  
  paletteRows.forEach(row => {
    // Get the palette's shade category and harmony scheme
    const shadeCategory = row.dataset.shadeCategory || 'regular';
    const harmonyScheme = row.dataset.harmonyScheme || 'normal';
    
    // Show or hide based on filters
    const matchesShade = shadeFilter === 'all' || shadeFilter === shadeCategory;
    const matchesHarmony = harmonyFilter === 'all' || harmonyFilter === harmonyScheme;
    
    if (matchesShade && matchesHarmony) {
      row.style.display = 'flex';
      visibleCount++;
    } else {
      row.style.display = 'none';
    }
  });
  
  console.log(`Filters applied - ${visibleCount} palettes visible`);
}

// Add a function to let users select which color is the background
function selectBackgroundColor(originalColors) {
  // Create a modal for selecting background color
  let modal = document.getElementById('background-color-modal');
  
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'background-color-modal';
    modal.classList.add('modal', 'fade');
    modal.setAttribute('tabindex', '-1');
    modal.setAttribute('role', 'dialog');
    modal.setAttribute('aria-labelledby', 'backgroundColorModalLabel');
    modal.setAttribute('aria-hidden', 'true');
    
    modal.innerHTML = `
      <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="backgroundColorModalLabel">Select Background Color</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <p>Click on the color you want to use as the background color:</p>
            <div id="background-color-options" class="d-flex flex-wrap gap-2 justify-content-center"></div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
            <button type="button" class="btn btn-primary" id="auto-detect-bg">Auto-detect</button>
          </div>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
  }
  
  // Clear existing color options
  const colorOptionsContainer = document.getElementById('background-color-options');
  colorOptionsContainer.innerHTML = '';
  
  // Create color swatches for each original color
  originalColors.forEach((color, index) => {
    const colorSwatch = document.createElement('div');
    colorSwatch.classList.add('background-color-option');
    colorSwatch.style.width = '50px';
    colorSwatch.style.height = '50px';
    colorSwatch.style.backgroundColor = `rgb(${color.join(',')})`;
    colorSwatch.style.cursor = 'pointer';
    colorSwatch.style.border = '2px solid #ddd';
    colorSwatch.style.borderRadius = '4px';
    
    // Get color name for tooltip
    const colorName = getColorName(color);
    colorSwatch.title = `${colorName} (${index + 1})`;
    
    // Add data attribute to store color index
    colorSwatch.dataset.colorIndex = index;
    
    // Add click handler
    colorSwatch.addEventListener('click', function() {
      // Remove selection styling from all swatches
      document.querySelectorAll('.background-color-option').forEach(swatch => {
        swatch.style.border = '2px solid #ddd';
      });
      
      // Add selection styling to clicked swatch
      this.style.border = '3px solid #007bff';
      
      // Store selected background color index
      window.selectedBackgroundColorIndex = parseInt(this.dataset.colorIndex, 10);
    });
    
    colorOptionsContainer.appendChild(colorSwatch);
  });
  
  // Add auto-detect handler
  document.getElementById('auto-detect-bg').addEventListener('click', function() {
    // Auto-detect background color (largest area or most frequent color)
    // For now, just use the first color as default
    window.selectedBackgroundColorIndex = 0;
    
    // Close the modal
    const bsModal = bootstrap.Modal.getInstance(modal);
    if (bsModal) {
      bsModal.hide();
    }
  });
  
  // Show the modal
  const bsModal = new bootstrap.Modal(modal);
  bsModal.show();
  
  // Return a promise that resolves when a color is selected
  return new Promise((resolve) => {
    modal.addEventListener('hidden.bs.modal', function() {
      resolve(window.selectedBackgroundColorIndex !== undefined ? window.selectedBackgroundColorIndex : 0);
    });
  });
}


function setupLazyLoadingForPalettes() {
  // Remove pagination controls if they exist
  const paginationContainer = document.querySelector('.palette-pagination');
  if (paginationContainer) {
    paginationContainer.remove();
  }
  
  // Show all palette rows
  document.querySelectorAll('.palette-row').forEach(row => {
    row.style.display = 'flex';
  });
  
  // Set up IntersectionObserver to load previews only when they become visible
  const previewObserver = new IntersectionObserver((entries, observer) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const container = entry.target;
        const previewCanvas = container.querySelector('.palette-preview-canvas');
        const paletteIndex = parseInt(container.dataset.paletteIndex, 10);
        
        if (previewCanvas && window.basePaletteColors && window.basePaletteColors[paletteIndex]) {
          const paletteColors = window.basePaletteColors[paletteIndex];
          
          // Generate the preview
          generatePreview(previewCanvas, paletteColors, paletteIndex);
          
          // Stop observing this container after loading
          observer.unobserve(container);
        }
      }
    });
  }, {
    rootMargin: '200px 0px', // Start loading when within 200px of viewport
    threshold: 0.01
  });
  
  // Start observing all palette containers
  document.querySelectorAll('.palette-clickable-container').forEach(container => {
    previewObserver.observe(container);
    
    // Add a placeholder instead of immediately loading
    const previewCanvas = container.querySelector('.palette-preview-canvas');
    if (previewCanvas) {
      const ctx = previewCanvas.getContext('2d');
      ctx.fillStyle = '#f8f8f8';
      ctx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
      
      // Add a visual indicator that this will load
      ctx.fillStyle = '#cccccc';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = '14px sans-serif';
      ctx.fillText('Preview will load when visible', previewCanvas.width/2, previewCanvas.height/2);
    }
  });
  
  // Add a scroll to top button for better navigation
  const scrollButton = document.createElement('button');
  scrollButton.className = 'scroll-to-top-btn';
  scrollButton.innerHTML = '↑';
  scrollButton.title = 'Scroll to top';
  scrollButton.style.cssText = `
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background-color: rgba(0,123,255,0.8);
    color: white;
    font-size: 20px;
    border: none;
    cursor: pointer;
    display: none;
    z-index: 1000;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
  `;
  
  document.body.appendChild(scrollButton);
  
  // Show/hide scroll button based on scroll position
  window.addEventListener('scroll', () => {
    if (document.documentElement.scrollTop > 300) {
      scrollButton.style.display = 'block';
    } else {
      scrollButton.style.display = 'none';
    }
  });
  
  // Add click handler for scroll button
  scrollButton.addEventListener('click', () => {
    window.scrollTo({
      top: 0,
      behavior: 'smooth'
    });
  });
  
  // Add a "loading more palettes" indicator at the bottom
  const loadingIndicator = document.createElement('div');
  loadingIndicator.className = 'palettes-loading-indicator';
  loadingIndicator.style.cssText = `
    text-align: center;
    padding: 20px;
    color: #666;
    font-style: italic;
  `;
  loadingIndicator.textContent = 'Loading more palettes as you scroll...';
  
  const palettesContainer = document.querySelector('.base-palettes-container');
  if (palettesContainer) {
    palettesContainer.parentNode.appendChild(loadingIndicator);
    
    // Set up observer to hide the loading indicator when all palettes are loaded
    const loadingObserver = new IntersectionObserver((entries) => {
      if (entries[0].isIntersecting) {
        // When we see the loading indicator in view, check if all palettes are loaded
        const notLoadedPalettes = document.querySelectorAll('.palette-clickable-container:not(.preview-ready)');
        
        if (notLoadedPalettes.length === 0) {
          // All palettes loaded, hide the indicator
          loadingIndicator.textContent = 'All palettes loaded!';
          setTimeout(() => {
            loadingIndicator.style.display = 'none';
          }, 2000);
          
          loadingObserver.disconnect();
        }
      }
    });
    
    loadingObserver.observe(loadingIndicator);
  }
}




// Modified generateBaseColors function to restore filter preference
function generateBaseColors() {
  const baseColorsGrid = document.querySelector('.base-colors-grid');
  
  // Convert RGB to Hex helper function
  function rgbToHex(r, g, b) {
    return '#' + [r, g, b].map(x => {
      const hex = x.toString(16);
      return hex.length === 1 ? '0' + hex : hex;
    }).join('');
  }
  
  // Clear existing content
  baseColorsGrid.innerHTML = '';
  
  // 24 predefined colors with names
  const baseColors = [
    { name: "Red", red: 255, green: 0, blue: 0 },
    { name: "Orange", red: 255, green: 165, blue: 0 },
    { name: "Yellow", red: 255, green: 255, blue: 0 },
    { name: "Lime", red: 0, green: 255, blue: 0 },
    { name: "Green", red: 0, green: 128, blue: 0 },
    { name: "Teal", red: 0, green: 128, blue: 128 },
    { name: "Cyan", red: 0, green: 255, blue: 255 },
    { name: "Blue", red: 0, green: 0, blue: 255 },
    { name: "Navy", red: 0, green: 0, blue: 128 },
    { name: "Purple", red: 128, green: 0, blue: 128 },
    { name: "Magenta", red: 255, green: 0, blue: 255 },
    { name: "Pink", red: 255, green: 192, blue: 203 },
    { name: "Brown", red: 165, green: 42, blue: 42 },
    { name: "Maroon", red: 128, green: 0, blue: 0 },
    { name: "Olive", red: 128, green: 128, blue: 0 },
    { name: "Gold", red: 255, green: 215, blue: 0 },
    { name: "Silver", red: 192, green: 192, blue: 192 },
    { name: "Gray", red: 128, green: 128, blue: 128 },
    { name: "Black", red: 0, green: 0, blue: 0 },
    { name: "White", red: 255, green: 255, blue: 255 },
    { name: "Coral", red: 255, green: 127, blue: 80 },
    { name: "Indigo", red: 75, green: 0, blue: 130 },
    { name: "Turquoise", red: 64, green: 224, blue: 208 },
    { name: "Lavender", red: 230, green: 230, blue: 250 }
  ];
  
  baseColors.forEach(color => {
    const colorBlock = document.createElement('div');
    colorBlock.className = 'base-color-block';
    
    // Convert color data to RGB array
    const rgb = [color.red, color.green, color.blue];
    colorBlock.style.backgroundColor = `rgb(${rgb.join(',')})`;
    
    // Convert RGB to HEX for display
    const hexColor = rgbToHex(rgb[0], rgb[1], rgb[2]);
    
    // Display the color name
    colorBlock.innerHTML = `<div class="color-name">${color.name}</div>`;
    
    // Add title attribute with hex code for tooltip
    colorBlock.title = `${color.name}: ${hexColor}`;
    
    // Handle color selection
    colorBlock.addEventListener('click', () => selectBaseColor(rgb));
    
    baseColorsGrid.appendChild(colorBlock);
  });

  // Initially hide the palettes section
  const basePalettesSection = document.querySelector('.base-palettes-section');
  if (basePalettesSection) {
    basePalettesSection.style.display = 'none';
  }
}

function resetBaseColorView() {
  // Show the base colors grid
  const baseColorsGrid = document.querySelector('.base-colors-grid');
  baseColorsGrid.style.display = 'grid';
  
  // Remove any existing filter container
  const filterContainer = document.querySelector('.base-color-filters');
  if (filterContainer) {
    filterContainer.remove();
  }
  
  // Hide the palettes section
  const basePalettesSection = document.querySelector('.base-palettes-section');
  if (basePalettesSection) {
    basePalettesSection.style.display = 'none';
  }
  
  // Reset the header text
  const headerElement = document.querySelector('#baseColorContent h4');
  if (headerElement) {
    headerElement.textContent = 'Base Colors';
  }
  
  // Remove the back button
  const backButton = document.querySelector('.back-to-base-colors');
  if (backButton) {
    backButton.remove();
  }
}



{% comment %} mockups  {% endcomment %}
// Add this to your JavaScript section

document.addEventListener('DOMContentLoaded', function() {
    // Set up event handlers for mockup apply buttons
    document.querySelectorAll('.apply-mockup-btn').forEach(button => {
        button.addEventListener('click', function() {
            const mockupId = this.closest('.mockup-item').dataset.mockupId;
            const mockupImg = this.closest('.mockup-item').querySelector('img').src;
            const mockupName = this.closest('.mockup-item').querySelector('.mockup-name').textContent;
            applyMockupOverlay(mockupId, mockupImg, mockupName);
        });
    });

    // Add mockups button handler to the existing navigation structure
    const mockupsButton = document.getElementById('mockupsButton');
    if (mockupsButton) {
        mockupsButton.addEventListener('click', function(e) {
            e.preventDefault();
            
            // Set this button as active
            const navButtons = document.querySelectorAll('.mostLeftUl li a');
            navButtons.forEach(button => {
                button.classList.remove('active');
            });
            this.classList.add('active');
            
            // Make sure secondaryColumn is visible
            const secondaryColumn = document.getElementById('secondaryColumn');
            secondaryColumn.style.display = 'flex';
            
            // Hide all content sections inside secondaryColumn
            const contentSections = document.querySelectorAll('#secondaryColumn .sidebar-content');
            contentSections.forEach(content => {
                if (content) content.style.display = 'none';
            });
            
            // Show the mockups content
            const mockupsContent = document.getElementById('mockupsContent');
            if (mockupsContent) {
                mockupsContent.style.display = 'block';
            }
            
            // If the sidebar is collapsed, uncollapse it
            if (secondaryColumn.classList.contains('collapsed')) {
                const toggleButton = secondaryColumn.querySelector('button');
                toggleSidebar('secondaryColumn', toggleButton);
            }
        });
    }
});

// Helper function to add the new layer to the layers panel in the right sidebar
// Helper function to add the new layer to the layers panel in the right sidebar
function addLayerToPanel(layerId, layerName, thumbnailSrc) {
    // Get the layer toggles container from the right sidebar specifically
    const layerToggles = document.querySelector('#rightSidebar .layer-toggles');
    if (!layerToggles) {
      console.error('Right sidebar layer toggles not found');
      return;
    }
  
    // Create new layer toggle item
    const layerItem = document.createElement('div');
    layerItem.className = 'layer-toggle-item';
    layerItem.id = `layer-toggle-${layerId}`;
  
    // Create thumbnail
    const thumbnail = document.createElement('img');
    thumbnail.className = 'thumbnail';
    thumbnail.src = thumbnailSrc;
    thumbnail.alt = layerName + ' Thumbnail';
  
    // Create layer name
    const nameSpan = document.createElement('span');
    nameSpan.className = 'layer-name';
    nameSpan.textContent = layerName;
  
    // Create visibility toggle
    const toggle = document.createElement('input');
    toggle.type = 'checkbox';
    toggle.id = `toggleLayer${layerId}`;
    toggle.checked = true;
    toggle.addEventListener('change', function() {
      const layerDiv = document.getElementById(`layer_${layerId}`);
      if (layerDiv) {
        layerDiv.style.display = this.checked ? 'block' : 'none';
      }
    });
  
    // Add select functionality
    layerItem.addEventListener('click', function(e) {
      if (e.target !== toggle) { // Don't select when clicking the checkbox
        selectLayer(layerId);
      }
    });
  
    // Assemble the layer item
    layerItem.appendChild(thumbnail);
    layerItem.appendChild(nameSpan);
    layerItem.appendChild(toggle);
  
    // Add to the right sidebar layers panel (at the top)
    if (layerToggles.firstChild) {
      layerToggles.insertBefore(layerItem, layerToggles.firstChild);
    } else {
      layerToggles.appendChild(layerItem);
    }
  }
function applyMockupOverlay(mockupId, mockupUrl, mockupName) {
    console.log(`Applying mockup overlay: ${mockupId} - ${mockupName}`);
  
    // Get the canvas container
    const canvasContainer = document.querySelector('.canvas-container');
    const zoomWrapper = document.getElementById('zoomWrapper') || canvasContainer.parentElement;
  
    // Create loader
    const loader = document.createElement('div');
    loader.id = 'mockup-loader';
    loader.innerHTML = `<div class="spinner-border text-primary" role="status"><span class="visually-hidden">Loading mockup...</span></div>`;
    loader.style.position = 'absolute';
    loader.style.top = '50%';
    loader.style.left = '50%';
    loader.style.transform = 'translate(-50%, -50%)';
    loader.style.zIndex = '1000';
  
    zoomWrapper.appendChild(loader);
  
    // First, combine all visible layers to get the design
    const designCanvas = createCombinedDesignCanvas();
  
    // Then load the mockup template
    const mockupImg = new Image();
    mockupImg.crossOrigin = 'Anonymous';
  
    mockupImg.onload = function() {
      // Remove loader
      document.getElementById('mockup-loader')?.remove();
  
      // Apply design to mockup as floating element
      createFloatingMockup(designCanvas, mockupImg, mockupName, mockupId);
    };
  
    mockupImg.onerror = function() {
      document.getElementById('mockup-loader')?.remove();
      console.error('Error loading mockup image');
      alert('Failed to load the mockup image. Please try again.');
    };
  
    mockupImg.src = mockupUrl;
  }
  
  // Function to create a floating mockup
  function createFloatingMockup(designCanvas, mockupImg, mockupName, mockupId) {
    // Create a temporary canvas for analyzing the mockup
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = mockupImg.width;
    tempCanvas.height = mockupImg.height;
    const tempCtx = tempCanvas.getContext('2d');
    tempCtx.drawImage(mockupImg, 0, 0);
  
    // Analyze the mockup to find transparent/mask areas
    const maskData = findMaskArea(tempCanvas);
  
    // Create output canvas with mockup dimensions
    const outputCanvas = document.createElement('canvas');
    outputCanvas.width = mockupImg.width;
    outputCanvas.height = mockupImg.height;
    const outputCtx = outputCanvas.getContext('2d');
  
    // First draw the design (scaled to fit the mask area)
    if (maskData.hasMask) {
      // Scale design to fit the mask area
      const scaledDesign = scaleDesignToFitArea(designCanvas, maskData.maskArea);
  
      // Draw the design onto the mask area
      outputCtx.drawImage(
        scaledDesign,
        0, 0, scaledDesign.width, scaledDesign.height,
        maskData.maskArea.x, maskData.maskArea.y,
        maskData.maskArea.width, maskData.maskArea.height
      );
    } else {
      // If no mask found, center the design at 40% of mockup size
      const designWidth = mockupImg.width * 0.4;
      const designHeight = mockupImg.height * 0.4;
      const centerX = (mockupImg.width - designWidth) / 2;
      const centerY = (mockupImg.height - designHeight) / 2;
  
      outputCtx.drawImage(designCanvas, centerX, centerY, designWidth, designHeight);
    }
  
    // Apply the mockup with transparency/mask on top
    applyMockupWithTransparency(outputCtx, mockupImg);
  
    // Create floating mockup element
    createFloatingElement(outputCanvas, mockupName, mockupId);
  }
  
  // Function to create floating element
  function createFloatingElement(canvas, mockupName, mockupId) {
    // Check if there's already a floating mockup with the same ID
    const existingMockup = document.getElementById(`floating-mockup-${mockupId}`);
    if (existingMockup) {
      existingMockup.remove();
    }
  
    // Create container for the floating mockup
    const floatingMockup = document.createElement('div');
    floatingMockup.id = `floating-mockup-${mockupId}`;
    floatingMockup.className = 'floating-mockup';
    floatingMockup.style.position = 'absolute';
    floatingMockup.style.top = '50%';
    floatingMockup.style.left = '50%';
    floatingMockup.style.transform = 'translate(-50%, -50%)';
    floatingMockup.style.boxShadow = '0 5px 15px rgba(0,0,0,0.3)';
    floatingMockup.style.borderRadius = '4px';
    floatingMockup.style.zIndex = '1000';
    floatingMockup.style.cursor = 'move';
    floatingMockup.style.maxWidth = '90%';
    floatingMockup.style.maxHeight = '90%';
    floatingMockup.style.userSelect = 'none';
  
    // Create the image from canvas
    const img = document.createElement('img');
    img.src = canvas.toDataURL('image/png');
    img.alt = mockupName;
    img.style.width = '100%';
    img.style.height = '100%';
    img.style.objectFit = 'contain';
    img.style.pointerEvents = 'none';
  
    // Create controls bar
    const controlsBar = document.createElement('div');
    controlsBar.className = 'mockup-controls';
    controlsBar.style.position = 'absolute';
    controlsBar.style.top = '0';
    controlsBar.style.right = '0';
    controlsBar.style.backgroundColor = 'rgba(0,0,0,0.5)';
    controlsBar.style.padding = '5px';
    controlsBar.style.borderBottomLeftRadius = '4px';
    controlsBar.style.display = 'flex';
    controlsBar.style.gap = '5px';
  
    // Add title
    const title = document.createElement('div');
    title.textContent = mockupName;
    title.style.color = 'white';
    title.style.padding = '0 8px';
    title.style.fontSize = '12px';
    title.style.lineHeight = '24px';
    title.style.whiteSpace = 'nowrap';
    title.style.overflow = 'hidden';
    title.style.textOverflow = 'ellipsis';
    title.style.maxWidth = '150px';
  
    // Add add-to-canvas button
    const addButton = document.createElement('button');
    addButton.innerHTML = '<i class="fas fa-plus"></i> Add';
    addButton.title = 'Add to canvas';
    addButton.style.backgroundColor = '#4CAF50';
    addButton.style.color = 'white';
    addButton.style.border = 'none';
    addButton.style.padding = '2px 8px';
    addButton.style.borderRadius = '3px';
    addButton.style.cursor = 'pointer';
    addButton.style.fontSize = '12px';

  
    // Add close button
    const closeButton = document.createElement('button');
    closeButton.innerHTML = '<i class="fas fa-times"></i>';
    closeButton.title = 'Close';
    closeButton.style.backgroundColor = '#F44336';
    closeButton.style.color = 'white';
    closeButton.style.border = 'none';
    closeButton.style.padding = '2px 8px';
    closeButton.style.borderRadius = '3px';
    closeButton.style.cursor = 'pointer';
    closeButton.style.fontSize = '12px';
    closeButton.onclick = function(e) {
      e.stopPropagation();
      floatingMockup.remove();
    };
  
    // Add download button
    const downloadButton = document.createElement('button');
    downloadButton.innerHTML = '<i class="fas fa-download"></i>';
    downloadButton.title = 'Download';
    downloadButton.style.backgroundColor = '#2196F3';
    downloadButton.style.color = 'white';
    downloadButton.style.border = 'none';
    downloadButton.style.padding = '2px 8px';
    downloadButton.style.borderRadius = '3px';
    downloadButton.style.cursor = 'pointer';
    downloadButton.style.fontSize = '12px';
    downloadButton.onclick = function(e) {
      e.stopPropagation();
      
      // Create a download link
      const link = document.createElement('a');
      link.download = `${mockupName.replace(/\s+/g, '-').toLowerCase()}.png`;
      link.href = canvas.toDataURL('image/png');
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    };
  
    // Assemble the controls
    controlsBar.appendChild(title);
    controlsBar.appendChild(downloadButton);
    controlsBar.appendChild(addButton);
    controlsBar.appendChild(closeButton);
  
    // Add elements to the floating mockup
    floatingMockup.appendChild(img);
    floatingMockup.appendChild(controlsBar);
  
    // Add to DOM - use a parent that persists across different views
    const appRoot = document.getElementById('app') || document.body;
    appRoot.appendChild(floatingMockup);
  
    // Make the floating mockup draggable
    makeDraggable(floatingMockup);
  
    // Show success message
    showToast('Mockup preview created! Click "Add" to add it to your canvas.', 'success');
  }
  
  // Function to make an element draggable
  function makeDraggable(element) {
    let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
    
    element.onmousedown = dragMouseDown;
  
    function dragMouseDown(e) {
      e = e || window.event;
      e.preventDefault();
      
      // Don't start drag if clicking on a button
      if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
        return;
      }
      
      // Get the mouse cursor position at startup
      pos3 = e.clientX;
      pos4 = e.clientY;
      document.onmouseup = closeDragElement;
      document.onmousemove = elementDrag;
      
      // Add active class
      element.classList.add('dragging');
    }
  
    function elementDrag(e) {
      e = e || window.event;
      e.preventDefault();
      
      // Calculate the new cursor position
      pos1 = pos3 - e.clientX;
      pos2 = pos4 - e.clientY;
      pos3 = e.clientX;
      pos4 = e.clientY;
      
      // Set the element's new position
      const top = (element.offsetTop - pos2);
      const left = (element.offsetLeft - pos1);
      
      element.style.top = top + "px";
      element.style.left = left + "px";
      element.style.transform = 'none'; // Remove the translate once we start dragging
    }
  
    function closeDragElement() {
      // Stop moving when mouse button is released
      document.onmouseup = null;
      document.onmousemove = null;
      
      // Remove active class
      element.classList.remove('dragging');
    }
  }
  
  // Function to find mask area in a mockup
  function findMaskArea(mockupCanvas) {
    const ctx = mockupCanvas.getContext('2d');
    const imageData = ctx.getImageData(0, 0, mockupCanvas.width, mockupCanvas.height);
    const data = imageData.data;
  
    const transparentPoints = [];
  
    // Check for transparent areas (alpha < 50)
    for (let y = 0; y < mockupCanvas.height; y++) {
      for (let x = 0; x < mockupCanvas.width; x++) {
        const idx = (y * mockupCanvas.width + x) * 4;
        if (data[idx + 3] < 50) {
          transparentPoints.push({ x, y });
        }
      }
    }
  
    // If we found transparent areas
    if (transparentPoints.length > 0) {
      // Calculate bounding box of transparent area
      const maskArea = calculateBoundingBox(transparentPoints, mockupCanvas.width, mockupCanvas.height);
  
      return {
        hasMask: true,
        maskArea: maskArea
      };
    }
  
    // If no transparent area found, look for a specific color that might indicate a mask
    // This is a fallback if the mockup uses a solid color instead of transparency
  
    // For now, let's use white as a fallback mask color (you can customize this)
    const whitePoints = [];
    const whiteThreshold = 245; // Threshold to consider a pixel "white"
  
    for (let y = 0; y < mockupCanvas.height; y++) {
      for (let x = 0; x < mockupCanvas.width; x++) {
        const idx = (y * mockupCanvas.width + x) * 4;
        if (data[idx] > whiteThreshold &&
            data[idx + 1] > whiteThreshold &&
            data[idx + 2] > whiteThreshold &&
            data[idx + 3] > 240) { // Fully opaque white
          whitePoints.push({ x, y });
        }
      }
    }
  
    if (whitePoints.length > 0) {
      // Must be at least 10% of the image to be considered a valid mask
      if (whitePoints.length > (mockupCanvas.width * mockupCanvas.height * 0.1)) {
        const maskArea = calculateBoundingBox(whitePoints, mockupCanvas.width, mockupCanvas.height);
        return {
          hasMask: true,
          maskArea: maskArea
        };
      }
    }
  
    // No mask found
    return {
      hasMask: false,
      maskArea: {
        x: 0,
        y: 0,
        width: mockupCanvas.width,
        height: mockupCanvas.height
      }
    };
  }
  
  // Apply mockup with preserved transparency
  function applyMockupWithTransparency(outputCtx, mockupImg) {
    // Create a temporary canvas
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = mockupImg.width;
    tempCanvas.height = mockupImg.height;
    const tempCtx = tempCanvas.getContext('2d');
  
    // Draw the mockup
    tempCtx.drawImage(mockupImg, 0, 0);
  
    // Get mockup image data
    const mockupImageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
    const mockupData = mockupImageData.data;
  
    // Get current output canvas data
    const outputImageData = outputCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
    const outputData = outputImageData.data;
  
    // Blend the images, preserving mockup transparency
    for (let i = 0; i < mockupData.length; i += 4) {
      const alpha = mockupData[i + 3] / 255;
  
      // If mockup pixel is opaque, use mockup color
      if (alpha > 0.8) {
        outputData[i] = mockupData[i]; // R
        outputData[i + 1] = mockupData[i + 1]; // G
        outputData[i + 2] = mockupData[i + 2]; // B
        outputData[i + 3] = 255; // A (fully opaque)
      }
      // If mockup pixel is semi-transparent, blend with design
      else if (alpha > 0) {
        outputData[i] = outputData[i] * (1 - alpha) + mockupData[i] * alpha;
        outputData[i + 1] = outputData[i + 1] * (1 - alpha) + mockupData[i + 1] * alpha;
        outputData[i + 2] = outputData[i + 2] * (1 - alpha) + mockupData[i + 2] * alpha;
        // Alpha channel remains the same (from the design)
      }
      // If mockup pixel is fully transparent, keep the design pixel as is
    }
  
    // Put the blended data back to output canvas
    outputCtx.putImageData(outputImageData, 0, 0);
  }
  
  // Create combined design canvas from all visible layers
  function createCombinedDesignCanvas() {
    // Get all visible layers
    const layers = document.querySelectorAll('.layer');
  
    if (layers.length === 0) {
      console.error('No layers found');
      return null;
    }
  
    // Create a canvas to hold the combined design
    const designCanvas = document.createElement('canvas');
  
    // Find the first canvas to get dimensions
    const firstCanvas = document.querySelector('canvas[id^="layer_canvas_"]');
    if (!firstCanvas) {
      console.error('No canvas elements found');
      return null;
    }
  
    designCanvas.width = firstCanvas.width;
    designCanvas.height = firstCanvas.height;
    const designCtx = designCanvas.getContext('2d');
  
    // Draw all visible layers onto the design canvas
    layers.forEach(layer => {
      // Check if layer is visible
      const layerId = layer.id.replace('layer_', '');
      const toggle = document.getElementById(`toggleLayer${layerId}`);
  
      // If toggle doesn't exist or is checked
      if (!toggle || toggle.checked) {
        const canvas = layer.querySelector('canvas');
        if (canvas) {
          // Get layer position
          const top = parseInt(layer.style.top) || 0;
          const left = parseInt(layer.style.left) || 0;
  
          // Draw the layer at its position
          designCtx.drawImage(canvas, left, top);
        }
      }
    });
  
    return designCanvas;
  }
  
  // Calculate bounding box for a set of points
  function calculateBoundingBox(points, canvasWidth, canvasHeight) {
    if (points.length === 0) return { x: 0, y: 0, width: canvasWidth, height: canvasHeight };
  
    let minX = canvasWidth, minY = canvasHeight, maxX = 0, maxY = 0;
  
    points.forEach(point => {
      minX = Math.min(minX, point.x);
      minY = Math.min(minY, point.y);
      maxX = Math.max(maxX, point.x);
      maxY = Math.max(maxY, point.y);
    });
  
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  
  // Scale and crop design to fit the target area
  function scaleDesignToFitArea(designCanvas, targetArea) {
    // Create a new canvas for the scaled design
    const scaledCanvas = document.createElement('canvas');
    scaledCanvas.width = targetArea.width;
    scaledCanvas.height = targetArea.height;
    const ctx = scaledCanvas.getContext('2d');
  
    // Calculate scaling to maintain aspect ratio
    const designRatio = designCanvas.width / designCanvas.height;
    const targetRatio = targetArea.width / targetArea.height;
  
    let sourceX = 0, sourceY = 0;
    let sourceWidth = designCanvas.width;
    let sourceHeight = designCanvas.height;
  
    if (designRatio > targetRatio) {
      // Design is wider than target area
      sourceWidth = designCanvas.height * targetRatio;
      sourceX = (designCanvas.width - sourceWidth) / 2;
    } else {
      // Design is taller than target area
      sourceHeight = designCanvas.width / targetRatio;
      sourceY = (designCanvas.height - sourceHeight) / 2;
    }
  
    // Draw the scaled design
    ctx.drawImage(
      designCanvas,
      sourceX, sourceY, sourceWidth, sourceHeight,
      0, 0, targetArea.width, targetArea.height
    );
  
    return scaledCanvas;
  }
  
  // Function to create a new layer from a canvas
  function createNewLayerFromCanvas(canvas, layerName) {
    try {
      // Generate a unique layer ID
      const timestamp = new Date().getTime();
      const newLayerId = `mockup_${timestamp}`;
  
      // Create a new canvas for this layer with the same dimensions
      const newCanvas = document.createElement('canvas');
      newCanvas.width = canvas.width;
      newCanvas.height = canvas.height;
      newCanvas.id = `layer_canvas_${newLayerId}`;
  
      // Copy the content from the provided canvas
      const ctx = newCanvas.getContext('2d');
      ctx.drawImage(canvas, 0, 0);
  
      // Create the layer container
      const layerDiv = document.createElement('div');
      layerDiv.id = `layer_${newLayerId}`;
      layerDiv.className = 'layer design-layer';
      layerDiv.style.position = 'absolute';
      layerDiv.style.top = '0';
      layerDiv.style.left = '0';
      layerDiv.style.zIndex = getHighestZIndex() + 1;
  
      // Add the canvas to the layer
      layerDiv.appendChild(newCanvas);
  
      // Add the layer to the canvas container
      const canvasContainer = document.querySelector('.canvas-container');
      canvasContainer.appendChild(layerDiv);
  
      // Create thumbnail for the layer panel
      const thumbnailCanvas = document.createElement('canvas');
      thumbnailCanvas.width = 50;
      thumbnailCanvas.height = 50;
      const thumbCtx = thumbnailCanvas.getContext('2d');
  
      // Draw a scaled down version of the layer content
      thumbCtx.drawImage(canvas, 0, 0, canvas.width, canvas.height, 0, 0, 50, 50);
  
      // Add layer to the layers panel
      addLayerToPanel(newLayerId, 'Mockup: ' + layerName, thumbnailCanvas.toDataURL());
  
      // Make the layer active
      selectLayer(newLayerId);
  
      // Show success message
      showToast('Mockup added to canvas!', 'success');
  
      return layerDiv;
    } catch (error) {
      console.error('Error creating layer from canvas:', error);
      showToast('Error applying mockup: ' + error.message, 'error');
      return null;
    }
  }
  
  // Helper function to get the highest z-index in use
  function getHighestZIndex() {
    const layers = document.querySelectorAll('.layer');
    let highestZ = 0;
  
    layers.forEach(layer => {
      const zIndex = parseInt(layer.style.zIndex) || 0;
      if (zIndex > highestZ) {
        highestZ = zIndex;
      }
    });
  
    return highestZ;
  }
  
  // Helper function to add the new layer to the layers panel
  function addLayerToPanel(layerId, layerName, thumbnailSrc) {
    const layerToggles = document.querySelector('.layer-toggles');
    if (!layerToggles) return;
  
    // Create new layer toggle item
    const layerItem = document.createElement('div');
    layerItem.className = 'layer-toggle-item';
    layerItem.id = `layer-toggle-${layerId}`;
  
    // Create thumbnail
    const thumbnail = document.createElement('img');
    thumbnail.className = 'thumbnail';
    thumbnail.src = thumbnailSrc;
    thumbnail.alt = layerName + ' Thumbnail';
  
    // Create layer name
    const nameSpan = document.createElement('span');
    nameSpan.className = 'layer-name';
    nameSpan.textContent = layerName;
  
    // Create visibility toggle
    const toggle = document.createElement('input');
    toggle.type = 'checkbox';
    toggle.id = `toggleLayer${layerId}`;
    toggle.checked = true;
    toggle.addEventListener('change', function() {
      const layerDiv = document.getElementById(`layer_${layerId}`);
      if (layerDiv) {
        layerDiv.style.display = this.checked ? 'block' : 'none';
      }
    });
  
    // Add select functionality
    layerItem.addEventListener('click', function(e) {
      if (e.target !== toggle) { // Don't select when clicking the checkbox
        selectLayer(layerId);
      }
    });
  
    // Assemble the layer item
    layerItem.appendChild(thumbnail);
    layerItem.appendChild(nameSpan);
    layerItem.appendChild(toggle);
  
    // Add to the layers panel (at the top)
    if (layerToggles.firstChild) {
      layerToggles.insertBefore(layerItem, layerToggles.firstChild);
    } else {
      layerToggles.appendChild(layerItem);
    }
  }
  
  // Helper function to select a layer
// Helper function to select a layer
function selectLayer(layerId) {
    // Deselect all other layers
    document.querySelectorAll('#rightSidebar .layer-toggle-item').forEach(item => {
      item.classList.remove('active');
    });
  
    // Select this layer
    const layerItem = document.getElementById(`layer-toggle-${layerId}`);
    if (layerItem) {
      layerItem.classList.add('active');
    }
  
    // Set this layer as the active one
    window.activeLayerId = layerId;
  
    // You might want to dispatch an event or call a function here to update your UI
    if (typeof updateToolsForActiveLayer === 'function') {
      updateToolsForActiveLayer();
    }
  }
  
  // Helper function to show toast notifications
  function showToast(message, type = 'info') {
    // Check if a toast container exists, create if not
    let toastContainer = document.getElementById('toast-container');
    if (!toastContainer) {
      toastContainer = document.createElement('div');
      toastContainer.id = 'toast-container';
      toastContainer.style.position = 'fixed';
      toastContainer.style.top = '20px';
      toastContainer.style.right = '20px';
      toastContainer.style.zIndex = '9999';
      document.body.appendChild(toastContainer);
    }
  
    // Create toast
    const toast = document.createElement('div');
    toast.className = `toast toast-${type}`;
    toast.style.minWidth = '250px';
    toast.style.margin = '10px';
    toast.style.padding = '15px';
    toast.style.borderRadius = '4px';
    toast.style.boxShadow = '0 2px 10px rgba(0,0,0,0.2)';
    toast.style.backgroundColor = type === 'success' ? '#4caf50' :
                                 type === 'error' ? '#f44336' :
                                 type === 'warning' ? '#ff9800' : '#2196f3';
    toast.style.color = 'white';
    toast.style.animation = 'fadeIn 0.3s, fadeOut 0.3s 2.7s';
    toast.style.animationFillMode = 'forwards';
    toast.innerHTML = message;
  
    // Add animation styles if not already present
    if (!document.getElementById('toast-animations')) {
      const style = document.createElement('style');
      style.id = 'toast-animations';
      style.innerHTML = `@keyframes fadeIn { from {opacity: 0; transform: translateY(-20px);} to {opacity: 1; transform: translateY(0);} } @keyframes fadeOut { from {opacity: 1; transform: translateY(0);} to {opacity: 0; transform: translateY(-20px);} }`;
      document.head.appendChild(style);
    }
  
    // Add toast to container
    toastContainer.appendChild(toast);
  
    // Remove toast after 3 seconds
    setTimeout(() => {
      toast.remove();
    }, 3000);
  }





// Function to convert HSV to RGB
function hsvToRgbBase(h, s, v) {
  let r, g, b;
  const i = Math.floor(h / 60);
  const f = h / 60 - i;
  const p = v * (1 - s);
  const q = v * (1 - f * s);
  const t = v * (1 - (1 - f) * s);
  
  switch (i % 6) {
      case 0: [r, g, b] = [v, t, p]; break;
      case 1: [r, g, b] = [q, v, p]; break;
      case 2: [r, g, b] = [p, v, t]; break;
      case 3: [r, g, b] = [p, q, v]; break;
      case 4: [r, g, b] = [t, p, v]; break;
      case 5: [r, g, b] = [v, p, q]; break;
  }
  
  return [
      Math.round(r * 255),
      Math.round(g * 255),
      Math.round(b * 255)
  ];
}
// Function to reset the base color view
function resetBaseColorView() {
  // Show the base colors grid
  const baseColorsGrid = document.querySelector('.base-colors-grid');
  baseColorsGrid.style.display = 'grid';
  
  // Hide the palettes section
  const basePalettesSection = document.querySelector('.base-palettes-section');
  basePalettesSection.style.display = 'none';
  
  // Reset the header
  const headerElement = document.querySelector('#baseColorContent h4');
  headerElement.textContent = 'Base Colors';
  
  // Remove the back button
  const backButton = document.querySelector('.back-to-base-colors');
  if (backButton) {
      backButton.remove();
  }
}

// Add some CSS for the back button
const backButtonStyle = document.createElement('style');
backButtonStyle.textContent = `
.back-to-base-colors {
  padding: 0.25rem 0.5rem;
  font-size: 0.875rem;
  margin-bottom: 1rem;
}

#baseColorContent h4 {
  margin-bottom: 0.5rem;
}
`;
document.head.appendChild(backButtonStyle);

// Initialize base colors when the page loads
document.addEventListener('DOMContentLoaded', () => {
  generateBaseColors();
  const baseColorButton = document.getElementById('baseColorButton');
  if (baseColorButton) {
      baseColorButton.addEventListener('click', function(e) {
          e.preventDefault();
          setActiveButton(this);
          secondaryColumn.style.display = 'flex';
          showContent('baseColorContent');
          
          // Reset to show base colors when the button is clicked
          resetBaseColorView();
      });
  }
});
{% comment %} base color end  {% endcomment %}


{% comment %} for generating random color pallete  {% endcomment %}
// Function to generate varied colors with preserved relationships but shifted hues
function generateCorrelatedPalettes(distinctColors, collection = 'trending') {
    // Convert RGB array to HSL
    function rgbToHsl(r, g, b) {
      r /= 255; g /= 255; b /= 255;
      const max = Math.max(r, g, b), min = Math.min(r, g, b);
      let h, s, l = (max + min) / 2;
  
      if (max === min) {
        h = s = 0; // achromatic
      } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
          case g: h = ((b - r) / d + 2) / 6; break;
          case b: h = ((r - g) / d + 4) / 6; break;
        }
      }
      return [h, s, l];
    }
  
    // Convert HSL to RGB
    function hslToRgb(h, s, l) {
      let r, g, b;
  
      if (s === 0) {
        r = g = b = l; // achromatic
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1; if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        };
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }
  
      return [
        Math.round(r * 255),
        Math.round(g * 255),
        Math.round(b * 255)
      ];
    }
  
    // Create a palette with shifted hue while preserving relationships
    function createShiftedPalette(colors, hueShift) {
      return colors.map(color => {
        const [h, s, l] = rgbToHsl(color[0], color[1], color[2]);
        
        // Shift the hue while preserving saturation and lightness
        let newHue = (h + hueShift) % 1.0;
        if (newHue < 0) newHue += 1.0;
        
        // Apply collection-specific adjustments
        let newS = s;
        let newL = l;
        
        if (collection === 'ss') {
          // Spring/Summer: Brighter, more saturated
          newS = Math.min(1, s * 1.1);
          newL = Math.min(0.9, l * 1.15);
        } else if (collection === 'aw') {
          // Autumn/Winter: Deeper, more muted
          newS = Math.max(0, s * 0.9);
          newL = Math.max(0.1, l * 0.85);
        }
        
        return hslToRgb(newHue, newS, newL);
      });
    }
    
    // Generate multiple palette variations based on color theory
    const palettes = [];
    
    // Complementary palette (180° hue shift)
    palettes.push(createShiftedPalette(distinctColors, 0.5));
    
    // Analogous palettes (30° and -30° hue shifts)
    palettes.push(createShiftedPalette(distinctColors, 0.083));
    palettes.push(createShiftedPalette(distinctColors, -0.083));
    
    // Triadic palettes (120° and 240° hue shifts)
    palettes.push(createShiftedPalette(distinctColors, 0.33));
    palettes.push(createShiftedPalette(distinctColors, 0.67));
    
    // Split-complementary palettes
    palettes.push(createShiftedPalette(distinctColors, 0.42));
    palettes.push(createShiftedPalette(distinctColors, 0.58));
    
    // Season-inspired shifts
    if (collection === 'ss') {
      // Spring/Summer: Shift toward yellow-green
      palettes.push(createShiftedPalette(distinctColors, 0.2));
      palettes.push(createShiftedPalette(distinctColors, 0.25));
    } else if (collection === 'aw') {
      // Autumn/Winter: Shift toward orange-red
      palettes.push(createShiftedPalette(distinctColors, -0.08));
      palettes.push(createShiftedPalette(distinctColors, -0.04));
    }
    
    // Add some random creative shifts
    for (let i = 0; i < 2; i++) {
      palettes.push(createShiftedPalette(distinctColors, Math.random()));
    }
    
    return palettes;
  }
  


async function displayColorPalette(layerIndex, colors, collection = 'trending', maxVisibleColors = 6, totalLayers = 1) {
    const prefix = collection + '_';
    const MAX_DISPLAY_COUNT = 8; // Maximum number of colors to display
    const MIN_DISPLAY_COUNT = 4; // Minimum number of colors to display
    
    // Add the provided hex palette - KEEP THIS as our first palette
    const additionalHexPalette = ["#00202e", "#003f5c", "#2c4875", "#8a508f", "#bc5090", "#ff6361", "#ff8531", "#ffa600", "#ffd380"];
    
    // Function to convert HEX to RGB
    function hexToRgb(hex) {
        // Remove the # if it exists
        hex = hex.replace(/^#/, '');
        
        // Parse the hex values
        const r = parseInt(hex.substring(0, 2), 16);
        const g = parseInt(hex.substring(2, 4), 16);
        const b = parseInt(hex.substring(4, 6), 16);
        
        return [r, g, b];
    }
    
    // Convert the hex palette to RGB - PRESERVE THIS for the first palette
    const additionalRgbPalette = additionalHexPalette.map(hex => hexToRgb(hex));
    
    // Function to keep trying to get valid colors until successful
    async function getPersistentColors(inputColors, maxAttempts = 100) {
      let validColors = [];
      let attempts = 0;
      
      // Keep trying until we get valid colors
      while (validColors.length === 0 && attempts < maxAttempts) {
        attempts++;
        
        // First try the input colors
        if (attempts === 1 && Array.isArray(inputColors)) {
          validColors = inputColors.filter(color => 
            Array.isArray(color) && 
            color.length === 3 && 
            color.every(value => typeof value === 'number' && !isNaN(value) && value >= 0 && value <= 255)
          );
        }
        
        // If we have valid colors, use them
        if (validColors.length > 0) {
          break;
        }
        
        // Try to get colors from distinctColorsArrayColorPallet
        try {
          if (typeof window.distinctColorsArrayColorPallet === 'function') {
            // Try to get as function
            const newColors = await window.distinctColorsArrayColorPallet();
            if (Array.isArray(newColors)) {
              validColors = newColors.filter(color => 
                Array.isArray(color) && 
                color.length === 3 && 
                color.every(value => typeof value === 'number' && !isNaN(value) && value >= 0 && value <= 255)
              );
            }
          } else if (window.distinctColorsArrayColorPallet) {
            // Try to get as variable
            const newColors = window.distinctColorsArrayColorPallet;
            if (Array.isArray(newColors)) {
              validColors = newColors.filter(color => 
                Array.isArray(color) && 
                color.length === 3 && 
                color.every(value => typeof value === 'number' && !isNaN(value) && value >= 0 && value <= 255)
              );
            }
          }
        } catch (e) {
          // Ignore errors and keep trying
        }
        
        // If still no valid colors, wait a bit and try again
        if (validColors.length === 0) {
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      }
      
      // If we STILL don't have valid colors after all attempts,
      // generate completely random ones (NOT from any predefined palette except the first one)
      if (validColors.length === 0) {
        // Generate completely random, unique colors
        const hues = [];
        for (let i = 0; i < 9; i++) {
          // Space hues evenly around the color wheel
          hues.push(Math.floor(i * (360 / 9)));
        }
        
        validColors = hues.map(hue => {
          // Convert HSL to RGB for each hue with good saturation and lightness
          return hslToRgb(hue, 70 + Math.random() * 30, 45 + Math.random() * 25);
        });
      }
      
      return validColors;
    }
    
    // Function to convert RGB to HEX
    function rgbToHex(r, g, b) {
      return '#' + [r, g, b].map(x => {
        const hex = x.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      }).join('');
    }
    
    // Helper functions for color manipulation
    function rgbToHsl(r, g, b) {
      try {
        r /= 255;
        g /= 255;
        b /= 255;
        
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;
        
        if (max === min) {
          h = s = 0;
        } else {
          const d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          
          switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
          }
          h /= 6;
        }
        
        return [h * 360, s * 100, l * 100];
      } catch (e) {
        // In case of error, return a random HSL value - NOT a fallback!
        return [
          Math.random() * 360,
          70 + Math.random() * 30,
          45 + Math.random() * 25
        ];
      }
    }
    
    // Calculate color difference using CIEDE2000 simplified version
    function colorDifference(rgb1, rgb2) {
      // Convert to HSL for a perceptually better difference calculation
      const hsl1 = rgbToHsl(...rgb1);
      const hsl2 = rgbToHsl(...rgb2);
      
      // Calculate differences in hue, saturation, and lightness
      let hueDiff = Math.abs(hsl1[0] - hsl2[0]);
      // Handle the color wheel wraparound
      hueDiff = Math.min(hueDiff, 360 - hueDiff);
      
      const satDiff = Math.abs(hsl1[1] - hsl2[1]);
      const lightDiff = Math.abs(hsl1[2] - hsl2[2]);
      
      // Weight the differences (hue is more important for visual distinctness)
      return hueDiff * 1.5 + satDiff + lightDiff * 1.2;
    }
    
    function hslToRgb(h, s, l) {
      try {
        h /= 360;
        s /= 100;
        l /= 100;
        
        let r, g, b;
        
        if (s === 0) {
          r = g = b = l;
        } else {
          const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1/6) return p + (q - p) * 6 * t;
            if (t < 1/2) return q;
            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
          };
          
          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          const p = 2 * l - q;
          
          r = hue2rgb(p, q, h + 1/3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1/3);
        }
        
        return [
          Math.round(r * 255),
          Math.round(g * 255),
          Math.round(b * 255)
        ];
      } catch (e) {
        // In case of error, generate a completely random RGB value - NOT a fallback!
        return [
          Math.floor(Math.random() * 256),
          Math.floor(Math.random() * 256),
          Math.floor(Math.random() * 256)
        ];
      }
    }
    
    // Generate a random number in range
    function randomInRange(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    
    // Ensure we have valid colors to work with - keep trying until successful
    const validatedColors = await getPersistentColors(colors);
    
    // Create 10 UNIQUE random palettes - BUT MAKE SURE FIRST ONE IS OUR PREDEFINED PALETTE
    async function generateRandomPalettes(baseColors) {
      const palettes = [];
      
      // IMPORTANT: Add our additionalRgbPalette as the first palette
      palettes.push([...additionalRgbPalette]);
      
      // Generate 9 more unique palettes (not 10, since we already added one)
      for (let i = 0; i < 9; i++) {
        let currentPalette = [];
        let success = false;
        let attempts = 0;
        
        // Keep trying to create a valid palette
        while (!success && attempts < 40) {
          attempts++;
          try {
            // Use different random transformations
            const hueShift = randomInRange(0, 359);
            const satFactor = 0.7 + (Math.random() * 0.6); // 0.7 to 1.3
            const lightFactor = 0.8 + (Math.random() * 0.4); // 0.8 to 1.2
            
            // Apply transformation to all colors
            currentPalette = baseColors.map((color) => {
              try {
                const [h, s, l] = rgbToHsl(...color);
                
                // Apply transformations
                const newHue = (h + hueShift) % 360;
                const newSat = Math.min(100, s * satFactor);
                const newLight = Math.min(95, Math.max(5, l * lightFactor));
                
                return hslToRgb(newHue, newSat, newLight);
              } catch (e) {
                // If transformation fails, create a new random color - NOT a fallback!
                return [
                  Math.floor(Math.random() * 256),
                  Math.floor(Math.random() * 256),
                  Math.floor(Math.random() * 256)
                ];
              }
            });
            
            // Validate the palette
            const allValid = currentPalette.every(color => 
              Array.isArray(color) && 
              color.length === 3 && 
              color.every(v => typeof v === 'number' && !isNaN(v) && v >= 0 && v <= 255)
            );
            
            if (allValid && currentPalette.length > 0) {
              success = true;
            }
          } catch (e) {
            // If error, try again
          }
        }
        
        // If we still don't have a valid palette, create completely random colors
        if (!success || currentPalette.length === 0) {
          currentPalette = [];
          for (let j = 0; j < Math.max(9, baseColors.length); j++) {
            currentPalette.push([
              Math.floor(Math.random() * 256),
              Math.floor(Math.random() * 256),
              Math.floor(Math.random() * 256)
            ]);
          }
        }
        
        palettes.push(currentPalette);
      }
      
      return palettes;
    }
    
    // Get color name to categorize colors
    function getColorName(rgb) {
      try {
        const [r, g, b] = rgb;
        
        // Convert RGB to HSV for better color categorization
        const rNorm = r / 255;
        const gNorm = g / 255;
        const bNorm = b / 255;
        const max = Math.max(rNorm, gNorm, bNorm);
        const min = Math.min(rNorm, gNorm, bNorm);
        const diff = max - min;
        
        // Calculate Hue
        let h = 0;
        if (max !== min) {
          if (max === rNorm) {
            h = (60 * ((gNorm - bNorm) / diff) + 360) % 360;
          } else if (max === gNorm) {
            h = (60 * ((bNorm - rNorm) / diff) + 120) % 360;
          } else {
            h = (60 * ((rNorm - gNorm) / diff) + 240) % 360;
          }
        }
        
        // Calculate Value (brightness)
        const v = max;
        
        // Determine hue category
        let hueName;
        if (h < 15 || h >= 345) hueName = "Red";
        else if (h >= 15 && h < 45) hueName = "Orange";
        else if (h >= 45 && h < 75) hueName = "Yellow";
        else if (h >= 75 && h < 165) hueName = "Green";
        else if (h >= 165 && h < 195) hueName = "Cyan";
        else if (h >= 195 && h < 255) hueName = "Blue";
        else if (h >= 255 && h < 285) hueName = "Purple";
        else if (h >= 285 && h < 345) hueName = "Pink";
        
        // Simplified shade prefix
        let shadePrefix = "";
        if (v < 0.4) shadePrefix = "Dark";
        else if (v > 0.7) shadePrefix = "Light";
        
        return shadePrefix ? `${shadePrefix} ${hueName}` : hueName;
      } catch (e) {
        return "Color";
      }
    }
    
    // Modified: Function to prepare display colors with one from each color family
    function prepareDisplayColors(colors) {
      // Make sure we have valid colors
      let validColors = colors.filter(color => 
        Array.isArray(color) && 
        color.length === 3 && 
        color.every(val => typeof val === 'number' && !isNaN(val) && val >= 0 && val <= 255)
      );
      
      // If no valid colors, generate new ones with good distribution
      if (validColors.length === 0) {
        validColors = [];
        for (let i = 0; i < MIN_DISPLAY_COUNT; i++) {
          // Generate colors with evenly distributed hues
          const hue = i * (360 / MIN_DISPLAY_COUNT);
          validColors.push(hslToRgb(hue, 70 + Math.random() * 30, 45 + Math.random() * 25));
        }
        return validColors;
      }
      
      // Define the color families (hue ranges)
      const colorFamilies = [
        { name: "Red", range: [345, 15] },        // Red wraps around 0
        { name: "Orange", range: [15, 45] },      // Orange
        { name: "Yellow", range: [45, 75] },      // Yellow
        { name: "Green", range: [75, 165] },      // Green
        { name: "Cyan", range: [165, 195] },      // Cyan
        { name: "Blue", range: [195, 255] },      // Blue
        { name: "Purple", range: [255, 285] },    // Purple
        { name: "Pink", range: [285, 345] }       // Pink
      ];
      
      // Categorize all colors by family
      const colorsByFamily = {};
      colorFamilies.forEach(family => {
        colorsByFamily[family.name] = [];
      });
      
      // Group colors by family
      validColors.forEach(color => {
        const [h, s, l] = rgbToHsl(...color);
        
        let foundFamily = false;
        for (const family of colorFamilies) {
          // Special case for red which wraps around 0/360
          if (family.name === "Red") {
            if (h >= family.range[0] || h < family.range[1]) {
              colorsByFamily[family.name].push(color);
              foundFamily = true;
              break;
            }
          } else if (h >= family.range[0] && h < family.range[1]) {
            colorsByFamily[family.name].push(color);
            foundFamily = true;
            break;
          }
        }
        
        // If no family found (edge case), add to closest family
        if (!foundFamily) {
          let closestFamily = colorFamilies[0];
          let minDistance = 360;
          
          for (const family of colorFamilies) {
            // Find the midpoint of the family range
            let midpoint;
            if (family.name === "Red") {
              // Red wraps around
              midpoint = (family.range[0] + family.range[1] + 360) / 2 % 360;
            } else {
              midpoint = (family.range[0] + family.range[1]) / 2;
            }
            
            // Calculate distance to midpoint, accounting for wrap-around
            let distance = Math.abs(h - midpoint);
            distance = Math.min(distance, 360 - distance);
            
            if (distance < minDistance) {
              minDistance = distance;
              closestFamily = family;
            }
          }
          
          colorsByFamily[closestFamily.name].push(color);
        }
      });
      
      // Always include the first color (may be background or most important)
      let displayColors = [validColors[0]];
      
      // Select one representative color from each family (with colors available)
      // Sort families by number of colors (descending) to prioritize families with more colors
      const sortedFamilies = Object.entries(colorsByFamily)
        .sort((a, b) => b[1].length - a[1].length)
        .filter(([_, colors]) => colors.length > 0);
      
      // Determine optimal number of colors to display
      let optimalDisplayCount = Math.min(
        MAX_DISPLAY_COUNT,
        Math.max(MIN_DISPLAY_COUNT, sortedFamilies.length + 1) // +1 for the first color
      );
      
      // Check if the first color already belongs to a family
      const [firstColorH, firstColorS, firstColorL] = rgbToHsl(...validColors[0]);
      let firstColorFamily = null;
      
      for (const family of colorFamilies) {
        if (family.name === "Red") {
          if (firstColorH >= family.range[0] || firstColorH < family.range[1]) {
            firstColorFamily = family.name;
            break;
          }
        } else if (firstColorH >= family.range[0] && firstColorH < family.range[1]) {
          firstColorFamily = family.name;
          break;
        }
      }
      
      // Select one representative from each family (excluding first color's family)
      for (const [familyName, familyColors] of sortedFamilies) {
        // Skip this family if it's the same as the first color's family
        if (familyName === firstColorFamily) continue;
        
        // If we've reached our optimal display count, break
        if (displayColors.length >= optimalDisplayCount) break;
        
        // Select the most saturated color from this family for better visibility
        let bestColor = familyColors[0];
        let highestSat = 0;
        
        for (const color of familyColors) {
          const [_, s, __] = rgbToHsl(...color);
          if (s > highestSat) {
            highestSat = s;
            bestColor = color;
          }
        }
        
        // Add the representative color from this family
        displayColors.push(bestColor);
      }
      
      // If we still don't have enough colors, add from the remaining colors
      // sorted by their perceptual distance from already selected colors
      if (displayColors.length < MIN_DISPLAY_COUNT) {
        // Flatten all colors from all families
        const allRemainingColors = validColors.filter(color => 
          !displayColors.some(c => 
            c[0] === color[0] && c[1] === color[1] && c[2] === color[2]
          )
        );
        
        // For each remaining color, calculate minimum distance to any selected color
        const colorDistances = allRemainingColors.map(color => {
          const minDistance = Math.min(...displayColors.map(selectedColor => 
            colorDifference(color, selectedColor)
          ));
          return { color, distance: minDistance };
        });
        
        // Sort by distance (descending) - most distinct colors first
        colorDistances.sort((a, b) => b.distance - a.distance);
        
        // Add colors until we reach the minimum
        for (const { color } of colorDistances) {
          displayColors.push(color);
          if (displayColors.length >= MIN_DISPLAY_COUNT) break;
        }
      }
      
      // If we still need more colors, generate completely new ones in empty hue regions
      if (displayColors.length < MIN_DISPLAY_COUNT) {
        // Find which hue regions are not represented
        const displayedHues = displayColors.map(color => rgbToHsl(...color)[0]);
        
        // Create hue "buckets" of 45 degrees each
        const hueBuckets = Array(8).fill(0);
        
        displayedHues.forEach(hue => {
          const bucketIndex = Math.floor(hue / 45) % 8;
          hueBuckets[bucketIndex]++;
        });
        
        // Generate new colors in empty buckets
        for (let i = 0; i < 8; i++) {
          if (hueBuckets[i] === 0 && displayColors.length < MIN_DISPLAY_COUNT) {
            // Generate a color in this empty hue region
            const baseHue = i * 45 + 22.5; // Middle of the bucket
            const newColor = hslToRgb(
              baseHue,
              70 + Math.random() * 30,
              45 + Math.random() * 25
            );
            displayColors.push(newColor);
          }
        }
      }
      
      return displayColors;
    }
    
    // Helper function to get distinct colors from an image
    async function getDistinctColors(imageData, maxColors = 30, quality = 10) {
      return new Promise((resolve) => {
        try {
          // Extract pixels from the image data
          const pixels = [];
          const data = imageData.data;
          const width = imageData.width;
          const height = imageData.height;
          
          // Sample pixels at intervals for better performance
          for (let y = 0; y < height; y += quality) {
            for (let x = 0; x < width; x += quality) {
              const i = (y * width + x) * 4;
              // Skip fully transparent pixels
              if (data[i+3] < 50) continue;
              
              pixels.push([data[i], data[i+1], data[i+2]]);
            }
          }
          
          // If very few pixels, just return them all
          if (pixels.length <= maxColors) {
            resolve(pixels);
            return;
          }
          
          // Use k-means clustering to find representative colors
          if (window.ColorThief && typeof window.ColorThief.getPalette === 'function') {
            try {
              const palette = window.ColorThief.getPalette(imageData, maxColors, quality);
              if (palette && palette.length > 0) {
                resolve(palette);
                return;
              }
            } catch (e) {
              console.error("ColorThief error:", e);
            }
          }
          
          // Simple fallback if ColorThief fails: just sample evenly
          const step = Math.max(1, Math.floor(pixels.length / maxColors));
          const sampledColors = [];
          for (let i = 0; i < pixels.length; i += step) {
            sampledColors.push(pixels[i]);
            if (sampledColors.length >= maxColors) break;
          }
          
          resolve(sampledColors);
        } catch (error) {
          console.error("Error in getDistinctColors:", error);
          // Return some basic colors as a fallback
          resolve([
            [0, 0, 0],
            [255, 255, 255],
            [255, 0, 0],
            [0, 255, 0],
            [0, 0, 255],
            [255, 255, 0],
            [0, 255, 255],
            [255, 0, 255]
          ]);
        }
      });
    }
    
    // New function to generate and immediately show preview
    // Modify the generateAndShowPreview function to use 1000x1000 for processing but 200x200 for display

    async function generateAndShowPreview(previewCanvas, paletteColors, paletteIndex, collection) {
      try {
        // Check cache first
        if (window.palettePreviewCache && 
            window.palettePreviewCache[collection] && 
            window.palettePreviewCache[collection][paletteIndex]) {
            
            // Use cached preview
            const cachedPreview = window.palettePreviewCache[collection][paletteIndex];
            const ctx = previewCanvas.getContext('2d', { willReadFrequently: true });
            
            // Clear with white background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
            
            return new Promise((resolve) => {
              const img = new Image();
              img.onload = () => {
                // Draw the image with proper aspect ratio (maintaining the display size of 200x200)
                const scale = Math.min(
                    previewCanvas.width / img.width,
                    previewCanvas.height / img.height
                );
                
                const scaledWidth = img.width * scale;
                const scaledHeight = img.height * scale;
                
                // Center the image
                const x = (previewCanvas.width - scaledWidth) / 2;
                const y = (previewCanvas.height - scaledHeight) / 2;
                
                // Draw the image with proper aspect ratio
                ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
                
                // Mark this preview as complete
                const container = previewCanvas.closest('.palette-clickable-container');
                if (container) {
                    container.classList.add('preview-ready');
                }
                resolve();
              };
              img.onerror = () => {
                // Draw fallback if loading fails
                drawFallbackPreview(previewCanvas, collection, paletteIndex);
                resolve();
              };
              img.src = cachedPreview;
            });
        }
        
        // No cache, create new preview
        // Get the original image
        let originalCanvas = null;
        if (totalLayers === 1) {
            originalCanvas = document.getElementById('layer_canvas_1');
        } else {
            // For multi-layer, use the specific layer
            const layerNumber = parseInt(paletteIndex) + 1;
            originalCanvas = document.getElementById(`layer_canvas_${layerNumber}`);
        }
        
        if (!originalCanvas) {
            console.error('No original canvas found for preview');
            drawFallbackPreview(previewCanvas, collection, paletteIndex);
            return;
        }
        
        // Clear the preview canvas with white background
        const ctx = previewCanvas.getContext('2d', { willReadFrequently: true });
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
        
        // IMPORTANT CHANGE: Create a higher resolution processing canvas (1000x1000)
        // but still maintain the aspect ratio of the original
        const originalAspect = originalCanvas.width / originalCanvas.height;
        
        // Create a temporary high-resolution canvas for processing
        const tempCanvas = document.createElement('canvas');
        if (originalAspect > 1) {
            // Image is wider than tall
            tempCanvas.width = 200;
            tempCanvas.height = Math.round(200 / originalAspect);
        } else {
            // Image is taller than wide
            tempCanvas.height = 200;
            tempCanvas.width = Math.round(200 * originalAspect);
        }
        
        const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
        
        // Draw original image to temp canvas at high resolution
        tempCtx.drawImage(originalCanvas, 0, 0, tempCanvas.width, tempCanvas.height);
        
        // Now get the temp canvas data for processing
        const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
        
        // Find original colors from the image
        const originalColors = await getDistinctColors(imageData, 30, 50);
        
        if (!originalColors || originalColors.length === 0) {
            console.error('No original colors found for preview');
            // Still draw the original image with correct aspect ratio in the display canvas
            const displayScale = Math.min(
                previewCanvas.width / tempCanvas.width,
                previewCanvas.height / tempCanvas.height
            );
            
            const displayWidth = tempCanvas.width * displayScale;
            const displayHeight = tempCanvas.height * displayScale;
            
            const displayX = (previewCanvas.width - displayWidth) / 2;
            const displayY = (previewCanvas.height - displayHeight) / 2;
            
            ctx.drawImage(tempCanvas, displayX, displayY, displayWidth, displayHeight);
            
            // Cache the result anyway
            cachePreview(previewCanvas, collection, paletteIndex);
            
            // Mark this preview as complete
            markPreviewReady(previewCanvas);
            return;
        }
        
        // Create color mappings
        const colorMappings = [];
        for (let i = 0; i < Math.min(originalColors.length, paletteColors.length); i++) {
            colorMappings.push({
                originalColor: originalColors[i],
                targetColor: paletteColors[i % paletteColors.length]
            });
        }
        
        // Use a simplified processor for the preview
        const colorProcessor = new ColorProcessor();
        const imageUrl = tempCanvas.toDataURL();
        
        // Process the preview at high resolution
        const processedImageUrl = await colorProcessor.applyMultipleColorMappings(
            imageUrl,
            colorMappings
        );
        
        // Load the processed image back to the preview canvas
        return new Promise((resolve) => {
          const resultImg = new Image();
          resultImg.onload = () => {
              // Draw the processed image with the correct positioning at display size (200x200)
              const displayScale = Math.min(
                  previewCanvas.width / resultImg.width,
                  previewCanvas.height / resultImg.height
              );
              
              const displayWidth = resultImg.width * displayScale;
              const displayHeight = resultImg.height * displayScale;
              
              const displayX = (previewCanvas.width - displayWidth) / 2;
              const displayY = (previewCanvas.height - displayHeight) / 2;
              
              ctx.drawImage(resultImg, displayX, displayY, displayWidth, displayHeight);
              
              // Cache the high resolution preview
              cachePreview(previewCanvas, collection, paletteIndex, processedImageUrl);
              
              // Mark this preview as complete
              markPreviewReady(previewCanvas);
              resolve();
          };
          resultImg.onerror = (e) => {
              console.error("Error loading processed preview:", e);
              drawFallbackPreview(previewCanvas, collection, paletteIndex);
              resolve();
          };
          resultImg.src = processedImageUrl;
        });
        
      } catch (error) {
        console.error("Error generating preview:", error);
        drawFallbackPreview(previewCanvas, collection, paletteIndex);
      }
    }

    // Modified cache function with safer implementation
    function cachePreview(canvas, collection, index, highResUrl) {
      // Initialize cache objects if they don't exist
      if (!window.palettePreviewCache) {
        window.palettePreviewCache = {};
      }
      
      if (!window.palettePreviewCache[collection]) {
        window.palettePreviewCache[collection] = {};
      }
      
      // Safer implementation that checks if highResUrl exists
      if (highResUrl) {
        window.palettePreviewCache[collection][index] = highResUrl;
      } else {
        window.palettePreviewCache[collection][index] = canvas.toDataURL();
      }
    }
        
    // Helper function to mark a preview as ready
    function markPreviewReady(canvas) {
      const container = canvas.closest('.palette-clickable-container');
      if (container) {
          container.classList.add('preview-ready');
      }
    }
    
    // Helper function to draw a fallback preview
    function drawFallbackPreview(canvas, collection, paletteIndex) {
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#f5f5f5';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#999';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = '14px sans-serif';
      ctx.fillText('Preview unavailable', canvas.width/2, canvas.height/2);
      
      // Cache the fallback
      cachePreview(canvas, collection, paletteIndex);
      
      // Mark as ready even though it's a fallback
      markPreviewReady(canvas);
    }
    
    // Add necessary CSS styles for the loading indicators
    if (!document.getElementById('palette-preview-styles')) {
      const styleElement = document.createElement('style');
      styleElement.id = 'palette-preview-styles';
      styleElement.textContent = `
        .palette-clickable-container {
            display: flex;
            flex-direction: column;
            cursor: pointer;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transition: transform 0.2s, box-shadow 0.2s;
            position: relative;
            width: 200px;
            margin-bottom: 15px;
        }
        
        .palette-clickable-container:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        
        .palette-preview-container {
            width: 200px;
            height: 200px;
            overflow: hidden;
            position: relative;
            background-color: white;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .palette-preview-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.7);
            z-index: 1;
        }
        
        .palette-preview-container::after {
            content: 'Loading...';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #666;
            z-index: 2;
        }
        
        .preview-ready .palette-preview-container::before,
        .preview-ready .palette-preview-container::after {
            display: none;
        }

        .palette-preview-canvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        
        .swatch-container {
            display: flex;
            justify-content: space-around;
            padding: 5px;
            background-color: #f5f5f5;
            border-top: 1px solid #ddd;
        }
        
        .color-swatch {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 1px solid #ddd;
            margin: 0 2px;
        }
        
        .ss-swatch {
            border-color: #d0d0ff;
        }
        
        .aw-swatch {
            border-color: #ffd0d0;
        }
        
        .show-all-colors-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 25px;
            height: 25px;
            background-color: rgba(255,255,255,0.8);
            color: #333;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-weight: bold;
            z-index: 3;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        
        .show-all-colors-btn:hover {
            background-color: rgba(255,255,255,0.95);
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        
        .full-palette-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.7);
        }
        
        .full-palette-modal-content {
            background-color: #fff;
            margin: 10% auto;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            width: 80%;
            max-width: 600px;
            position: relative;
        }
        
        .close-palette-modal {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .palette-modal-title {
            text-align: center;
            margin-bottom: 20px;
            color: #333;
        }
        
        .all-colors-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
        }
        
        .full-palette-color {
            width: 80px;
            height: 80px;
            border-radius: 8px;
            position: relative;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .color-info {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: rgba(0,0,0,0.6);
            color: white;
            font-size: 10px;
            padding: 3px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .full-palette-color:hover .color-info {
            opacity: 1;
        }
      `;
      document.head.appendChild(styleElement);
    }
    
    // Main processing logic for single layer - MODIFIED TO START EACH PREVIEW IMMEDIATELY
    if (totalLayers === 1) {
        // For single layer, generate 10 unique random palettes, with the first one being our predefined palette
        const randomPalettes = await generateRandomPalettes(validatedColors);
        
        // Initialize preview cache if needed
        if (!window.palettePreviewCache) {
            window.palettePreviewCache = {};
        }
        if (!window.palettePreviewCache[collection]) {
            window.palettePreviewCache[collection] = {};
        }
        
        // Create preview canvases if they don't exist
        if (!window.previewCanvases) {
            window.previewCanvases = {};
            
            // Generate a smaller version of the original image for preview
            const originalCanvas = document.getElementById('layer_canvas_1');
            if (originalCanvas) {
                const previewCanvas = document.createElement('canvas');
                previewCanvas.width = 200;
                previewCanvas.height = 200;
                const previewCtx = previewCanvas.getContext('2d', { willReadFrequently: true });
                
                // Draw the original image scaled down
                previewCtx.drawImage(originalCanvas, 0, 0, 200, 200);
                
                // Store the preview canvas data URL for future use
                window.previewCanvases['original'] = previewCanvas.toDataURL();
            }
        }
        
        // Create all palette containers first
        const paletteContainers = [];
        
        for (let i = 0; i < 10; i++) {
            const paletteContainer = document.getElementById(`${prefix}colorPalette_${i}`);
            if (!paletteContainer) continue;
            
            paletteContainer.innerHTML = '';
            
            // For the first palette (i=0), make sure we're using additionalRgbPalette
            let paletteColors = i === 0 ? [...additionalRgbPalette] : randomPalettes[i];
            
            // Verify that all colors are valid
            paletteColors = paletteColors.filter(color => 
                Array.isArray(color) && 
                color.length === 3 && 
                color.every(v => typeof v === 'number' && !isNaN(v) && v >= 0 && v <= 255)
            );
            
            // If somehow we lost all colors, generate new ones
            if (paletteColors.length === 0) {
                // Use additionalRgbPalette for first palette, generate new for others
                if (i === 0 && additionalRgbPalette.length > 0) {
                    paletteColors = [...additionalRgbPalette];
                } else {
                    // Generate new colors with good distribution
                    paletteColors = [];
                    for (let j = 0; j < 9; j++) {
                        const hue = j * (360 / 9);
                        paletteColors.push(hslToRgb(hue, 70 + Math.random() * 30, 45 + Math.random() * 25));
                    }
                }
            }
            
            // Apply collection-specific adjustments
            if (collection === 'ss') {
                paletteColors = paletteColors.map(color => {
                    try {
                        const [h, s, l] = rgbToHsl(...color);
                        return hslToRgb(h, Math.min(100, s * 1.2), Math.min(100, l * 1.1));
                    } catch (e) {
                        // Generate a bright color if adjustment fails
                        const hue = Math.random() * 360;
                        return hslToRgb(hue, 80, 65);
                    }
                });
            } else if (collection === 'aw') {
                paletteColors = paletteColors.map(color => {
                    try {
                        const [h, s, l] = rgbToHsl(...color);
                        return hslToRgb(h, s * 0.9, l * 0.85);
                    } catch (e) {
                        // Generate a muted color if adjustment fails
                        const hue = Math.random() * 360;
                        return hslToRgb(hue, 60, 45);
                    }
                });
            }
            
            // Initialize the storage if needed
            window[`${collection}PaletteColors`] = window[`${collection}PaletteColors`] || {};
            
            // Store ALL colors in the palette data structure
            window[`${collection}PaletteColors`][i] = [...paletteColors];
            
            // NEW: Create container for the palette that includes preview
            const clickableContainer = document.createElement('div');
            clickableContainer.classList.add('palette-clickable-container');
            paletteContainer.appendChild(clickableContainer);
            
            // Add data attribute to store the palette index
            clickableContainer.dataset.paletteIndex = i;
            clickableContainer.dataset.collection = collection;
            
            // NEW: Add preview image container
            const previewContainer = document.createElement('div');
            previewContainer.classList.add('palette-preview-container');
            clickableContainer.appendChild(previewContainer);
            
            // Create small preview canvas
            const previewCanvas = document.createElement('canvas');
            previewCanvas.width = 200;
            previewCanvas.height = 200;
            previewCanvas.classList.add('palette-preview-canvas');
            previewContainer.appendChild(previewCanvas);
            
            // NEW: Display the representative colors underneath the preview
            const swatchContainer = document.createElement('div');
            swatchContainer.classList.add('swatch-container');
            clickableContainer.appendChild(swatchContainer);
            
            // Prepare display colors - ONE FROM EACH COLOR FAMILY
            const displayColors = prepareDisplayColors(paletteColors);
            
            // Display color swatches under the preview
            displayColors.forEach((color, idx) => {
                const swatch = document.createElement('div');
                swatch.classList.add('color-swatch');
                swatch.style.backgroundColor = `rgb(${color.join(',')})`;
                
                // Updated tooltip with HEX value instead of RGB
                const hexValue = rgbToHex(color[0], color[1], color[2]);
                swatch.title = ` ${hexValue}`;
                
                if (collection === 'ss') {
                    swatch.classList.add('ss-swatch');
                } else if (collection === 'aw') {
                    swatch.classList.add('aw-swatch');
                }
                
                swatchContainer.appendChild(swatch);
            });
            
            // Click handler to use the FULL palette
            clickableContainer.addEventListener('click', function() {
                const paletteIndex = parseInt(this.dataset.paletteIndex, 10);
                const collectionName = this.dataset.collection;
                
                // Get the FULL palette from storage
                const fullPalette = window[`${collectionName}PaletteColors`] && 
                                  window[`${collectionName}PaletteColors`][paletteIndex];
                
                // Call processPallet with the FULL palette from storage
                if (typeof window.processPallet === 'function' && fullPalette && fullPalette.length > 0) {
                  console.log('called this')
                  console.log(collectionName)
                    window.processPallet(null, totalLayers, null, 0, null, fullPalette, paletteIndex,collectionName);
                }
            });
            
            // Add "Show All" button
            const showAllButton = document.createElement('div');
            showAllButton.classList.add('show-all-colors-btn');
            showAllButton.innerHTML = '+';
            showAllButton.title = 'Show all colors in palette';
            clickableContainer.appendChild(showAllButton);
            
            // Add event listener to show all colors in a modal
            showAllButton.addEventListener('click', function(e) {
                e.stopPropagation(); // Prevent triggering the parent container's click
                
                const fullPalette = window[`${collection}PaletteColors`][i];
                if (!fullPalette || fullPalette.length === 0) {
                    return;
                }
                
                showFullPaletteModal(fullPalette, collection, i);
            });
            
            // Store the palette info for preview generation
            paletteContainers.push({
                index: i,
                canvas: previewCanvas,
                colors: paletteColors
            });
        }
        
        // Generate previews one by one with small delays between each to avoid overloading the browser
        for (let i = 0; i < paletteContainers.length; i++) {
            const item = paletteContainers[i];
            
            // Use setTimeout to stagger the preview generation
            // This allows each preview to start loading immediately as it's ready
            setTimeout(() => {
                generateAndShowPreview(item.canvas, item.colors, item.index, collection);
            }, i * 50); // Small delay between each preview start (50ms per palette)
        }
    } else {
        // Multi-layer logic
        const paletteContainer = document.getElementById(`${prefix}colorPalette_${layerIndex}`);
        if (!paletteContainer) return;
        
        // For multi-layer, ensure first layer (layerIndex 0) is our additional palette
        let paletteColors = layerIndex === 0 ? [...additionalRgbPalette] : [...validatedColors];
        
        // Apply random transformation for non-first layers
        if (layerIndex !== 0) {
            const hueShift = randomInRange(0, 359);
            const satFactor = 0.7 + (Math.random() * 0.6);
            const lightFactor = 0.8 + (Math.random() * 0.4);
            
            paletteColors = paletteColors.map(color => {
                try {
                    const [h, s, l] = rgbToHsl(...color);
                    const newHue = (h + hueShift) % 360;
                    const newSat = Math.min(100, s * satFactor);
                    const newLight = Math.min(95, Math.max(5, l * lightFactor));
                    return hslToRgb(newHue, newSat, newLight);
                } catch (e) {
                    // Generate a new color if transformation fails
                    const hue = Math.random() * 360;
                    return hslToRgb(hue, 70, 50);
                }
            });
        }
        
        // Apply collection-specific adjustments
        if (collection === 'ss') {
            paletteColors = paletteColors.map(color => {
                try {
                    const [h, s, l] = rgbToHsl(...color);
                    return hslToRgb(h, Math.min(100, s * 1.2), Math.min(100, l * 1.1));
                } catch (e) {
                    // Generate a new bright color if adjustment fails
                    const hue = Math.random() * 360;
                    return hslToRgb(hue, 80, 65);
                }
            });
        } else if (collection === 'aw') {
            paletteColors = paletteColors.map(color => {
                try {
                    const [h, s, l] = rgbToHsl(...color);
                    return hslToRgb(h, s * 0.9, l * 0.85);
                } catch (e) {
                    // Generate a new muted color if adjustment fails
                    const hue = Math.random() * 360;
                    return hslToRgb(hue, 60, 45);
                }
            });
        }
        
        // Initialize the storage if needed
        window[`${collection}PaletteColors`] = window[`${collection}PaletteColors`] || {};
        
        // Store ALL colors in the palette data structure
        window[`${collection}PaletteColors`][layerIndex] = [...paletteColors];
        
        // Clear container first
        paletteContainer.innerHTML = '';
        
        // NEW: Create container for the palette that includes preview
        const clickableContainer = document.createElement('div');
        clickableContainer.classList.add('palette-clickable-container');
        paletteContainer.appendChild(clickableContainer);
        
        // Add data attribute to store the layer index
        clickableContainer.dataset.layerIndex = layerIndex;
        clickableContainer.dataset.collection = collection;
        
        // NEW: Add preview image container
        const previewContainer = document.createElement('div');
        previewContainer.classList.add('palette-preview-container');
        clickableContainer.appendChild(previewContainer);
        
        // Create small preview canvas - use the current layer's canvas as source
        const previewCanvas = document.createElement('canvas');
        previewCanvas.width = 200;
        previewCanvas.height = 200;
        previewCanvas.classList.add('palette-preview-canvas');
        previewContainer.appendChild(previewCanvas);
        
        // Initialize preview cache if needed
        if (!window.palettePreviewCache) {
            window.palettePreviewCache = {};
        }
        if (!window.palettePreviewCache[collection]) {
            window.palettePreviewCache[collection] = {};
        }
        
        // Find the layer's canvas
        const layerCanvas = document.getElementById(`layer_canvas_${layerIndex+1}`);
        if (layerCanvas) {
            // Create preview canvases for this layer if they don't exist
            if (!window.previewCanvases) {
                window.previewCanvases = {};
            }
            
            // Generate a smaller version of this layer for preview
            if (!window.previewCanvases[`layer_${layerIndex+1}`]) {
                const previewLayerCanvas = document.createElement('canvas');
                previewLayerCanvas.width = 200;
                previewLayerCanvas.height = 200;
                const previewLayerCtx = previewLayerCanvas.getContext('2d', { willReadFrequently: true });
                
                // Draw the layer image scaled down
                previewLayerCtx.drawImage(layerCanvas, 0, 0, 200, 200);
                
                // Store the preview layer data URL
                window.previewCanvases[`layer_${layerIndex+1}`] = previewLayerCanvas.toDataURL();
            }
        }
        
        // NEW: Display the representative colors underneath the preview
        const swatchContainer = document.createElement('div');
        swatchContainer.classList.add('swatch-container');
        clickableContainer.appendChild(swatchContainer);
        
        // Prepare display colors - ONE FROM EACH COLOR FAMILY
        const displayColors = prepareDisplayColors(paletteColors);
        
        // Display color swatches under the preview
        displayColors.forEach((color, idx) => {
            const swatch = document.createElement('div');
            swatch.classList.add('color-swatch');
            swatch.style.backgroundColor = `rgb(${color.join(',')})`;
            
            // Updated tooltip with HEX value instead of RGB
            const hexValue = rgbToHex(color[0], color[1], color[2]);
            swatch.title = `Color ${idx+1}: ${getColorName(color)} - ${hexValue}`;
            
            if (collection === 'ss') {
                swatch.classList.add('ss-swatch');
            } else if (collection === 'aw') {
                swatch.classList.add('aw-swatch');
            }
            
            swatchContainer.appendChild(swatch);
        });
        
        // Add click handler to use the FULL palette when clicked
        clickableContainer.addEventListener('click', function() {
            const layerIdx = parseInt(this.dataset.layerIndex, 10);
            const collectionName = this.dataset.collection;
            
            // Get the FULL palette from storage
            const fullPalette = window[`${collectionName}PaletteColors`] && 
                               window[`${collectionName}PaletteColors`][layerIdx];
            
            // Call processPallet with the FULL palette
            if (typeof window.processPallet === 'function' && fullPalette && fullPalette.length > 0) {
                window.processPallet(null, totalLayers, null, layerIdx, null, fullPalette, layerIdx);
            }
        });
        
        // Add "Show All" button for the multi-layer case
        const showAllButton = document.createElement('div');
        showAllButton.classList.add('show-all-colors-btn');
        showAllButton.innerHTML = '+';
        showAllButton.title = 'Show all colors in palette';
        clickableContainer.appendChild(showAllButton);
        
        // Add event listener to show all colors in a modal
        showAllButton.addEventListener('click', function(e) {
            e.stopPropagation(); // Prevent triggering the parent container's click
            
            const fullPalette = window[`${collection}PaletteColors`][layerIndex];
            if (!fullPalette || fullPalette.length === 0) {
                return;
            }
            
            showFullPaletteModal(fullPalette, collection, layerIndex);
        });
        
        // Start generating the preview immediately
        generateAndShowPreview(previewCanvas, paletteColors, layerIndex, collection);
    }
}

// Modal function for showing all palette colors
function showFullPaletteModal(palette, collection, paletteIndex) {
  // Create and append modal elements if they don't exist
  let modal = document.getElementById('full-palette-modal');
  
  if (!modal) {
      modal = document.createElement('div');
      modal.id = 'full-palette-modal';
      modal.classList.add('full-palette-modal');
      
      const modalContent = document.createElement('div');
      modalContent.classList.add('full-palette-modal-content');
      
      const closeBtn = document.createElement('span');
      closeBtn.classList.add('close-palette-modal');
      closeBtn.innerHTML = '&times;';
      
      const modalTitle = document.createElement('h3');
      modalTitle.classList.add('palette-modal-title');
      
      const colorsContainer = document.createElement('div');
      colorsContainer.classList.add('all-colors-container');
      
      modalContent.appendChild(closeBtn);
      modalContent.appendChild(modalTitle);
      modalContent.appendChild(colorsContainer);
      modal.appendChild(modalContent);
      
      document.body.appendChild(modal);
      
      // Add event listener to close button
      closeBtn.addEventListener('click', function() {
          modal.style.display = 'none';
      });
      
      // Close modal when clicking outside content
      window.addEventListener('click', function(event) {
          if (event.target === modal) {
              modal.style.display = 'none';
          }
      });
  }
  
  // Update modal content with current palette
  const modalTitle = modal.querySelector('.palette-modal-title');
  const colorsContainer = modal.querySelector('.all-colors-container');
  
  modalTitle.textContent = `Full Palette (${collection.toUpperCase()} #${paletteIndex+1})`;
  colorsContainer.innerHTML = '';
  
  // Add all colors to the modal
  palette.forEach((color, index) => {
      const colorBox = document.createElement('div');
      colorBox.classList.add('full-palette-color');
      colorBox.style.backgroundColor = `rgb(${color.join(',')})`;
      
      // Add color information
      const colorInfo = document.createElement('div');
      colorInfo.classList.add('color-info');
      colorInfo.textContent = `#${index+1}: RGB(${color.join(',')})`;
      colorBox.appendChild(colorInfo);
      
      colorsContainer.appendChild(colorBox);
  });
  
  // Show the modal
  modal.style.display = 'block';
}


async function processPreviewQueue() {
  // Check if queue exists
  if (typeof window.previewQueue === 'undefined') {
    window.isProcessingPreviewQueue = false;
    return;
  }
  
  // Check if queue is empty
  if (window.previewQueue.length === 0) {
    window.isProcessingPreviewQueue = false;
    return;
  }
  
  window.isProcessingPreviewQueue = true;
  
  // Take the next preview from the queue
  const nextPreview = window.previewQueue.shift();
  
  try {
    // Generate this preview
    await generatePreview(
      nextPreview.previewCanvas, 
      nextPreview.paletteColors, 
      nextPreview.paletteIndex, 
      nextPreview.collection
    );
  } catch (error) {
    console.error("Error processing preview in queue:", error);
  }
  
  // Small delay to prevent UI freezing
  await new Promise(resolve => setTimeout(resolve, 50));
  
  // Process the next preview in the queue
  processPreviewQueue();
}








    
      function loadZoomValue(){
        //document.getElementById('zoomWrapper').style.transform = `scale(${0.072})`;
        document.getElementById('zoomWrapper').style.transform = `scale(${0.3})`;
      }
      document.addEventListener('DOMContentLoaded', loadZoomValue);
      document.getElementById('zoomSlider').addEventListener('input', function() {
        const zoomLevel = this.value / 100;
        //const zoomLevel = 0.3;

        document.getElementById('zoomWrapper').style.transform = `scale(${zoomLevel})`;
      });

      function toggleLayer(layerIndex) {
        const layerDiv = document.getElementById(`layer_${layerIndex}`);
        const checkbox = document.getElementById(`toggleLayer${layerIndex}`);
        layerDiv.style.display = checkbox.checked ? 'block' : 'none';
      }

      // Analyze the image data to calculate layer-specific parameters
      function analyzeImageLayer(ctx) {
        const imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
        const data = imageData.data;

        let totalLightness = 0;
        let totalHue = 0;
        let pixelCount = 0;

        const hues = [];

        for (let i = 0; i < data.length; i += 4) {
            // Ignore fully transparent pixels
            if (data[i + 3] === 0) continue;

            const rgb = [data[i], data[i + 1], data[i + 2]];
            const hsl = rgbToHsl(rgb[0], rgb[1], rgb[2]);

            totalLightness += hsl[2];
            totalHue += hsl[0];
            hues.push(hsl[0]);
            pixelCount++;
        }

        // Handle cases where no valid pixels were processed
        if (pixelCount === 0) {
            return {
                avgLightness: 0,
                avgHue: 0,
                hueRange: 0,
                lightnessTolerance: 0,
                hueTolerance: 0,
            };
        }

        const avgLightness = totalLightness / pixelCount;
        const avgHue = totalHue / pixelCount;

        let hueRange = calculateHueRange(hues);

        const lightnessTolerance = Math.min(0.5, avgLightness * 0.5); // Adjusted scaling
        const hueTolerance = Math.min(40, hueRange * 0.5);            // Adjusted scaling

        return {
            avgLightness,
            avgHue,
            hueRange,
            lightnessTolerance,
            hueTolerance,
        };
      }

      function analyzeImageLayerforsingle(ctx) {
         const imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
         const data = imageData.data;

         let totalLightness = 0;
         let totalHue = 0;
         let pixelCount = 0;

         const hues = [];

         for (let i = 0; i < data.length; i += 4) {
             // Ignore fully transparent pixels
             if (data[i + 3] === 0) continue;

             const rgb = [data[i], data[i + 1], data[i + 2]];
             const hsl = rgbToHslforsingle(rgb[0], rgb[1], rgb[2]);

             totalLightness += hsl[2];
             totalHue += hsl[0];
             hues.push(hsl[0]);
             pixelCount++;
         }

         // Handle cases where no valid pixels were processed
         if (pixelCount === 0) {
             //console.warn("No valid pixels found in layer.");
             return {
                 avgLightness: 0,
                 avgHue: 0,
                 hueRange: 0,
                 lightnessTolerance: 0,
                 hueTolerance: 0,
             };
         }

         const avgLightness = totalLightness / pixelCount;
         const avgHue = totalHue / pixelCount;

         // Calculate hue range only if there are hues available
         //const hueRange = hues.length > 0 ? Math.max(...hues) - Math.min(...hues) : 0;
         let hueRange = calculateHueRangeforsingle(hues);



         const lightnessTolerance = Math.min(0.7, avgLightness / 2); // Scaled by avgLightness
         const hueTolerance = Math.min(47, hueRange / 2);            // Scaled by hue range


         return {
             avgLightness,
             avgHue,
             hueRange,
             lightnessTolerance,
             hueTolerance,
         };
       }
      function rgbToHsl(r, g, b) {
        r /= 255; g /= 255; b /= 255;
        const max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;

        if (max === min) {
            h = s = 0; // achromatic
        } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r:
                    h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
                    break;
                case g:
                    h = ((b - r) / d + 2) / 6;
                    break;
                case b:
                    h = ((r - g) / d + 4) / 6;
                    break;
            }
        }
        return [h, s, l];
      }

      function hslToRgb(h, s, l) {
        let r, g, b;

        if (s === 0) {
            r = g = b = l; // achromatic
        } else {
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1; if (t > 1) t -= 1;
                if (t < 1 / 6) return p + (q - p) * 6 * t;
                if (t < 1 / 2) return q;
                if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                return p;
            };
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
        }

        return [r, g, b];
      }


      // Function to convert RGB to HSL





      function rgbToHslforsingle(r, g, b) {
    r /= 255;
    g /= 255;
    b /= 255;

    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;

    if (max === min) {
        h = s = 0; // Achromatic
    } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

        switch (max) {
            case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
            case g:
                h = (b - r) / d + 2;
                break;
            case b:
                h = (r - g) / d + 4;
                break;
        }

        h /= 6;
    }

    return [h, s, l];
}

function hslToRgbforsingle(h, s, l) {
    let r, g, b;

    if (s === 0) {
        r = g = b = l; // Achromatic
    } else {
        const hue2rgb = function (p, q, t) {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
        };

        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
    }

    return [r * 255, g * 255, b * 255];
}

   function calculateHueRange(hues) {
        if (hues.length === 0) return 0;

        // Convert hues to degrees (0 to 360)
        const huesInDegrees = hues.map(h => h * 360);

        // Sort hues
        huesInDegrees.sort((a, b) => a - b);

        // Calculate differences between adjacent hues
        let maxDiff = 0;
        for (let i = 0; i < huesInDegrees.length - 1; i++) {
            const diff = huesInDegrees[i + 1] - huesInDegrees[i];
            if (diff > maxDiff) maxDiff = diff;
        }

        // Include wrap-around difference
        const wrapAroundDiff = 360 - huesInDegrees[huesInDegrees.length - 1] + huesInDegrees[0];
        if (wrapAroundDiff > maxDiff) maxDiff = wrapAroundDiff;

        return maxDiff;
      }

      function calculateHueRangeforsingle(hues) {
         if (hues.length === 0) return 0;

         let maxHue = -Infinity;
         let minHue = Infinity;

         for (let hue of hues) {
             if (hue > maxHue) maxHue = hue;
             if (hue < minHue) minHue = hue;
         }

         return maxHue - minHue;
       }
       function getDistinctColors(imageData, threshold = 30, maxColors = 50, minDistance = 30) {
        const totalLayers = {{ layers|length }};
        const uniqueColors = new Map(); // Changed to Map to track counts
        const data = imageData.data;
        const isSingleLayer = totalLayers === 1;
    
        // First pass: collect all unique colors and count occurrences
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            const a = data[i + 3];
    
            // Skip fully transparent pixels
            if (a === 0) continue;
            // Skip near-black colors (more lenient check)
            if (r < 15 && g < 15 && b < 15) continue;
            
            const colorKey = `${r},${g},${b}`;
            if (uniqueColors.has(colorKey)) {
                uniqueColors.set(colorKey, uniqueColors.get(colorKey) + 1);
            } else {
                uniqueColors.set(colorKey, 1);
            }
        }
    
        // Convert to array and map to RGB arrays with counts
        const colors = Array.from(uniqueColors.entries()).map(([colorStr, count]) => {
            const [r, g, b] = colorStr.split(',').map(Number);
            return {
                rgb: [r, g, b],
                count: count,
                // Add HSL values to help with diversity
                hsl: rgbToHsl(r, g, b)
            };
        });
    
        console.log('Total unique colors found:', colors.length);
    
        // Sort colors by count (frequency) in descending order
        colors.sort((a, b) => b.count - a.count);
        
        // Collect distinct colors directly, applying the minimum distance requirement
        const distinctColors = [];
        
        // Always include the most frequent color
        if (colors.length > 0) {
            distinctColors.push(colors[0].rgb);
        }
        
        // For all remaining colors, check if they meet the minimum distance requirement
        for (let i = 1; i < colors.length && distinctColors.length < maxColors; i++) {
            const candidate = colors[i].rgb;
            let isDistinct = true;
            
            for (const existingColor of distinctColors) {
                const distance = colorDistance(candidate, existingColor);
                if (distance < minDistance) {
                    isDistinct = false;
                    break;
                }
            }
            
            if (isDistinct) {
                distinctColors.push(candidate);
            }
        }
        
        console.log('Final distinct colors:', distinctColors.length);
        localStorage.setItem('distinctColorsArrayColorPallet', JSON.stringify(distinctColors));
        return distinctColors;
    }
    
    function colorDistance(c1, c2) {
        return Math.sqrt(
            Math.pow(c1[0] - c2[0], 2) +
            Math.pow(c1[1] - c2[1], 2) +
            Math.pow(c1[2] - c2[2], 2)
        );
    }
        function generateUniqueRGBColorArray(count) {
            const colors = [];
        
            while (colors.length < count) {
                const r = Math.floor(Math.random() * 256);
                const g = Math.floor(Math.random() * 256);
                const b = Math.floor(Math.random() * 256);
        
                const isGreenish = (g > r && g > b);
                const isDuplicate = colors.some(color => color[0] === r && color[1] === g && color[2] === b);
        
                if (!isGreenish && !isDuplicate) {
                    colors.push([r, g, b]);
                }
            }
        
            return colors;
        }
    
    function generateUniqueRGBColorArray(count) {
        const colors = [];
    
        while (colors.length < count) {
            const r = Math.floor(Math.random() * 256);
            const g = Math.floor(Math.random() * 256);
            const b = Math.floor(Math.random() * 256);
    
            const isGreenish = (g > r && g > b);
            const isDuplicate = colors.some(color => color[0] === r && color[1] === g && color[2] === b);
    
            if (!isGreenish && !isDuplicate) {
                colors.push([r, g, b]);
            }
        }
    
        return colors;
    }

      function showLayerInfo() {
        contextMenu.style.display = 'none';
        $('#colorPickerModal').modal('show');
        const layerIndex = contextMenu.dataset.layerIndex; // Assuming contextMenu is defined

        updateLayersWithNewColorCount(layerIndex);
      }

async function processLayerAsync(ctx, targetColor, newColor, minAreaThreshold = 1, maxSkipCount = 5) {
    return new Promise(async (resolve) => {
        const colorProcessor = new ColorProcessor();
        const canvasId = ctx.canvas.id;
        const layerIndex = parseInt(canvasId.replace('layer_canvas_', ''));
        const imageDataUrl = ctx.canvas.toDataURL();
        console.log('Processing layer:', layerIndex, 'with target color:', targetColor, 'and new color:', newColor);

        try {
            const colorMapping = await colorProcessor.getColorMapping(imageDataUrl);
            // CORRECTED: Swap parameter order here
            const processedImageUrl = await colorProcessor.applyColorMapping(
                imageDataUrl,
                colorMapping,
                targetColor,  // Original color to replace (now first)
                newColor      // New color to apply (now second)
            );

            const img = new Image();
            img.onload = () => {
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                ctx.drawImage(img, 0, 0);
                updateFooterColorButton(layerIndex, newColor);
                resolve();
            };
            img.src = processedImageUrl;
        } catch (error) {
            console.error('Error processing layer:', error);
            resolve();
        }
    });
}
// Helper function to check if a color is locked
function isColorLocked(color, layerIndex) {
    // Implement this based on how you store locked colors
    // For example:
    if (window.lockedColors && window.lockedColors[layerIndex]) {
        return window.lockedColors[layerIndex].some(lockedColor => 
            Math.abs(color[0] - lockedColor[0]) < 5 &&
            Math.abs(color[1] - lockedColor[1]) < 5 &&
            Math.abs(color[2] - lockedColor[2]) < 5
        );
    }
    return false;
}
function updateLayersWithNewColorCount(layerIndex) {
  console.info("layerIndex: " + layerIndex);
  const layerIndexCount = layerIndex - 1;
  const sliderValue = document.getElementById('color-count-slider').value;
  const totalLayers = {{ layers|length }};
  const layers = {{ layers|safe }};

  let distinctColorTolerance = totalLayers > 5 ? 180 : 200;
  let layer = layers[layerIndexCount];
  let canvas = document.getElementById('layer_canvas_' + layerIndex);
  
  // If no canvas found, return early
  if (!canvas) return;

  let ctx = canvas.getContext('2d', { willReadFrequently: true });
  let latestImageData = null;

  // Get current canvas state if it exists
  const currentState = canvas.getAttribute('data-current-state');
  const img = new Image();
  
  img.onload = function() {
      const colorPickerContainer = document.getElementById('color-pickers');
      colorPickerContainer.innerHTML = '';
      
      // Preserve canvas dimensions
      const originalWidth = canvas.width;
      const originalHeight = canvas.height;
      canvas.width = img.width || originalWidth;
      canvas.height = img.height || originalHeight;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0);

      // Save the current state
      layerStates.saveEditedState(layerIndex);

      latestImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const distinctColors = getDistinctColors(imageData, 30, 50);

      console.log('Processing colors for layer:', layerIndex);

      distinctColors.forEach((color, index) => {
          const button = document.createElement('button');
          button.className = 'color-picker';
          button.style.backgroundColor = `rgb(${color.join(',')})`;
          colorPickerContainer.appendChild(button);

          const pickr = Pickr.create({
              el: button,
              theme: 'nano',
              default: `rgb(${color.join(',')})`,
              components: {
                  preview: true,
                  opacity: true,
                  hue: true,
                  interaction: {
                      rgba: true,
                      input: true,
                      hsla: true,
                      save: true,
                  }
              }
          });

          let isProcessing = false;


        pickr.on('save', async (newColor) => {
          if (isProcessing) return;
          isProcessing = true;

          try {
              const rgbaColor = newColor.toRGBA().map(v => Math.round(v));
              // Store the original target color when the picker is created
              // This way, even if distinctColors changes, we keep the original reference
              const currentTargetColor = [...color]; // Use a copy of the original color
              
              // Save state before processing
              layerStates.saveEditedState(layerIndex);
              const rgbColor = rgbaColor.slice(0, 3);
              await processLayerAsync(ctx, currentTargetColor, rgbColor);
              
              // Update UI elements
              updateFooterColorButton(layerIndex, rgbaColor);
              button.style.backgroundColor = `rgba(${rgbaColor.join(',')})`;
              
              // Update the specific color in distinctColors
              distinctColors[index] = rgbaColor.slice(0, 3);
              
              // Update latest image data
              latestImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
              ctx.putImageData(latestImageData, 0, 0);

              // Save the new state after processing
              canvas.setAttribute('data-current-state', canvas.toDataURL());
              
              pickr.hide();
          } catch (error) {
              console.error('Error processing color change:', error);
          } finally {
              setTimeout(() => {
                  isProcessing = false;
              }, 100);
          }
        });

          // Add change event to update preview in real-time
          pickr.on('change', (color) => {
              button.style.backgroundColor = color.toRGBA().toString();
          });
      });
  };

  // Load appropriate image source
  if (currentState) {
      img.src = currentState;
  } else {
      img.src = layer.path;
      // Save original state if it hasn't been saved yet
      if (!layerStates.hasOriginalState(layerIndex)) {
          layerStates.saveOriginalState(layerIndex);
      }
  }

  img.onerror = function(error) {
      console.error('Error loading image:', error);
  };
}
      
      function changeHueWithHueAndLightnessTolerance(ctx, targetColor, newColor, hueTolerance, lightnessTolerance) {
        console.info('Processing Layer with target color:', targetColor, 'and new color:', newColor);
        const canvasWidth = ctx.canvas.width;
        const canvasHeight = ctx.canvas.height;
        const imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
        const data = imageData.data;

        // Convert target and new colors to HSL
        const targetHsl = rgbToHsl(...targetColor);
        const newHsl = rgbToHsl(...newColor);

        // Normalize hue tolerance to fraction (since hue is between 0 and 1 in HSL)
        //const hueToleranceFraction = hueTolerance / 360;
        const hueToleranceFraction = Math.max(0.05, hueTolerance / 360); // Minimum 5% tolerance
        //const lightnessTolerance = Math.max(0.1, lightnessTolerance);   // Minimum 10% tolerance

        for (let i = 0; i < data.length; i += 4) {
            const currentColor = [data[i], data[i + 1], data[i + 2]];
            const currentHsl = rgbToHsl(...currentColor);

            // Calculate hue and lightness differences
            let hueDiff = Math.abs(currentHsl[0] - targetHsl[0]);
            if (hueDiff > 0.5) hueDiff = 1 - hueDiff; // Wrap-around for hue differences
            const lightnessDiff = Math.abs(currentHsl[2] - targetHsl[2]);
            //console.log(`Pixel ${i / 4}: Matches Tolerance (HueDiff: ${hueDiff}, LightnessDiff: ${lightnessDiff})`);
            // Check if the pixel's hue and lightness are within tolerance range
            if (hueDiff <= hueToleranceFraction && lightnessDiff <= lightnessTolerance) {
                //const blendedRgb = hslToRgb(newHsl[0], currentHsl[1], currentHsl[2]);
                const blendedRgb = hslToRgb(newHsl[0], currentHsl[1], currentHsl[2]);

                // Scale RGB values to 0-255 and assign to data array
                data[i] = Math.round(blendedRgb[0] * 255);
                data[i + 1] = Math.round(blendedRgb[1] * 255);
                data[i + 2] = Math.round(blendedRgb[2] * 255);
            }
        }

        ctx.putImageData(imageData, 0, 0);
      }



      {% comment %} fav section starts  {% endcomment %}

// Add this to your existing JavaScript file
function toggleFavorite(button, collection) {
  const paletteType = button.dataset.paletteType;
  const colorsId = button.dataset.colorsId;
  const icon = button.querySelector('i');
  const countSpan = button.querySelector('.fav-count');
  
  // Get the colors from the stored palette
  const colors = window[`${collection}PaletteColors`][colorsId];
  
  if (!colors) {
      console.error('No colors found for this palette');
      return;
  }

  const paletteData = {
      name: `${collection.toUpperCase()} Palette ${colorsId}`,
      type: paletteType,
      base_color_r: colors[0][0],
      base_color_g: colors[0][1],
      base_color_b: colors[0][2],
      num_colors: colors.length,
      colors: colors.map(color => ({
          red: color[0],
          green: color[1],
          blue: color[2]
      }))
  };

  if (icon.classList.contains('bi-heart')) {
      // Add to favorites
      savePalette(paletteData, button);
  } else {
      // Remove from favorites
      removePalette(button.dataset.paletteId);
  }
}

// Helper function to get CSRF token from cookies
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

async function savePalette(paletteData, button) {
  try {
      const response = await fetch('api/palettes/favorite/', {
          method: 'POST',
          headers: {
              'Content-Type': 'application/json',
              'X-CSRFToken': getCookie('csrftoken')
          },
          body: JSON.stringify(paletteData)
      });

      const data = await response.json();
      
      if (response.ok) {
          const icon = button.querySelector('i');
          const countSpan = button.querySelector('.fav-count');
          
          icon.classList.remove('bi-heart');
          icon.classList.add('bi-heart-fill');
          button.dataset.paletteId = data.palette_id;
          countSpan.textContent = data.favorites_count;
          
          // Refresh favorites section
          loadFavorites();
      }
  } catch (error) {
      console.error('Error saving palette:', error);
  }
}

async function removePalette(paletteId) {
  try {
      const response = await fetch(`api/palettes/favorite/${paletteId}/`, {
          method: 'DELETE',
          headers: {
              'X-CSRFToken': getCookie('csrftoken')
          }
      });

      if (response.ok) {
          const button = document.querySelector(`[data-palette-id="${paletteId}"]`);
          const icon = button.querySelector('i');
          const countSpan = button.querySelector('.fav-count');
          
          icon.classList.remove('bi-heart-fill');
          icon.classList.add('bi-heart');
          delete button.dataset.paletteId;
          
          const data = await response.json();
          countSpan.textContent = data.favorites_count;
          
          // Refresh favorites section
          loadFavorites();
      }
  } catch (error) {
      console.error('Error removing palette:', error);
  }
}

async function loadFavorites() {
    try {
        const response = await fetch('/tif-editor/api/palettes/favorites/');
        if (!response.ok) throw new Error(`Failed to load favorites`);
        
        const favorites = await response.json();
        const favContainer = document.querySelector('#favCollectionContent .layer-toggles');
        favContainer.innerHTML = '';

        if (favorites.length === 0) {
            showNoFavoritesMessage(0, "You haven't saved any favorite palettes yet.");
            return;
        }

        // Initialize storage for favorite palette colors
        window.favPaletteColors = {};

        favorites.forEach((favorite, index) => {
            // Convert color objects to RGB arrays
            const colors = favorite.colors.map(color => [color.red, color.green, color.blue]);
            
            // Store the full palette
            window.favPaletteColors[index] = colors;
            
            // Create palette HTML
            const paletteHtml = `
                <div class="layer-toggle-item d-flex flex-column gap-2">
                    <div id="fav_colorPalette_${index}" class="color-palette d-flex flex-column"></div>
                    <div class="d-flex align-items-center justify-content-between w-100">
                        <button id="fav_shufflePalette_${index}" class="btn btn-sm btn-primary">
                            <i class="bi bi-shuffle"></i>
                        </button>
                        <button type="button" class="btn favorite-btn active" data-palette-id="${favorite.id}">
                            <i class="bi bi-heart-fill"></i>
                            <span class="fav-count">${favorite.favorites_count}</span>
                        </button>
                        <button type="button" id="fav_applyButton_${index}" class="btn btn-success">
                            <i class="bi bi-magic"></i>
                        </button>
                    </div>
                    <div class="text-center small">${favorite.name}</div>
                </div>
            `;
            
            favContainer.insertAdjacentHTML('beforeend', paletteHtml);
            
            // Display the palette (showing max 6 colors for display)
            const displayColors = colors.slice(0, 6);
            displayColorPalette(index, displayColors, 'fav', 4, 1);
            
            // Add event listeners
            document.getElementById(`fav_shufflePalette_${index}`).addEventListener('click', () => {
                displayColorPalette(index, colors, 'fav', 4, 1);
            });
            
            document.getElementById(`fav_applyButton_${index}`).addEventListener('click', () => {
              if (typeof window.processPallet === 'function') {
                // Get colors specifically from the favPaletteColors collection
                console.log('this clicked')
                const baseColors = window.favPaletteColors[index];
                
                if (!baseColors || baseColors.length === 0) {
                  console.error(`No colors found for favorite palette ${index}`);
                  return;
                }
                
                console.log(`Applying favorite palette ${index} with ${baseColors.length} base colors`);
                
                // Generate a complete palette from the favorite colors
                const fullPalette = regenerateFullPaletteFromFavorite(baseColors);
                console.log(`Generated full palette:`, fullPalette);
                
                // Store the generated palette
                if (!window.favGeneratedPalettes) {
                  window.favGeneratedPalettes = {};
                }
                window.favGeneratedPalettes[index] = fullPalette;
                
                // Pass the full palette directly to processPallet with a special identifier
                window.processPallet(null, 1, null, 0, null, fullPalette,'fav', index);
              }
            });
        });
    } catch (error) {
        console.error('Error loading favorites:', error);
        showErrorMessage(`Failed to load favorites: ${error.message}`);
    }
}
// Function to remove a favorite
function removeFavorite(button, index) {
    const paletteId = button.dataset.paletteId;
    
    if (!paletteId) {
        console.error('No palette ID found');
        return;
    }
    
    fetch(`/tif-editor/api/palettes/favorite/${paletteId}/`, {
        method: 'DELETE',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken'),
        }
    })
    .then(response => {
        if (!response.ok) {
            return response.json().then(err => { 
                throw new Error(err.error || 'Request failed');
            });
        }
        return response.json();
    })
    .then(data => {
        console.log('Favorite removed:', data);
        
        // Remove the palette from the UI
        const paletteElement = button.closest('.layer-toggle-item');
        if (paletteElement) {
            paletteElement.remove();
        }
        
        // Check if we need to show the "no favorites" message
        const favContainer = document.querySelector('#favCollectionContent .layer-toggles');
        if (favContainer && favContainer.children.length === 0) {
            const numLayers = document.querySelectorAll('[id^="layer_canvas_"]').length || 1;
            showNoFavoritesMessage(numLayers);
        }
    })
    .catch(error => {
        console.error('Error removing favorite:', error);
        alert('Error removing favorite: ' + error.message);
    });
}

// Helper function to show "no favorites" message
function showNoFavoritesMessage(numLayers, customMessage = null) {
    const favContainer = document.querySelector('#favCollectionContent .layer-toggles');
    if (favContainer) {
        const message = customMessage || `No favorite palettes found matching ${numLayers} layers.`;
        
        favContainer.innerHTML = `
            <div class="alert alert-info text-center w-100">
                <i class="bi bi-info-circle me-2"></i>
                ${message}
                <br>
                <small class="text-muted">Save some palettes from the Trending section to see them here.</small>
            </div>
        `;
    }
}

// Helper function to show error message
function showErrorMessage(message) {
    const favContainer = document.querySelector('#favCollectionContent .layer-toggles');
    if (favContainer) {
        favContainer.innerHTML = `
            <div class="alert alert-danger text-center w-100">
                <i class="bi bi-exclamation-triangle me-2"></i>
                ${message}
            </div>
        `;
    }
}

// Initialize favorites on page load
document.addEventListener('DOMContentLoaded', function() {
    // Find all sidebar navigation links
    const sidebarLinks = document.querySelectorAll('.sidebar-nav a');
    
    // Add click handlers to them
    sidebarLinks.forEach(link => {
        link.addEventListener('click', function(e) {
            // Get the target content ID from the href attribute
            const targetId = this.getAttribute('href').substring(1);
            
            // If it's the favorites tab, load the favorites
            if (targetId === 'favCollectionContent') {
                loadFavorites();
            }
        });
    });
    
    // If favorites tab is active by default, load favorites
    const activeSidebarLink = document.querySelector('.sidebar-nav a.active');
    if (activeSidebarLink && activeSidebarLink.getAttribute('href') === '#favCollectionContent') {
        loadFavorites();
    }
});

// Helper function to get CSRF token
function getCookie(name) {
  let cookieValue = null;
  if (document.cookie && document.cookie !== '') {
      const cookies = document.cookie.split(';');
      for (let i = 0; i < cookies.length; i++) {
          const cookie = cookies[i].trim();
          if (cookie.substring(0, name.length + 1) === (name + '=')) {
              cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
              break;
          }
      }
  }
  return cookieValue;
}

// Load favorites when the page loads
document.addEventListener('DOMContentLoaded', loadFavorites);

      {% comment %} fav sections ends  {% endcomment %}
      
      function changeHueWithHueAndLightnessTolerance(ctx, targetColor, newColor, hueTolerance, lightnessTolerance) {
  console.info('Processing Layer with target color:', targetColor, 'and new color:', newColor);
  const canvasWidth = ctx.canvas.width;
  const canvasHeight = ctx.canvas.height;
  const imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
  const data = imageData.data;

  // Convert target and new colors to HSL
  const targetHsl = rgbToHsl(...targetColor);
  const newHsl = rgbToHsl(...newColor);

  // Normalize hue tolerance to fraction (since hue is between 0 and 1 in HSL)
  const hueToleranceFraction = hueTolerance / 360; // Strict hue tolerance
  const lightnessTolerance1 = Math.max(0.05, lightnessTolerance); // Minimum 5% lightness tolerance
  const minSaturation = 0.1; // Minimum saturation threshold

  for (let i = 0; i < data.length; i += 4) {
    const currentColor = [data[i], data[i + 1], data[i + 2]];
    const currentHsl = rgbToHsl(...currentColor);

    // Skip desaturated colors
    if (currentHsl[1] < minSaturation) continue;

    // Calculate hue and lightness differences
    let hueDiff = Math.abs(currentHsl[0] - targetHsl[0]);
    if (hueDiff > 0.5) hueDiff = 1 - hueDiff; // Wrap-around for hue differences
    const lightnessDiff = Math.abs(currentHsl[2] - targetHsl[2]);

    // Check if the pixel's hue and lightness are within tolerance range
    if (hueDiff <= hueToleranceFraction && lightnessDiff <= lightnessTolerance1) {
      const blendedRgb = hslToRgb(newHsl[0], currentHsl[1], currentHsl[2]);

      // Scale RGB values to 0-255 and assign to data array
      data[i] = Math.round(blendedRgb[0] * 255);
      data[i + 1] = Math.round(blendedRgb[1] * 255);
      data[i + 2] = Math.round(blendedRgb[2] * 255);
    }
  }

  ctx.putImageData(imageData, 0, 0);
}


function updateColorCountDisplay() {
         const sliderValue = document.getElementById('color-count-slider').value;
         document.getElementById('color-count-display').innerText = sliderValue;

       }


 
       // Function to convert RGB to HSL
       function rgbToHsl(r, g, b) {
         r /= 255;
         g /= 255;
         b /= 255;

         const max = Math.max(r, g, b);
         const min = Math.min(r, g, b);
         let h, s, l = (max + min) / 2;

         if (max === min) {
             h = s = 0; // Achromatic
         } else {
             const d = max - min;
             s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

             switch (max) {
                 case r:
                     h = (g - b) / d + (g < b ? 6 : 0);
                     break;
                 case g:
                     h = (b - r) / d + 2;
                     break;
                 case b:
                     h = (r - g) / d + 4;
                     break;
             }

             h /= 6;
         }

         return [h, s, l];
       }
       async function generatePallateColors() {
        updateColorCountDisplay();
        const layerIndex = contextMenu.dataset.layerIndex;
        const layerIndexCount = layerIndex - 1;
        const sliderValue = document.getElementById('color-count-slider').value;
    
        const layers = {{ layers|safe }};
        let layer = layers[layerIndexCount];
        let img = new Image();
        img.src = layer.path;
        let canvas = document.getElementById('layer_canvas_'+layerIndex);
        let ctx = canvas.getContext('2d', { willReadFrequently: true });
        let latestImageData = null;
    
        img.onload = async function() {
            const colorPickerContainer = document.getElementById('color-pickers');
            colorPickerContainer.innerHTML = '';
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
    
            // Create ImageColorAnalyzer instance
            const analyzer = new ImageColorAnalyzer();
            const colorAnalysis = await analyzer.analyzeImageColors(img);
    
            // Get all colors including dominant and other colors
            let distinctColors = [colorAnalysis.dominantColor];
            if (colorAnalysis.otherColors) {
                colorAnalysis.otherColors.forEach(color => {
                    distinctColors.push(color.rgb);
                });
            }
    
            // Store original colors
            window.originalColors = [...distinctColors];
    
            // Limit colors based on slider value
            distinctColors = distinctColors.slice(0, parseInt(sliderValue));
    
            // Create color pickers for each distinct color
            distinctColors.forEach((color, index) => {
                const button = document.createElement('button');
                button.className = 'color-picker';
                button.style.backgroundColor = `rgb(${color.join(',')})`;
                
                // Get color name using analyzer
                const colorName = analyzer.getColorGroup(...color);
                button.title = colorName;
                
                document.getElementById('color-pickers').appendChild(button);
    
                const pickr = Pickr.create({
                    el: button,
                    theme: 'nano',
                    default: `rgb(${color.join(',')})`,
                    components: {
                        preview: true,
                        opacity: true,
                        hue: true,
                        interaction: {
                            rgba: true,
                            input: true,
                            hsla: true,
                            save: true,
                        }
                    }
                });
    
                let isProcessing = false;
                pickr.on('save', async (newColor) => {
                    if (isProcessing) return;
                    const rgbaColor = newColor.toRGBA().map(v => Math.round(v));
                    const currentTargetColor = distinctColors[index];
    
                    isProcessing = true;
                    await processLayerAsync(ctx, currentTargetColor, rgbaColor);
                    
                    button.style.backgroundColor = `rgba(${rgbaColor.join(',')})`;
                    distinctColors[index] = rgbaColor.slice(0, 3);
    
                    isProcessing = false;
                    pickr.hide();
                });
            });
    
            // Create a shuffle button for this color set
            const shuffleButton = document.createElement('button');
            shuffleButton.className = 'btn btn-sm btn-secondary mt-2';
            shuffleButton.innerHTML = '<i class="bi bi-shuffle"></i> Shuffle Colors';
            shuffleButton.onclick = async () => {
                const newColorAnalysis = await analyzer.analyzeImageColors(img);
                const newColors = [newColorAnalysis.dominantColor];
                
                if (newColorAnalysis.otherColors) {
                    newColorAnalysis.otherColors.forEach(color => {
                        if (newColors.length < distinctColors.length) {
                            newColors.push(color.rgb);
                        }
                    });
                }
    
                // Update existing color pickers with new colors
                const colorPickers = document.querySelectorAll('#color-pickers .color-picker');
                colorPickers.forEach((picker, index) => {
                    if (newColors[index]) {
                        picker.style.backgroundColor = `rgb(${newColors[index].join(',')})`;
                        distinctColors[index] = newColors[index];
                    }
                });
            };
            
            document.getElementById('color-pickers').appendChild(shuffleButton);
        };
    }


    // Helper function to set up palette buttons consistently
    function setupPaletteButton(buttonId, paletteIndex, collection, targetLayerIndex) {
        const button = document.getElementById(buttonId);
        if (!button) {
            // Button might not exist, especially in single layer mode with multiple palettes
            return;
        }
        com
        
        button.addEventListener('click', async function(event) {
            console.log(`Button clicked: ${buttonId}, applying ${collection} palette ${paletteIndex} to layer ${targetLayerIndex}`);
            
            // Load the original image
            const img = new Image();
            img.src = "{{ layer.path }}";
            
            await new Promise((resolve) => {
                img.onload = resolve;
            });
            
            // Reset canvas to original image
            const canvas = document.getElementById(`layer_canvas_${targetLayerIndex}`);
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0);
            
            // ----- COMPLETELY REPLACED CODE SECTION -----
            
            // Get the full palette directly from storage
            if (!window[`${collection}PaletteColors`]) {
                console.error(`Collection ${collection} not found in storage`);
                return;
            }
            
            if (!window[`${collection}PaletteColors`][paletteIndex]) {
                console.error(`Palette index ${paletteIndex} not found in ${collection}`);
                return;
            }
            
            const fullPalette = window[`${collection}PaletteColors`][paletteIndex];
            console.log(`Using full palette from storage with ${fullPalette.length} colors`);
            
            // Pass the collection name and paletteIndex correctly to processPallet
            await processPallet(
                ctx, 
                totalLayers, 
                canvas, 
                targetLayerIndex, 
                [], 
                collection,  // Pass the collection NAME
                paletteIndex  // Pass the palette INDEX
            );
        });
    }

async function processPallet(layerCtx, totalLayers, layerCanvas, currentLayerIndex, oldColorArray, collection = 'trending', paletteIndex, collectionName = null) {
  const loadingScreen = document.getElementById('loading-screen');
  loadingScreen.style.display = 'block';
  const colorProcessor = new ColorProcessor();

  try {
      // Special handling for arrays passed instead of collection name or favorites
      let fullPalette;
      let actualCollection = collectionName || collection;
      
      // NEW: Check if this is a favorite palette request
      if (typeof paletteIndex === 'string' && paletteIndex.startsWith('fav_')) {
          const favIndex = parseInt(paletteIndex.split('_')[1], 10);
          console.log(`Processing favorite palette ${favIndex}`);
          
          // Use the generated full palette for this favorite
          if (window.favGeneratedPalettes && window.favGeneratedPalettes[favIndex]) {
              fullPalette = window.favGeneratedPalettes[favIndex];
              actualCollection = 'fav';
          } else if (window.favPaletteColors && window.favPaletteColors[favIndex]) {
              // If we have favorite colors but no generated palette, generate one now
              const baseColors = window.favPaletteColors[favIndex];
              
              // Get current image colors for adaptation
              let newImageColors = null;
              const layer1Canvas = document.getElementById('layer_canvas_1');
              if (layer1Canvas) {
                  const ctx = layer1Canvas.getContext('2d', { willReadFrequently: true });
                  const imageData = ctx.getImageData(0, 0, layer1Canvas.width, layer1Canvas.height);
                  newImageColors = await getDistinctColors(imageData, 30, 50);
              }
              
              // Generate full palette using the function
              fullPalette = regenerateFullPaletteFromFavorite(baseColors, newImageColors);
              
              // Store for future use
              if (!window.favGeneratedPalettes) {
                  window.favGeneratedPalettes = {};
              }
              window.favGeneratedPalettes[favIndex] = fullPalette;
              
              actualCollection = 'fav';
          } else {
              console.error(`No favorite palette found for index ${favIndex}`);
              loadingScreen.style.display = 'none';
              return;
          }
      } else if (Array.isArray(collection)) {
          // If we're passed an array, use it as the palette
          console.log("Collection parameter is an array with", collection.length, "colors");
          fullPalette = collection;
          
          // If collectionName is explicitly provided, use it
          if (collectionName) {
              actualCollection = collectionName;
              console.log(`Using provided collection name: ${actualCollection}`);
              
              // Update the stored palette colors for future use
              if (!window[`${actualCollection}PaletteColors`]) {
                  window[`${actualCollection}PaletteColors`] = {};
              }
              window[`${actualCollection}PaletteColors`][paletteIndex] = fullPalette;
          } else {
              // If no explicit collection name, check if this palette exists in any collection
              // Priority: If we know which collection to use, don't search others
              actualCollection = collection; // Default to original value
              
              // Only search through collections if we don't have a specific collection name
              if (typeof collection !== 'string' || !window[`${collection}PaletteColors`] || !window[`${collection}PaletteColors`][paletteIndex]) {
                  const collectionsToCheck = ['trending', 'ss', 'aw', 'base', 'fav'];
                  let foundFullPalette = false;
                  
                  for (const collName of collectionsToCheck) {
                      if (window[`${collName}PaletteColors`] && 
                          window[`${collName}PaletteColors`][paletteIndex]) {
                          
                          // Make sure we're comparing the right palettes by checking a sample color
                          const storedPalette = window[`${collName}PaletteColors`][paletteIndex];
                          
                          if (storedPalette && storedPalette.length > 0) {
                              console.log(`Found stored palette in ${collName}PaletteColors[${paletteIndex}] with ${storedPalette.length} colors`);
                              fullPalette = storedPalette;
                              actualCollection = collName;
                              foundFullPalette = true;
                              break;
                          }
                      }
                  }
              }
          }
      } else {
          // Normal case: collection is a string name like 'trending', 'ss', 'aw', etc.
          console.log(`Looking for palette in ${actualCollection}PaletteColors[${paletteIndex}]`);
          
          if (!window[`${actualCollection}PaletteColors`]) {
              console.error(`No palette collection found for "${actualCollection}"`);
              loadingScreen.style.display = 'none';
              return;
          }
          
          fullPalette = window[`${actualCollection}PaletteColors`][paletteIndex];
          
          if (!fullPalette || fullPalette.length === 0) {
              console.error(`No palette found for ${actualCollection}[${paletteIndex}]`);
              loadingScreen.style.display = 'none';
              return;
          }
      }
      
      console.log(`Using full palette with ${fullPalette.length} colors from ${actualCollection}:`);
  
      // Now use the full palette for processing
      if (totalLayers === 1) {
          // Single layer optimized processing
          const layer = 1;
          const layerCanvas = document.getElementById(`layer_canvas_${layer}`);
          if (!layerCanvas) {
              console.error("Layer canvas not found");
              loadingScreen.style.display = 'none';
              return;
          }
          
          // Cache DOM elements and computed values
          const colorButtons = document.querySelectorAll('.color-picker');
          const unlockedButtons = Array.from(colorButtons).filter(button => button.dataset.locked !== 'true');
          
          if (unlockedButtons.length === 0) {
              console.log('All colors are locked');
              loadingScreen.style.display = 'none';
              return;
          }
          
          // Save current state before processing
          if (typeof layerStates !== 'undefined' && layerStates.saveEditedState) {
              layerStates.saveEditedState(layer);
          }
          
          // IMPORTANT CHANGE: Always start with the original image
          // Load the original image state instead of working with the current canvas
          const ctx = layerCanvas.getContext('2d', { willReadFrequently: true });
          
          // First, restore the original image
          let originalImageData;
          
          if (typeof layerStates !== 'undefined' && layerStates.hasOriginalState && layerStates.hasOriginalState(layer)) {
              // Load original image from layer states
              originalImageData = layerStates.getOriginalState(layer);
              const originalImg = new Image();
              await new Promise(resolve => {
                  originalImg.onload = () => {
                      ctx.clearRect(0, 0, layerCanvas.width, layerCanvas.height);
                      ctx.drawImage(originalImg, 0, 0);
                      resolve();
                  };
                  originalImg.src = originalImageData;
              });
          }
          
          // Now get the current image data after restoring the original
          const imageDataUrl = layerCanvas.toDataURL();
          
          // Create array of color mappings to process
          const colorMappings = [];
          
          // IMPORTANT: We need to get the original colors from the original image
          // Analyze the original image to find its colors
          const imageData = ctx.getImageData(0, 0, layerCanvas.width, layerCanvas.height);
          const originalColors = await getDistinctColors(imageData, 30, 50); // Adjust parameters as needed
          
          // KEY CHANGE: Track which buttons are locked and their original colors
          const lockedIndexes = new Set();
          Array.from(colorButtons).forEach((button, idx) => {
              if (button.dataset.locked === 'true') {
                  lockedIndexes.add(idx);
              }
          });
          
          // Create mappings only for unlocked buttons
          let paletteColorIndex = 0;
          for (let i = 0; i < Math.min(colorButtons.length, originalColors.length); i++) {
              const button = colorButtons[i];
              const originalColor = originalColors[i];
              
              if (lockedIndexes.has(i)) {
                  // For locked colors, map the original color to itself (no change)
                  colorMappings.push({
                      originalColor,
                      targetColor: originalColor, // Same color so no change happens
                      button
                  });
              } else {
                  // For unlocked colors, use the next color from the palette
                  const targetColor = fullPalette[paletteColorIndex % fullPalette.length];
                  paletteColorIndex++;
                  
                  if (!targetColor) {
                      console.error(`Target color not found at index ${paletteColorIndex-1}`);
                      continue;
                  }
              
                  colorMappings.push({
                      originalColor,
                      targetColor,
                      button
                  });
              }
          }
          
          if (colorMappings.length === 0) {
              console.error("No valid color mappings to apply");
              loadingScreen.style.display = 'none';
              return;
          }
          
          // Process all colors in one go
          const processedImageUrl = await colorProcessor.applyMultipleColorMappings(
              imageDataUrl,
              colorMappings
          );
          
          // Load the processed image back to canvas once
          const resultImg = new Image();
          await new Promise(resolve => {
              resultImg.onload = () => {
                  ctx.clearRect(0, 0, layerCanvas.width, layerCanvas.height);
                  ctx.drawImage(resultImg, 0, 0);
                  
                  // FIXED: Only update colors for unlocked buttons
                  colorMappings.forEach(mapping => {
                      const buttonIndex = Array.from(colorButtons).indexOf(mapping.button);
                      // Only update if the button is not locked
                      if (!lockedIndexes.has(buttonIndex)) {
                          mapping.button.style.backgroundColor = `rgb(${mapping.targetColor.join(',')})`;
                      }
                  });
                  
                  resolve();
              };
              resultImg.src = processedImageUrl;
          });
          
          // Update footer once - with safety check
          if (fullPalette[0] && typeof updateFooterColorButton === 'function') {
              updateFooterColorButton(layer, fullPalette[0]);
          }
          
      } else {
          // Optimized multi-layer processing with original image restoration
          const colorButtons = document.querySelectorAll('.color-picker');
          const unlockedLayers = [];
          const colorMappingsPerLayer = new Map();
          
          // Prepare all color mappings first to minimize DOM access
          for (let layer = 1; layer <= totalLayers; layer++) {
              const colorButton = document.querySelector(`.color-picker[data-layer-index="${layer-1}"]`);
              if (!colorButton) {
                  console.log(`No color button found for layer ${layer}`);
                  continue;
              }
              
              if (colorButton.dataset.locked === 'true') {
                  console.log(`Layer ${layer} is locked, skipping processing`);
                  continue;
              }
              
              const layerCanvas = document.getElementById(`layer_canvas_${layer}`);
              if (!layerCanvas) {
                  console.log(`Canvas not found for layer ${layer}`);
                  continue;
              }
              
              // Save current state before processing
              if (typeof layerStates !== 'undefined' && layerStates.saveEditedState) {
                  layerStates.saveEditedState(layer);
              }
              
              // For multi-layer, we'll handle the original image restoration inside the processing loop
              unlockedLayers.push({
                  layer,
                  canvas: layerCanvas,
                  button: colorButton
              });
              
              // Get target color (cycle through the full palette)
              const targetColorIndex = (layer - 1) % fullPalette.length;
              const targetColor = fullPalette[targetColorIndex];
              
              if (!targetColor) {
                  console.error(`Target color not found at index ${targetColorIndex} for layer ${layer}`);
                  continue;
              }
              
              // We'll determine the original color during processing
              colorMappingsPerLayer.set(layer, {
                  targetColor
              });
          }
          
          if (unlockedLayers.length === 0) {
              console.log('No unlocked layers to process');
              loadingScreen.style.display = 'none';
              return;
          }
          
          // Process all layers in parallel
          const layerPromises = unlockedLayers.map(async ({ layer, canvas, button }) => {
              const layerCtx = canvas.getContext('2d', { willReadFrequently: true });
              const mapping = colorMappingsPerLayer.get(layer);
              
              if (!mapping) {
                  console.error(`No color mapping found for layer ${layer}`);
                  return;
              }
              
              // IMPORTANT: Always start with the original image
              let originalImageData;
              
              if (typeof layerStates !== 'undefined' && layerStates.hasOriginalState && layerStates.hasOriginalState(layer)) {
                  // Load original image from layer states
                  originalImageData = layerStates.getOriginalState(layer);
                  const originalImg = new Image();
                  await new Promise(resolve => {
                      originalImg.onload = () => {
                          layerCtx.clearRect(0, 0, canvas.width, canvas.height);
                          layerCtx.drawImage(originalImg, 0, 0);
                          resolve();
                      };
                      originalImg.src = originalImageData;
                  });
              }
              
              // Now get the current image data after restoring the original
              const imageDataUrl = canvas.toDataURL();
              
              // Analyze the original image data to find its dominant color
              const imageData = layerCtx.getImageData(0, 0, canvas.width, canvas.height);
              const originalColors = await getDistinctColors(imageData, 30, 50); // Adjust parameters as needed
              
              if (originalColors.length === 0) {
                  console.error(`No original colors found for layer ${layer}`);
                  return;
              }
              
              // Use the first original color
              const originalColor = originalColors[0];
              mapping.originalColor = originalColor;
              
              // Now process with the original color and target color
              const processedImageUrl = await colorProcessor.applyColorMapping(
                  imageDataUrl,
                  await colorProcessor.getColorMapping(imageDataUrl),
                  mapping.targetColor,
                  mapping.originalColor
              );
              
              // Load the processed image back to canvas
              const resultImg = new Image();
              await new Promise(resolve => {
                  resultImg.onload = () => {
                      layerCtx.clearRect(0, 0, canvas.width, canvas.height);
                      layerCtx.drawImage(resultImg, 0, 0);
                      
                      // Update button color
                      button.style.backgroundColor = `rgb(${mapping.targetColor.join(',')})`;
                      
                      // Update footer with safety check
                      if (typeof updateFooterColorButton === 'function') {
                          updateFooterColorButton(layer, mapping.targetColor);
                      }
                      
                      resolve();
                  };
                  resultImg.src = processedImageUrl;
              });
          });
          
          // Wait for all layers to complete
          await Promise.all(layerPromises);
      }
  } catch (error) {
      console.error("Error while processing pallet:", error);
      console.error("Error details:", error.stack);
  } finally {
      loadingScreen.style.display = 'none';
  }
}

function getRandomColor() {
  const r = Math.floor(Math.random() * 256);
  const g = Math.floor(Math.random() * 256);
  const b = Math.floor(Math.random() * 256);
  return [r, g, b];
}


function updateFooterColorButton(layerIndex, newColor) {
    const colorButton = document.querySelector(`.color-picker[data-layer-index="${layerIndex-1}"]`);
    if (colorButton) {
        colorButton.style.backgroundColor = Array.isArray(newColor) ? 
            `rgb(${newColor.join(',')})` : newColor;
    }
}


class ImageColorAnalyzer {
    constructor() {
        this.logger = console;
        this.cv = null;
        this.isReady = false;
        this.initializationPromise = null;
    }

    async initialize() {
        // If already initialized, return
        if (this.isReady) return;

        // If initialization is in progress, return the existing promise
        if (this.initializationPromise) {
            return this.initializationPromise;
        }

        this.initializationPromise = new Promise((resolve, reject) => {
            // Check if OpenCV is already loaded
            if (typeof cv !== 'undefined') {
                this.cv = cv;
                this.isReady = true;
                resolve();
                return;
            }

            // Check if the script is already being loaded
            const existingScript = document.querySelector('script[src*="opencv.js"]');
            if (existingScript) {
                existingScript.addEventListener('load', () => {
                    this.cv = cv;
                    this.isReady = true;
                    resolve();
                });
                existingScript.addEventListener('error', () => {
                    reject(new Error('Failed to load OpenCV.js'));
                });
                return;
            }

            // Load OpenCV if not already loading
            const script = document.createElement('script');
            script.src = 'https://docs.opencv.org/4.8.0/opencv.js';
            script.async = true;
            script.type = 'text/javascript';

            // Only set Module if it's not already defined
            if (typeof window.Module === 'undefined') {
                window.Module = {
                    onRuntimeInitialized: () => {
                        this.cv = cv;
                        this.isReady = true;
                        resolve();
                    }
                };
            }

            script.onerror = () => {
                reject(new Error('Failed to load OpenCV.js'));
            };

            document.body.appendChild(script);
        });

        return this.initializationPromise;
    }

    rgbToLab(r, g, b) {
        // Convert RGB to XYZ
        r = r / 255;
        g = g / 255;
        b = b / 255;

        // RGB to XYZ conversion
        r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
        g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
        b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;

        r *= 100;
        g *= 100;
        b *= 100;

        const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
        const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
        const z = r * 0.0193 + g * 0.1192 + b * 0.9505;

        // XYZ to Lab conversion
        const xn = 95.047;
        const yn = 100.000;
        const zn = 108.883;

        const fx = x / xn > 0.008856 ? Math.pow(x / xn, 1/3) : (7.787 * x / xn) + 16/116;
        const fy = y / yn > 0.008856 ? Math.pow(y / yn, 1/3) : (7.787 * y / yn) + 16/116;
        const fz = z / zn > 0.008856 ? Math.pow(z / zn, 1/3) : (7.787 * z / zn) + 16/116;

        const L = (116 * fy) - 16;
        const a = 500 * (fx - fy);
        const b_val = 200 * (fy - fz);

        return [L, a, b_val];
    }

    calculateColorDifference(lab1, lab2) {
        // Delta E 2000 calculation (simplified version)
        const deltaL = lab2[0] - lab1[0];
        const deltaA = lab2[1] - lab1[1];
        const deltaB = lab2[2] - lab1[2];

        return Math.sqrt(
            Math.pow(deltaL, 2) +
            Math.pow(deltaA, 2) +
            Math.pow(deltaB, 2)
        );
    }

    async analyzeImageColors(imageElement) {
        if (!this.isReady) {
            await this.initialize();
        }

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = imageElement.width;
        canvas.height = imageElement.height;
        ctx.drawImage(imageElement, 0, 0);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const pixels = imageData.data;

        // Store colors with their frequency and LAB values
        const colorMap = new Map();
        const totalPixels = pixels.length / 4;

        // Sample pixels (analyze every 4th pixel for performance)
        for (let i = 0; i < pixels.length; i += 16) {
            const r = pixels[i];
            const g = pixels[i + 1];
            const b = pixels[i + 2];
            const a = pixels[i + 3];

            // Skip transparent pixels
            if (a < 127) continue;

            const key = `${r},${g},${b}`;
            const lab = this.rgbToLab(r, g, b);

            if (colorMap.has(key)) {
                colorMap.get(key).count++;
            } else {
                colorMap.set(key, {
                    rgb: [r, g, b],
                    lab: lab,
                    count: 1
                });
            }
        }

        // Convert map to array for processing
        let colors = Array.from(colorMap.values());

        // Merge similar colors
        const mergedColors = [];
        const threshold = 5; // Color difference threshold

        while (colors.length > 0) {
            const baseColor = colors[0];
            let totalCount = baseColor.count;
            const similarColors = [baseColor];

            // Find and merge similar colors
            for (let i = 1; i < colors.length; i++) {
                const diff = this.calculateColorDifference(baseColor.lab, colors[i].lab);
                if (diff < threshold) {
                    totalCount += colors[i].count;
                    similarColors.push(colors[i]);
                }
            }

            // Calculate weighted average color
            const avgColor = similarColors.reduce((acc, curr) => {
                const weight = curr.count / totalCount;
                return {
                    rgb: [
                        acc.rgb[0] + curr.rgb[0] * weight,
                        acc.rgb[1] + curr.rgb[1] * weight,
                        acc.rgb[2] + curr.rgb[2] * weight
                    ]
                };
            }, { rgb: [0, 0, 0] });

            mergedColors.push({
                rgb: avgColor.rgb.map(Math.round),
                percentage: (totalCount / (totalPixels / 4)) * 100
            });

            // Remove processed colors
            colors = colors.filter(c => !similarColors.includes(c));
        }

        // Sort by percentage and group by basic color categories
        const colorGroups = {};
        
        mergedColors.sort((a, b) => b.percentage - a.percentage)
            .forEach(color => {
                const colorGroup = this.getColorGroup(...color.rgb);
                
                if (!colorGroups[colorGroup]) {
                    colorGroups[colorGroup] = {
                        totalPercentage: 0,
                        shades: []
                    };
                }

                colorGroups[colorGroup].shades.push({
                    rgb: color.rgb,
                    percentage: color.percentage
                });
                colorGroups[colorGroup].totalPercentage += color.percentage;
            });

        // Sort and format results
        const sortedGroups = Object.entries(colorGroups)
            .map(([name, data]) => ({
                name,
                totalPercentage: data.totalPercentage,
                dominantShade: data.shades.sort((a, b) => b.percentage - a.percentage)[0]
            }))
            .sort((a, b) => b.totalPercentage - a.totalPercentage);

        const dominantGroup = sortedGroups[0];
        const otherColors = sortedGroups.slice(1, 5).map(group => ({
            colorName: group.name,
            rgb: group.dominantShade.rgb,
            percentage: group.totalPercentage
        }));



        const [h, s, l] = this.rgbToHsl(...dominantGroup.dominantShade.rgb);

        return {
            dominantColor: dominantGroup.dominantShade.rgb,
            dominantColorName: dominantGroup.name,
            dominantPercentage: dominantGroup.totalPercentage,
            otherColors: otherColors,
            hue: h * 360,
            saturation: s * 100,
            lightness: l * 100
        };
    }

    rgbToHsl(r, g, b) {
        r /= 255;
        g /= 255;
        b /= 255;

        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;

        if (max === min) {
            h = s = 0;
        } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }

            h /= 6;
        }

        return [h, s, l];
    }

    getColorGroup(r, g, b) {
    const [h, s, l] = this.rgbToHsl(r, g, b);
    const hue = h * 360;

    // Define color ranges by hue
    if (l < 0.1) return 'black';
    if (l > 0.9 && s < 0.1) return 'white';
    if (s < 0.15 && l > 0.1 && l < 0.9) return 'gray';

    // Hue-based color grouping
    if ((hue >= 345 || hue <= 10) && s > 0.15) return 'red';
    if (hue > 10 && hue <= 45) return 'orange';
    if (hue > 45 && hue <= 65) return 'yellow';
    if (hue > 65 && hue <= 170) return 'green';
    if (hue > 170 && hue <= 190) return 'cyan';
    if (hue > 190 && hue <= 260) return 'blue';
    if (hue > 260 && hue <= 320) return 'magenta';
    if (hue > 320 && hue <= 345) return 'purple';

    return 'other';
}
}

class ColorProcessor {
  constructor() {
        this.EPSILON = 0.0001;
        this.COLOR_SIMILARITY_THRESHOLD = 30;
        this.COLOR_QUANTIZATION_STEP = 15; // Added for color quantization
        this.cv = null; // Will store OpenCV instance
        
        // Bind methods
        this.applyColorMapping = this.applyColorMapping.bind(this);
   
       
        this.rgbToHsvProcessor = this.rgbToHsvProcessor.bind(this);
        this.hsvToRgbProcessor = this.hsvToRgbProcessor.bind(this);
        this.quantizeColor = this.quantizeColor.bind(this)
    }

    rgbToLab(rgb) {
      // First, convert RGB to XYZ using D65 illuminant
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;

      // Convert to sRGB space
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;

      // Convert to XYZ space
      const x = (r * 0.4124564 + g * 0.3575761 + b * 0.1804375) * 100;
      const y = (r * 0.2126729 + g * 0.7151522 + b * 0.0721750) * 100;
      const z = (r * 0.0193339 + g * 0.1191920 + b * 0.9503041) * 100;

      // Convert XYZ to Lab
      const xn = 95.047;
      const yn = 100.000;
      const zn = 108.883;

      const fx = x / xn > 0.008856 ? Math.pow(x / xn, 1/3) : (903.3 * x / xn + 16) / 116;
      const fy = y / yn > 0.008856 ? Math.pow(y / yn, 1/3) : (903.3 * y / yn + 16) / 116;
      const fz = z / zn > 0.008856 ? Math.pow(z / zn, 1/3) : (903.3 * z / zn + 16) / 116;

      const L = Math.max(0, 116 * fy - 16);
      const a = 500 * (fx - fy);
      const c = 200 * (fy - fz);

      return [L, a, c];
  }

  rgbToHsvProcessor(rgb) {
        const r = rgb[0] / 255;
        const g = rgb[1] / 255;
        const b = rgb[2] / 255;
        
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        const diff = max - min;
        
        let h = 0;
        if (max === min) {
            h = 0;
        } else if (max === r) {
            h = (60 * ((g - b) / diff) + 360) % 360;
        } else if (max === g) {
            h = (60 * ((b - r) / diff) + 120) % 360;
        } else {
            h = (60 * ((r - g) / diff) + 240) % 360;
        }
        
        const s = max === 0 ? 0 : diff / max;
        const v = max;
        
        return [h, s, v];
    }







   
    isColorSimilar(color1, color2) {
    const hsv1 = this.rgbToHsvProcessor(color1);
    const hsv2 = this.rgbToHsvProcessor(color2);
    
    // Calculate hue difference
    let hueDiff = Math.abs(hsv1[0] - hsv2[0]);
    if (hueDiff > 180) hueDiff = 360 - hueDiff;
    
    // Make the similarity check more strict
    const saturationThreshold = (hsv1[1] < 0.1 || hsv2[1] < 0.1) ? 0.1 : 0.2;
    
    return (
        (hueDiff < 20 || (hsv1[1] < 0.1 && hsv2[1] < 0.1)) && // Stricter hue check
        Math.abs(hsv1[1] - hsv2[1]) < saturationThreshold && 
        Math.abs(hsv1[2] - hsv2[2]) < 0.3
    );
}
quantizeColor(rgb) {
    return rgb.map(v => Math.round(v / this.COLOR_QUANTIZATION_STEP) * this.COLOR_QUANTIZATION_STEP);
}
calculateColorDistance(lab1, lab2) {
    // Use Delta E 2000 instead of Euclidean distance for more perceptually accurate color differences
    const kL = 1;
    const kC = 1;
    const kH = 1;
    
    const deltaL = lab1[0] - lab2[0];
    const L1 = lab1[0], L2 = lab2[0];
    const a1 = lab1[1], a2 = lab2[1];
    const b1 = lab1[2], b2 = lab2[2];
    
    const C1 = Math.sqrt(a1 * a1 + b1 * b1);
    const C2 = Math.sqrt(a2 * a2 + b2 * b2);
    const deltaC = C1 - C2;
    
    const deltaA = a1 - a2;
    const deltaB = b1 - b2;
    
    const deltaH = Math.sqrt(deltaA * deltaA + deltaB * deltaB - deltaC * deltaC);
    
    const SL = 1;
    const SC = 1 + 0.045 * (C1 + C2) / 2;
    const SH = 1 + 0.015 * (C1 + C2) / 2;
    
    return Math.sqrt(
        Math.pow(deltaL / (kL * SL), 2) +
        Math.pow(deltaC / (kC * SC), 2) +
        Math.pow(deltaH / (kH * SH), 2)
    );
}

    findSimilarColors(currentLab, shades, threshold = 25) {
        return shades.filter(shade => 
            this.calculateColorDistance(currentLab, shade.lab) < threshold
        );
    }

async getColorMapping(imageData) {
      return new Promise((resolve) => {
          const img = new Image();
          img.onload = () => {
              const canvas = document.createElement('canvas');
              const ctx = canvas.getContext('2d');
              canvas.width = img.width;
              canvas.height = img.height;
              ctx.drawImage(img, 0, 0);
              
              const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
              const pixels = imgData.data;
              const totalPixels = pixels.length / 4;
              
              // Store colors with their frequency and LAB values
              const colorMap = new Map();
  
              // Analyze every pixel for better accuracy
              for (let i = 0; i < pixels.length; i += 4) {
                  const r = pixels[i];
                  const g = pixels[i + 1];
                  const b = pixels[i + 2];
                  const a = pixels[i + 3];
  
                  // Skip fully transparent pixels and pure black/white
                  if (a < 127) continue;
                  if (r === 0 && g === 0 && b === 0) continue;
                  if (r === 255 && g === 255 && b === 255) continue;
  
                  const key = `${r},${g},${b}`;
                  const lab = this.rgbToLab([r, g, b]);
                  const hsv = this.rgbToHsv(r, g, b);
  
                  if (colorMap.has(key)) {
                      colorMap.get(key).count++;
                  } else {
                      colorMap.set(key, {
                          rgb: [r, g, b],
                          lab: lab,
                          hsv: hsv,
                          count: 1
                      });
                  }
              }
  
              // Convert map to array for processing
              let colors = Array.from(colorMap.values());
  
              // Initial filtering of insignificant colors
              colors = colors.filter(color => 
                  (color.count / totalPixels) * 100 > 0.1 && // More than 0.1% of image
                  color.hsv[1] > 0.05 // Has some saturation
              );
  
              // Merge similar colors with adaptive threshold
              const mergedColors = [];
              const baseThreshold = 5; // Base threshold for color difference
  
              while (colors.length > 0) {
                  const baseColor = colors[0];
                  let totalCount = baseColor.count;
                  const similarColors = [baseColor];
  
                  // Adaptive threshold based on color properties
                  const adaptiveThreshold = this.calculateAdaptiveThreshold(baseColor, baseThreshold);
  
                  // Find and merge similar colors
                  for (let i = 1; i < colors.length; i++) {
                      const diff = this.calculateColorDistance(baseColor.lab, colors[i].lab);
                      const hsvDiff = this.calculateHSVDifference(baseColor.hsv, colors[i].hsv);
                      
                      if (diff < adaptiveThreshold || hsvDiff < 0.15) {
                          totalCount += colors[i].count;
                          similarColors.push(colors[i]);
                      }
                  }
  
                  // Calculate weighted average color
                  const avgColor = similarColors.reduce((acc, curr) => {
                      const weight = curr.count / totalCount;
                      return {
                          rgb: [
                              acc.rgb[0] + curr.rgb[0] * weight,
                              acc.rgb[1] + curr.rgb[1] * weight,
                              acc.rgb[2] + curr.rgb[2] * weight
                          ]
                      };
                  }, { rgb: [0, 0, 0] });
  
                  const finalRGB = avgColor.rgb.map(Math.round);
                  mergedColors.push({
                      rgb: finalRGB,
                      lab: this.rgbToLab(finalRGB),
                      hsv: this.rgbToHsv(...finalRGB),
                      percentage: (totalCount / totalPixels) * 100
                  });
  
                  // Remove processed colors
                  colors = colors.filter(c => !similarColors.includes(c));
              }
  
              // Sort by perceptual importance (combination of frequency and distinctiveness)
              mergedColors.sort((a, b) => {
                  const aScore = this.calculateColorImportance(a);
                  const bScore = this.calculateColorImportance(b);
                  return bScore - aScore;
              });
  
              // Get distinct colors while maintaining relationships
              const distinctColors = this.filterDistinctColors(mergedColors);
  
              // Get base color and shades
              const baseColor = distinctColors[0].rgb;
              const shades = distinctColors.map(color => ({
                  original: color.rgb,
                  lab: color.lab,
                  hsv: color.hsv,
                  frequency: color.percentage,
                  distance: this.calculateColorDistance(color.lab, distinctColors[0].lab)
              }));
  
              resolve({
                  baseColor,
                  shades
              });
          };
          img.src = imageData;
      });
  }
  // Add this new method to the ColorProcessor class
async applyDirectColorMapping(imageData, colorMappings) {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        console.time('directColorMapping');
        const canvasElement = document.createElement('canvas');
        const ctx = canvasElement.getContext('2d');
        canvasElement.width = img.width;
        canvasElement.height = img.height;
  
        ctx.drawImage(img, 0, 0);
        const imageDataObj = ctx.getImageData(0, 0, img.width, img.height);
        const data = imageDataObj.data;
        
        // Function to convert RGB to HSV for better comparison
        function rgbToHsv(r, g, b) {
          r /= 255; g /= 255; b /= 255;
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          const d = max - min;
          let h, s = max === 0 ? 0 : d / max, v = max;
  
          if (max === min) {
            h = 0;
          } else {
            switch (max) {
              case r: h = (g - b) / d + (g < b ? 6 : 0); break;
              case g: h = (b - r) / d + 2; break;
              case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
          }
          return [h * 360, s * 100, v * 100];
        }
        
        function hsvToRgb(h, s, v) {
          h /= 360; s /= 100; v /= 100;
          let r, g, b;
          
          if (s === 0) {
            r = g = b = v;
          } else {
            const i = Math.floor(h * 6);
            const f = h * 6 - i;
            const p = v * (1 - s);
            const q = v * (1 - f * s);
            const t = v * (1 - (1 - f) * s);
            
            switch (i % 6) {
              case 0: r = v, g = t, b = p; break;
              case 1: r = q, g = v, b = p; break;
              case 2: r = p, g = v, b = t; break;
              case 3: r = p, g = q, b = v; break;
              case 4: r = t, g = p, b = v; break;
              case 5: r = v, g = p, b = q; break;
            }
          }
          
          return [
            Math.round(r * 255),
            Math.round(g * 255),
            Math.round(b * 255)
          ];
        }
        
        // Prepare color mappings with HSV values
        const preparedMappings = colorMappings.map(mapping => {
          const { originalColor, targetColor } = mapping;
          return {
            originalRgb: originalColor,
            targetRgb: targetColor,
            originalHsv: rgbToHsv(...originalColor),
            targetHsv: rgbToHsv(...targetColor)
          };
        });
        
        // Use a cache for transformed colors
        const transformCache = new Map();
        
        // Process each pixel
        for (let i = 0; i < data.length; i += 4) {
          if (data[i + 3] < 128) continue; // Skip transparent pixels
          
          const r = data[i];
          const g = data[i + 1];
          const b = data[i + 2];
          
          // Skip absolute black
          if (r <= 3 && g <= 3 && b <= 3) continue;
          
          // Check cache for this color
          const colorKey = `${r},${g},${b}`;
          if (transformCache.has(colorKey)) {
            const newColor = transformCache.get(colorKey);
            data[i] = newColor[0];
            data[i + 1] = newColor[1];
            data[i + 2] = newColor[2];
            continue;
          }
          
          // Find the best matching mapping
          let bestMatch = null;
          let minDistance = Infinity;
          
          // Convert pixel to HSV
          const pixelHsv = rgbToHsv(r, g, b);
          
          // Find closest match
          for (const mapping of preparedMappings) {
            const { originalRgb, originalHsv } = mapping;
            
            // Calculate RGB distance (primary metric)
            const rgbDistance = Math.sqrt(
              Math.pow(r - originalRgb[0], 2) +
              Math.pow(g - originalRgb[1], 2) +
              Math.pow(b - originalRgb[2], 2)
            );
            
            // Also consider HSV for better matching
            let hueDiff = Math.abs(pixelHsv[0] - originalHsv[0]);
            if (hueDiff > 180) hueDiff = 360 - hueDiff;
            
            const satDiff = Math.abs(pixelHsv[1] - originalHsv[1]);
            const valDiff = Math.abs(pixelHsv[2] - originalHsv[2]);
            
            // Lower weight for hue if saturation is low
            const hueWeight = pixelHsv[1] < 20 ? 0.1 : 0.6;
            
            // Combined distance (RGB and HSV)
            const distance = rgbDistance * 0.7 + ((hueDiff/180) * hueWeight + satDiff/100 + valDiff/100) * 30;
            
            if (distance < minDistance) {
              minDistance = distance;
              bestMatch = mapping;
            }
          }
          
          // Transform the color if we found a match
          if (bestMatch && minDistance < 100) {
            const { originalHsv, targetHsv } = bestMatch;
            
            // Preserve relative brightness and saturation
            const relativeBrightness = originalHsv[2] > 0 ? pixelHsv[2] / originalHsv[2] : 1;
            const relativeSaturation = originalHsv[1] > 0 ? pixelHsv[1] / originalHsv[1] : 1;
            
            // Apply transformation with preserved relationships
            const newHue = targetHsv[0];
            const newSat = Math.min(100, targetHsv[1] * relativeSaturation);
            const newVal = Math.min(100, targetHsv[2] * relativeBrightness);
            
            // Convert back to RGB
            const newColor = hsvToRgb(newHue, newSat, newVal);
            
            // Apply the new color
            data[i] = newColor[0];
            data[i + 1] = newColor[1];
            data[i + 2] = newColor[2];
            
            // Cache the transformation
            transformCache.set(colorKey, newColor);
          }
        }
  
        // Apply changes
        ctx.putImageData(imageDataObj, 0, 0);
        const dataUrl = canvasElement.toDataURL('image/png');
        console.timeEnd('directColorMapping');
        resolve(dataUrl);
      };
      img.src = imageData;
    });
  }


async applyMultipleColorMappingsextra(imageData, colorMappings) {
    return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
            console.time('colorMapping');
            const canvasElement = document.createElement('canvas');
            const ctx = canvasElement.getContext('2d');
            canvasElement.width = img.width;
            canvasElement.height = img.height;

            ctx.drawImage(img, 0, 0);
            const imageDataObj = ctx.getImageData(0, 0, img.width, img.height);
            const data = imageDataObj.data;
            const width = img.width;
            const height = img.height;

            // Color conversion utilities
            function rgbToHsv(r, g, b) {
                r /= 255; g /= 255; b /= 255;
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                const d = max - min;
                let h, s = max === 0 ? 0 : d / max, v = max;

                if (max === min) {
                    h = 0;
                } else {
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    h /= 6;
                }
                return [h * 360, s * 100, v * 100];
            }

            function hsvToRgb(h, s, v) {
                h /= 360; s /= 100; v /= 100;
                let r, g, b;
                const i = Math.floor(h * 6);
                const f = h * 6 - i;
                const p = v * (1 - s);
                const q = v * (1 - f * s);
                const t = v * (1 - (1 - f) * s);

                switch (i % 6) {
                    case 0: r = v; g = t; b = p; break;
                    case 1: r = q; g = v; b = p; break;
                    case 2: r = p; g = v; b = t; break;
                    case 3: r = p; g = q; b = v; break;
                    case 4: r = t; g = p; b = v; break;
                    case 5: r = v; g = p; b = q; break;
                }

                return [
                    Math.round(r * 255),
                    Math.round(g * 255),
                    Math.round(b * 255)
                ];
            }
            
            // IMPROVED: More flexible color family detection for blurry images
            function sameColorFamily(color1, color2) {
                const [r1, g1, b1] = color1;
                const [r2, g2, b2] = color2;
                
                // Convert to HSV for better comparison
                const hsv1 = rgbToHsv(r1, g1, b1);
                const hsv2 = rgbToHsv(r2, g2, b2);
                
                // Check if both are achromatic (black, white, gray)
                const isAchromatic1 = hsv1[1] < 20; // More lenient threshold
                const isAchromatic2 = hsv2[1] < 20; 
                
                // If both are achromatic, compare by value (brightness)
                if (isAchromatic1 && isAchromatic2) {
                    // Allow more variance in brightness for achromatic colors
                    return Math.abs(hsv1[2] - hsv2[2]) < 40; // More lenient
                }
                
                // If one is achromatic and the other not, they're different families
                if (isAchromatic1 !== isAchromatic2) {
                    return false;
                }
                
                // For chromatic colors, check hue similarity with adaptive threshold
                // Calculate hue difference with wrap-around
                let hueDiff = Math.abs(hsv1[0] - hsv2[0]);
                if (hueDiff > 180) hueDiff = 360 - hueDiff;
                
                // For very dark or low saturation colors, hue is less reliable
                const areBothDark = hsv1[2] < 35 && hsv2[2] < 35;
                const lowSaturation = hsv1[1] < 40 || hsv2[1] < 40;
                
                // Adapt thresholds based on color properties
                // CHANGE: Tighter hue threshold (40 → 30) for better handling of many colors
                const hueThreshold = areBothDark || lowSaturation ? 45 : 30;
                const satThreshold = areBothDark ? 50 : 40;
                
                // Colors in the same family should have similar hue and not too different saturation
                return hueDiff < hueThreshold && 
                       Math.abs(hsv1[1] - hsv2[1]) < satThreshold;
            }
            
            // IMPROVED: Better gradient detection for blurry images
            function detectGradients() {
                // Store gradient information
                const gradientMap = new Array(width * height).fill(false);
                const gradientStrengthMap = new Array(width * height).fill(0);
                
                // First pass: detect gradient pixels with more sensitivity
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const centerIdx = (y * width + x) * 4;
                        if (data[centerIdx + 3] < 128) continue; // Skip transparent
                        
                        const centerColor = [data[centerIdx], data[centerIdx + 1], data[centerIdx + 2]];
                        const centerHsv = rgbToHsv(...centerColor);
                        
                        // Adaptive thresholds - more sensitive for blurry images
                        const minDiffThreshold = Math.max(2, 5 - centerHsv[1] * 0.05);
                        const maxDiffThreshold = 60 + (1 - centerHsv[1]/100) * 20;
                        
                        // Check neighbors
                        let maxDiff = 0;
                        let hasGradient = false;
                        
                        // Check in all directions for better detection
                        const directions = [
                            { dx: -1, dy: 0 }, { dx: 1, dy: 0 },
                            { dx: 0, dy: -1 }, { dx: 0, dy: 1 },
                            { dx: -1, dy: -1 }, { dx: 1, dy: -1 },
                            { dx: -1, dy: 1 }, { dx: 1, dy: 1 }
                        ];
                        
                        for (const { dx, dy } of directions) {
                            const nx = x + dx;
                            const ny = y + dy;
                            
                            if (nx < 0 || nx >= width || ny < 0 || ny >= height) continue;
                            
                            const neighborIdx = (ny * width + nx) * 4;
                            if (data[neighborIdx + 3] < 128) continue;
                            
                            const neighborColor = [data[neighborIdx], data[neighborIdx + 1], data[neighborIdx + 2]];
                            
                            // Calculate color difference
                            const diff = Math.sqrt(
                                Math.pow(centerColor[0] - neighborColor[0], 2) +
                                Math.pow(centerColor[1] - neighborColor[1], 2) +
                                Math.pow(centerColor[2] - neighborColor[2], 2)
                            );
                            
                            // More relaxed condition for gradients
                            if (diff > minDiffThreshold && diff < maxDiffThreshold) {
                                // For very subtle gradients, don't strictly require same family
                                if (diff < 15 || sameColorFamily(centerColor, neighborColor)) {
                                    hasGradient = true;
                                    maxDiff = Math.max(maxDiff, diff);
                                }
                            }
                        }
                        
                        if (hasGradient) {
                            gradientMap[y * width + x] = true;
                            gradientStrengthMap[y * width + x] = Math.min(1, maxDiff / maxDiffThreshold);
                        }
                    }
                }
                
                // Second pass: expand gradient regions more aggressively
                const expandedGradientMap = [...gradientMap];
                
                // Multiple expansion passes for better coverage
                for (let pass = 0; pass < 2; pass++) {
                    for (let y = 1; y < height - 1; y++) {
                        for (let x = 1; x < width - 1; x++) {
                            const pixelIndex = y * width + x;
                            if (expandedGradientMap[pixelIndex] || data[(pixelIndex * 4) + 3] < 128) continue;
                            
                            // Check if surrounded by gradient pixels
                            let gradientNeighbors = 0;
                            
                            for (let dy = -2; dy <= 2; dy++) {
                                for (let dx = -2; dx <= 2; dx++) {
                                    if (dx === 0 && dy === 0) continue;
                                    
                                    const nx = x + dx;
                                    const ny = y + dy;
                                    
                                    if (nx < 0 || nx >= width || ny < 0 || ny >= height) continue;
                                    
                                    const nIndex = ny * width + nx;
                                    
                                    if (expandedGradientMap[nIndex]) {
                                        // Weight by distance
                                        gradientNeighbors += (Math.abs(dx) + Math.abs(dy) <= 2) ? 1 : 0.5;
                                    }
                                }
                            }
                            
                            // More aggressive expansion for blurry images
                            if (gradientNeighbors >= 1.5) {
                                expandedGradientMap[pixelIndex] = true;
                                gradientStrengthMap[pixelIndex] = 0.6;
                            }
                        }
                    }
                }
                
                return { gradientMap: expandedGradientMap, gradientStrengthMap };
            }
            
            // Identify color families with improved logic
            function identifyColorFamilies() {
                const colorFamilies = [];
                const pixelFamilyMap = new Array(width * height).fill(-1);
                
                // Process pixels to form initial color families
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const pixelIndex = y * width + x;
                        const colorIdx = pixelIndex * 4;
                        
                        if (data[colorIdx + 3] < 128) continue; // Skip transparent
                        
                        // Skip if already assigned to a family
                        if (pixelFamilyMap[pixelIndex] !== -1) continue;
                        
                        const pixelColor = [data[colorIdx], data[colorIdx + 1], data[colorIdx + 2]];
                        
                        // Only skip pure black (almost zero in all channels)
                        if (pixelColor[0] <= 3 && pixelColor[1] <= 3 && pixelColor[2] <= 3) continue;
                        
                        // CHANGE: For many colors, be more selective about family membership
                        // Check if this color fits into an existing family with stricter thresholds
                        let foundFamily = false;
                        
                        // CHANGE: Only check recent families first to improve performance with many colors
                        const startIdx = Math.max(0, colorFamilies.length - 50);
                        for (let i = startIdx; i < colorFamilies.length; i++) {
                            const family = colorFamilies[i];
                            
                            // Check if color belongs to this family with improved detection
                            if (sameColorFamily(pixelColor, family.referenceColor)) {
                                // Add to family
                                family.pixels.push(pixelIndex);
                                family.sumR += pixelColor[0];
                                family.sumG += pixelColor[1];
                                family.sumB += pixelColor[2];
                                family.count++;
                                
                                pixelFamilyMap[pixelIndex] = i;
                                foundFamily = true;
                                break;
                            }
                        }
                        
                        // If no matching family in recent ones, check older ones
                        if (!foundFamily && startIdx > 0) {
                            for (let i = 0; i < startIdx; i++) {
                                const family = colorFamilies[i];
                                
                                if (sameColorFamily(pixelColor, family.referenceColor)) {
                                    // Add to family
                                    family.pixels.push(pixelIndex);
                                    family.sumR += pixelColor[0];
                                    family.sumG += pixelColor[1];
                                    family.sumB += pixelColor[2];
                                    family.count++;
                                    
                                    pixelFamilyMap[pixelIndex] = i;
                                    foundFamily = true;
                                    break;
                                }
                            }
                        }
                        
                        // If no matching family, create a new one
                        if (!foundFamily) {
                            const familyIndex = colorFamilies.length;
                            colorFamilies.push({
                                referenceColor: pixelColor,
                                pixels: [pixelIndex],
                                sumR: pixelColor[0],
                                sumG: pixelColor[1],
                                sumB: pixelColor[2],
                                count: 1,
                                mappingIndex: -1 // Will be set later
                            });
                            
                            pixelFamilyMap[pixelIndex] = familyIndex;
                        }
                    }
                }
                
                // Calculate average color for each family
                colorFamilies.forEach(family => {
                    family.avgColor = [
                        Math.round(family.sumR / family.count),
                        Math.round(family.sumG / family.count),
                        Math.round(family.sumB / family.count)
                    ];
                    
                    // Also calculate HSV for easier comparisons
                    family.hsv = rgbToHsv(...family.avgColor);
                });
                
                console.log(`Identified ${colorFamilies.length} color families`);
                return { colorFamilies, pixelFamilyMap };
            }
            
            // Process color mappings
            function prepareColorMappings() {
                return colorMappings.map((mapping, index) => {
                    const { originalColor, targetColor } = mapping;
                    
                    // Convert to HSV for easier transformations
                    const originalHsv = rgbToHsv(...originalColor);
                    const targetHsv = rgbToHsv(...targetColor);
                    
                    // Calculate transformation parameters more explicitly
                    let hueShift = targetHsv[0] - originalHsv[0];
                    if (hueShift > 180) hueShift -= 360;
                    else if (hueShift < -180) hueShift += 360;
                    
                    // Calculate more precise ratios to maintain the exact relationship
                    const satRatio = originalHsv[1] > 5 ? targetHsv[1] / originalHsv[1] : 1;
                    const valRatio = originalHsv[2] > 5 ? targetHsv[2] / originalHsv[2] : 1;
                    
                    // Include the original button reference to maintain the exact mapping relationship
                    return {
                        originalColor,
                        targetColor,
                        originalHsv,
                        targetHsv,
                        hueShift,
                        satRatio,
                        valRatio,
                        index,
                        buttonReference: mapping.button // Store the button reference
                    };
                });
            }
            
            // IMPROVED: Better mapping for more colors
            function mapFamiliesToMappings(colorFamilies, processedMappings) {
                // CHANGE: For each color family, find the best matching source color
                // When dealing with many colors, we need more precise mapping
                colorFamilies.forEach(family => {
                    let bestMappingIndex = -1;
                    let bestScore = Infinity;
                    
                    for (let i = 0; i < processedMappings.length; i++) {
                        const mapping = processedMappings[i];
                        
                        // Calculate weighted distance in both RGB and HSV space
                        // RGB distance for precise matching
                        const rgbDistance = Math.sqrt(
                            Math.pow(family.avgColor[0] - mapping.originalColor[0], 2) +
                            Math.pow(family.avgColor[1] - mapping.originalColor[1], 2) +
                            Math.pow(family.avgColor[2] - mapping.originalColor[2], 2)
                        );
                        
                        // HSV comparison for perceptual matching
                        const familyHsv = family.hsv;
                        const mappingHsv = mapping.originalHsv;
                        
                        // Calculate hue difference with wrap-around
                        let hueDiff = Math.abs(familyHsv[0] - mappingHsv[0]);
                        if (hueDiff > 180) hueDiff = 360 - hueDiff;
                        
                        // Weight the components differently
                        const isAchromatic = familyHsv[1] < 15 || mappingHsv[1] < 15;
                        
                        let score;
                        if (isAchromatic) {
                            // For achromatic colors, focus on brightness
                            score = (rgbDistance * 0.3) + (Math.abs(familyHsv[2] - mappingHsv[2]) * 2);
                        } else {
                            // For chromatic colors, prioritize hue match
                            score = (rgbDistance * 0.3) + (hueDiff * 0.5) + 
                                    (Math.abs(familyHsv[1] - mappingHsv[1]) * 0.3) + 
                                    (Math.abs(familyHsv[2] - mappingHsv[2]) * 0.2);
                        }
                        
                        if (score < bestScore) {
                            bestScore = score;
                            bestMappingIndex = i;
                        }
                    }
                    
                    // CHANGE: Use a threshold that scales with the number of color mappings
                    // More colors need more relaxed threshold to ensure proper mapping
                    const threshold = 60 + Math.min(40, processedMappings.length * 2);
                    
                    if (bestScore < threshold) {
                        family.mappingIndex = bestMappingIndex;
                    } else {
                        // For families without a good match, leave unmapped
                        family.mappingIndex = -1;
                    }
                });
            }
            
            // IMPROVED: Better color transformation logic
            function transformColor(r, g, b, mappingIndex, isGradient = false, gradientStrength = 0) {
                // Get the mapping
                const mapping = processedMappings[mappingIndex];
                
                // Get color in HSV space
                const pixelHsv = rgbToHsv(r, g, b);
                
                // Check if colors are very close to the original mapping color
                const originalRGB = mapping.originalColor;
                const rgbDistance = Math.sqrt(
                    Math.pow(r - originalRGB[0], 2) +
                    Math.pow(g - originalRGB[1], 2) +
                    Math.pow(b - originalRGB[2], 2)
                );
                
                // If very close to original color, use target color directly
                if (rgbDistance < 10) {
                    return mapping.targetColor;
                }
                
                // Check if color is achromatic (low saturation)
                const isAchromatic = pixelHsv[1] < 15;
                const isDark = pixelHsv[2] < 30;
                
                // Calculate relative brightness compared to the original mapping color
                // This is crucial for preserving shading and transparency effects
                const relativeBrightness = mapping.originalHsv[2] > 0 ? 
                    pixelHsv[2] / mapping.originalHsv[2] : 1;
                
                // Calculate hue difference with wrap-around handling
                let hueDiff = ((pixelHsv[0] - mapping.originalHsv[0] + 360) % 360);
                hueDiff = hueDiff > 180 ? hueDiff - 360 : hueDiff;
                
                // For saturation, calculate the relative value
                const relativeSaturation = mapping.originalHsv[1] > 0 ? 
                    pixelHsv[1] / mapping.originalHsv[1] : 1;
                
                // Different transformation strategy based on pixel characteristics
                let newHue, newSat, newVal;
                
                if (isAchromatic) {
                    // For grayscale, adopt target hue but preserve relative brightness
                    newHue = mapping.targetHsv[0];
                    
                    // Keep very low saturation for achromatic colors
                    newSat = Math.min(10, pixelHsv[1]);
                    
                    // Crucial: Preserve relative brightness for shading effects
                    newVal = Math.max(0, Math.min(100, mapping.targetHsv[2] * relativeBrightness));
                } 
                else if (isGradient) {
                    // For gradients, preserve the relative brightness even more carefully
                    
                    // Use target hue but adjust based on original variations for natural gradients
                    newHue = (mapping.targetHsv[0] + hueDiff * 0.3) % 360;
                    if (newHue < 0) newHue += 360;
                    
                    // Blend saturation but respect original variations
                    newSat = Math.max(5, Math.min(100, mapping.targetHsv[1] * relativeSaturation));
                    
                    // Most important: accurately preserve relative brightness
                    newVal = Math.max(0, Math.min(100, mapping.targetHsv[2] * relativeBrightness));
                } 
                else {
                    // For regular pixels, carefully preserve shading
                    if (isDark) {
                        // For dark areas, maintain darkness but use target hue
                        newHue = mapping.targetHsv[0];
                        newSat = Math.min(100, mapping.targetHsv[1] * 0.7);
                        
                        // Preserve darkness but map to target's darkness range
                        // This ensures dark areas remain distinguishable but adopt target color
                        newVal = Math.max(0, Math.min(40, mapping.targetHsv[2] * relativeBrightness));
                    } 
                    else {
                        // For normal colors, preserve shading variations
                        newHue = mapping.targetHsv[0];
                        
                        // Maintain saturation relationship to preserve texture
                        newSat = Math.max(0, Math.min(100, mapping.targetHsv[1] * relativeSaturation));
                        
                        // Crucial: accurately preserve brightness relationships
                        newVal = Math.max(0, Math.min(100, mapping.targetHsv[2] * relativeBrightness));
                    }
                }
                
                // Convert back to RGB
                return hsvToRgb(newHue, newSat, newVal);
            }
            
            // Main processing pipeline
            
            // Step 1: Detect gradients
            console.log("Detecting gradients...");
            const { gradientMap, gradientStrengthMap } = detectGradients();
            
            // Step 2: Identify color families
            console.log("Identifying color families...");
            const { colorFamilies, pixelFamilyMap } = identifyColorFamilies();
            
            // Step 3: Process mappings
            console.log("Processing color mappings...");
            const processedMappings = prepareColorMappings();
            
            // Step 4: Map families to mappings - IMPROVED for more colors
            console.log("Mapping color families to target colors...");
            mapFamiliesToMappings(colorFamilies, processedMappings);
            
            // CHANGE: Set a better default mapping for unmatched pixels
            // Find the most dominant mapping by counting pixels
            let mappingCounts = new Array(processedMappings.length).fill(0);
            colorFamilies.forEach(family => {
                if (family.mappingIndex !== -1) {
                    mappingCounts[family.mappingIndex] += family.count;
                }
            });
            
            let defaultMappingIndex = 0;
            let maxCount = mappingCounts[0];
            for (let i = 1; i < mappingCounts.length; i++) {
                if (mappingCounts[i] > maxCount) {
                    maxCount = mappingCounts[i];
                    defaultMappingIndex = i;
                }
            }
            
            console.log("Transforming colors...");

            // Use a cache for processed colors
            const transformCache = new Map();

            // Apply transformations
            for (let i = 0; i < data.length; i += 4) {
                if (data[i + 3] < 128) continue; // Skip transparent
                
                const r = data[i], g = data[i + 1], b = data[i + 2];
                
                // Only skip absolute black
                if (r <= 3 && g <= 3 && b <= 3) continue;
                
                const pixelIndex = Math.floor(i / 4);
                const familyIndex = pixelFamilyMap[pixelIndex];
                
                // Determine which mapping to use, with fallback for unassigned pixels
                let mappingToUse = defaultMappingIndex;
                
                if (familyIndex !== -1 && familyIndex < colorFamilies.length) {
                    const family = colorFamilies[familyIndex];
                    if (family.mappingIndex !== -1) {
                        mappingToUse = family.mappingIndex;
                    } else {
                        // CHANGE: For families with no mapping, find closest mapping directly
                        // This helps with more accurate color matching for many colors
                        const pixelHsv = rgbToHsv(r, g, b);
                        let bestDistance = Infinity;
                        
                        for (let j = 0; j < processedMappings.length; j++) {
                            const mappingHsv = processedMappings[j].originalHsv;
                            
                            // Weighted distance calculation for perceptual matching
                            let hueDiff = Math.abs(pixelHsv[0] - mappingHsv[0]);
                            if (hueDiff > 180) hueDiff = 360 - hueDiff;
                            
                            // For low saturation, focus on brightness
                            const distance = (pixelHsv[1] < 15 || mappingHsv[1] < 15) ? 
                                Math.abs(pixelHsv[2] - mappingHsv[2]) / 100 :
                                (hueDiff / 180) * 0.6 + 
                                Math.abs(pixelHsv[1] - mappingHsv[1]) / 100 * 0.2 + 
                                Math.abs(pixelHsv[2] - mappingHsv[2]) / 100 * 0.2;
                            
                            if (distance < bestDistance) {
                                bestDistance = distance;
                                mappingToUse = j;
                            }
                        }
                    }
                }
                
                // Check cache for this color and mapping combination
                const colorKey = `${r},${g},${b},${mappingToUse}`;
                if (transformCache.has(colorKey)) {
                    const cachedColor = transformCache.get(colorKey);
                    data[i] = cachedColor[0];
                    data[i + 1] = cachedColor[1];
                    data[i + 2] = cachedColor[2];
                    continue;
                }
                
                // Check if this pixel is part of a gradient
                const isGradient = gradientMap[pixelIndex];
                const gradientStrength = gradientStrengthMap[pixelIndex];
                
                // Transform the color
                const newColor = transformColor(r, g, b, mappingToUse, isGradient, gradientStrength);
                
                // Apply the transformed color
                data[i] = newColor[0];
                data[i + 1] = newColor[1];
                data[i + 2] = newColor[2];
                
                // Cache this transformation
                // CHANGE: Limit cache size to prevent memory issues with many colors
                if (transformCache.size < 100000) {
                    transformCache.set(colorKey, newColor);
                }
            }

            console.log("Finished color mapping!");

            // Apply the changes to the canvas
            ctx.putImageData(imageDataObj, 0, 0);
            const dataUrl = canvasElement.toDataURL('image/png');
            console.timeEnd('colorMapping');
            resolve(dataUrl);
        };
        img.src = imageData;
    });
}
async applyMultipleColorMappings(imageData, colorMappings, useJimp = false) {
  

  // If useJimp is true, send to the backend for Jimp processing
  if (useJimp) {
    console.log("Using Jimp for backend processing");
    try {
      // Create form data for sending to backend
      const formData = new FormData();
      
      // Handle image data based on format
      if (typeof imageData === 'string' && imageData.startsWith('data:image')) {
        // If it's a data URL, convert to blob
        try {
          const fetchResponse = await fetch(imageData);
          if (!fetchResponse.ok) throw new Error("Failed to fetch image data");
          const blob = await fetchResponse.blob();
          formData.append('image', blob, 'image.png');
          console.log("Added image as blob to form data");
        } catch (blobError) {
          console.error("Error converting data URL to blob:", blobError);
          // Fallback: send as base64 string
          formData.append('imageData', imageData);
          console.log("Added image as base64 string (fallback)");
        }
      } else {
        // For other formats (already blob, etc.)
        formData.append('imageData', imageData);
        console.log("Added image data to form data");
      }
      
      // Add color mappings as JSON string
      formData.append('colorMappings', JSON.stringify(colorMappings));
      
      
      // Send to backend endpoint with proper CORS settings
      console.log("Sending request to Jimp backend...");
      const response = await fetch('http://localhost:3000/api/process-image-with-jimp', {
        method: 'POST',
        body: formData,
        // No need to set Content-Type with FormData
        // Let the browser handle it with the correct multipart boundary
      });
      
      // Handle non-200 responses
      if (!response.ok) {
        const errorText = await response.text();
        console.error("Backend response error:", response.status, errorText);
        throw new Error(`Backend processing failed: ${response.status} ${response.statusText}`);
      }
      
      // Parse the JSON response
      const result = await response.json();
      
      if (!result.success || !result.processedImage) {
        console.error("Invalid response from backend:", result);
        throw new Error("Backend returned an invalid response format");
      }
      
      console.log("Successfully processed image with Jimp backend");
      return result.processedImage; // Base64 image data
    } catch (error) {
      console.error('Error with Jimp processing:', error);
      // Fall back to frontend processing if backend fails
     
      // Recursively call with useJimp=false to use frontend processing
      return this.applyMultipleColorMappings(imageData, colorMappings, false);
    }
  }
  
  // Otherwise, use the original frontend Canvas implementation
  return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
          console.time('colorMapping');
          const canvasElement = document.createElement('canvas');
          const ctx = canvasElement.getContext('2d');
          canvasElement.width = img.width;
          canvasElement.height = img.height;

          ctx.drawImage(img, 0, 0);
          const imageDataObj = ctx.getImageData(0, 0, img.width, img.height);
          const data = imageDataObj.data;

          // Color conversion utilities
          function rgbToLab(r, g, b) {
              r /= 255; g /= 255; b /= 255;

              r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
              g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
              b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;

              let x = (r * 0.4124564 + g * 0.3575761 + b * 0.1804375) * 100;
              let y = (r * 0.2126729 + g * 0.7151522 + b * 0.0721750) * 100;
              let z = (r * 0.0193339 + g * 0.1191920 + b * 0.9503041) * 100;

              x /= 95.047; y /= 100; z /= 108.883;

              x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + 16/116;
              y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + 16/116;
              z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + 16/116;

              return [
                  116 * y - 16,   // L
                  500 * (x - y),   // a
                  200 * (y - z)    // b
              ];
          }

          function rgbToHsv(r, g, b) {
              r /= 255; g /= 255; b /= 255;
              const max = Math.max(r, g, b);
              const min = Math.min(r, g, b);
              const d = max - min;
              let h, s = max === 0 ? 0 : d / max, v = max;

              if (max === min) {
                  h = 0;
              } else {
                  switch (max) {
                      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                      case g: h = (b - r) / d + 2; break;
                      case b: h = (r - g) / d + 4; break;
                  }
                  h /= 6;
              }
              return [h * 360, s * 100, v * 100];
          }

          function hsvToRgb(h, s, v) {
              h /= 360; s /= 100; v /= 100;
              let r, g, b;
              const i = Math.floor(h * 6);
              const f = h * 6 - i;
              const p = v * (1 - s);
              const q = v * (1 - f * s);
              const t = v * (1 - (1 - f) * s);

              switch (i % 6) {
                  case 0: r = v; g = t; b = p; break;
                  case 1: r = q; g = v; b = p; break;
                  case 2: r = p; g = v; b = t; break;
                  case 3: r = p; g = q; b = v; break;
                  case 4: r = t; g = p; b = v; break;
                  case 5: r = v; g = p; b = q; break;
              }

              return [
                  Math.round(r * 255),
                  Math.round(g * 255),
                  Math.round(b * 255)
              ];
          }

          // Calculate direct RGB distance
          function rgbDistance(r1, g1, b1, r2, g2, b2) {
              return Math.sqrt(
                  Math.pow(r1 - r2, 2) +
                  Math.pow(g1 - g2, 2) +
                  Math.pow(b1 - b2, 2)
              );
          }

          // LAB to RGB conversion
          function labToRgb(L, A, B) {
              let y = (L + 16) / 116;
              let x = A / 500 + y;
              let z = y - B / 200;
              
              x = 0.95047 * ((x * x * x > 0.008856) ? x * x * x : (x - 16/116) / 7.787);
              y = 1.00000 * ((y * y * y > 0.008856) ? y * y * y : (y - 16/116) / 7.787);
              z = 1.08883 * ((z * z * z > 0.008856) ? z * z * z : (z - 16/116) / 7.787);
              
              let rr = x *  3.2406 + y * -1.5372 + z * -0.4986;
              let gg = x * -0.9689 + y *  1.8758 + z *  0.0415;
              let bb = x *  0.0557 + y * -0.2040 + z *  1.0570;
              
              rr = (rr > 0.0031308) ? (1.055 * Math.pow(rr, 1/2.4) - 0.055) : 12.92 * rr;
              gg = (gg > 0.0031308) ? (1.055 * Math.pow(gg, 1/2.4) - 0.055) : 12.92 * gg;
              bb = (bb > 0.0031308) ? (1.055 * Math.pow(bb, 1/2.4) - 0.055) : 12.92 * bb;
              
              return [
                  Math.max(0, Math.min(255, Math.round(rr * 255))),
                  Math.max(0, Math.min(255, Math.round(gg * 255))),
                  Math.max(0, Math.min(255, Math.round(bb * 255)))
              ];
          }

          // Prepare all color mappings with their properties
          const processedMappings = colorMappings.map(mapping => {
              const originalColor = mapping.originalColor;
              const replacementColor = mapping.targetColor;

              
              // Get color properties
              const originalHsv = rgbToHsv(...originalColor);
              const replacementHsv = rgbToHsv(...replacementColor);
              const originalLab = rgbToLab(...originalColor);
              const replacementLab = rgbToLab(...replacementColor);
              
              // Only check if this is a black color (3,3,3 or less)
              const isBlack = originalColor[0] <= 3 && originalColor[1] <= 3 && originalColor[2] <= 3;
              
              return {
                  originalColor,
                  replacementColor,
                  originalHsv,
                  replacementHsv,
                  originalLab,
                  replacementLab,
                  isBlack
              };
          });

          // Create a cache for color transformations
          const transformCache = new Map();

          // Define tolerances - improved for better gradient handling
          const RGB_TOLERANCE = 80;       // Increased for better gradient detection
          const HUE_TOLERANCE = 20;       // Slightly increased
          const SAT_TOLERANCE = 25;       // Increased for better pattern handling
          const VAL_TOLERANCE = 30;       // Increased for better shade detection
          const LAB_TOLERANCE = 30;       // Increased for better perceptual matching
          
          // Maintain a gradient map - colors that are part of gradients
          const gradientColors = new Set();
          
          // First pass - identify gradient colors by analyzing local neighborhoods
          // This is simplified for performance, but could be more sophisticated
          if (img.width > 10 && img.height > 10) {  // Only for reasonably sized images
              for (let y = 1; y < img.height - 1; y++) {
                  for (let x = 1; x < img.width - 1; x++) {
                      const idx = (y * img.width + x) * 4;
                      if (data[idx + 3] < 128) continue; // Skip transparent
                      
                      // Get this pixel's color
                      const r = data[idx];
                      const g = data[idx + 1];
                      const b = data[idx + 2];
                      
                      // Skip true black
                      if (r <= 3 && g <= 3 && b <= 3) continue;
                      
                      // Check neighbors for gradient patterns
                      let isGradient = false;
                      
                      // Check horizontal neighbors
                      const leftIdx = (y * img.width + (x-1)) * 4;
                      const rightIdx = (y * img.width + (x+1)) * 4;
                      
                      if (data[leftIdx + 3] >= 128 && data[rightIdx + 3] >= 128) {
                          const leftDist = rgbDistance(r, g, b, data[leftIdx], data[leftIdx + 1], data[leftIdx + 2]);
                          const rightDist = rgbDistance(r, g, b, data[rightIdx], data[rightIdx + 1], data[rightIdx + 2]);
                          
                          // If colors change gradually, likely a gradient
                          if (leftDist < 15 && rightDist < 15 && leftDist + rightDist > 5) {
                              isGradient = true;
                          }
                      }
                      
                      // Check vertical neighbors if not already identified
                      if (!isGradient) {
                          const topIdx = ((y-1) * img.width + x) * 4;
                          const bottomIdx = ((y+1) * img.width + x) * 4;
                          
                          if (data[topIdx + 3] >= 128 && data[bottomIdx + 3] >= 128) {
                              const topDist = rgbDistance(r, g, b, data[topIdx], data[topIdx + 1], data[topIdx + 2]);
                              const bottomDist = rgbDistance(r, g, b, data[bottomIdx], data[bottomIdx + 1], data[bottomIdx + 2]);
                              
                              if (topDist < 15 && bottomDist < 15 && topDist + bottomDist > 5) {
                                  isGradient = true;
                              }
                          }
                      }
                      
                      // Mark as gradient for special handling
                      if (isGradient) {
                          gradientColors.add(`${r},${g},${b}`);
                      }
                  }
              }
          }

          // Process each pixel
          for (let i = 0; i < data.length; i += 4) {
              if (data[i + 3] < 128) continue; // Skip transparent pixels

              const r = data[i];
              const g = data[i + 1];
              const b = data[i + 2];
              
              // Skip pure black for efficiency (and we won't modify it)
              if (r <= 3 && g <= 3 && b <= 3) continue;
              
              // Create a key for the cache
              const colorKey = `${r},${g},${b}`;
              if (transformCache.has(colorKey)) {
                  const cachedColor = transformCache.get(colorKey);
                  data[i] = cachedColor[0];
                  data[i + 1] = cachedColor[1];
                  data[i + 2] = cachedColor[2];
                  continue;
              }
              
              // Check if this is a gradient color
              const isGradientColor = gradientColors.has(colorKey);
              
              // Find all matching mappings for this color with their scores
              const matchedMappings = [];
              
              for (const mapping of processedMappings) {
                  // Skip black mappings for non-black pixels
                  if (mapping.isBlack && !(r <= 3 && g <= 3 && b <= 3)) continue;
                  
                  // Direct RGB distance - fastest check
                  const rgbDist = rgbDistance(r, g, b, 
                      mapping.originalColor[0], 
                      mapping.originalColor[1], 
                      mapping.originalColor[2]);
                  
                  // Skip if too far in RGB space for efficiency
                  if (rgbDist > RGB_TOLERANCE * 1.5) continue;
                  
                  // Calculate pixel color in HSV space
                  const pixelHsv = rgbToHsv(r, g, b);
                  
                  // Calculate hue distance (accounting for circularity)
                  let hueDist = Math.abs(pixelHsv[0] - mapping.originalHsv[0]);
                  if (hueDist > 180) hueDist = 360 - hueDist;
                  
                  // Set a uniform matching criteria for all colors
                  const hueMultiplier = isGradientColor ? 1.3 : 1.0;
                  const satMultiplier = isGradientColor ? 1.4 : 1.0;
                  const valMultiplier = isGradientColor ? 1.3 : 1.0;
                  
                  const isColorMatch = 
                      hueDist < HUE_TOLERANCE * hueMultiplier && 
                      Math.abs(pixelHsv[1] - mapping.originalHsv[1]) < SAT_TOLERANCE * satMultiplier &&
                      Math.abs(pixelHsv[2] - mapping.originalHsv[2]) < VAL_TOLERANCE * valMultiplier;
                  
                  // If HSV check passes or RGB is close, do a more expensive Lab check
                  if (isColorMatch || rgbDist < RGB_TOLERANCE * (isGradientColor ? 0.7 : 0.5)) {
                      const pixelLab = rgbToLab(r, g, b);
                      
                      const labDistance = Math.sqrt(
                          Math.pow(pixelLab[0] - mapping.originalLab[0], 2) +
                          Math.pow(pixelLab[1] - mapping.originalLab[1], 2) +
                          Math.pow(pixelLab[2] - mapping.originalLab[2], 2)
                      );
                      
                      // For gradients and patterns, be more generous with matching
                      const labToleranceAdjusted = isGradientColor ? LAB_TOLERANCE * 1.3 : LAB_TOLERANCE;
                      
                      // Calculate match score - lower is better
                      // Combine different metrics with appropriate weights
                      const rgbScore = rgbDist / (isGradientColor ? RGB_TOLERANCE * 1.2 : RGB_TOLERANCE);
                      const labScore = labDistance / labToleranceAdjusted;
                      
                      // Emphasize LAB distance more for gradients (better perceptual matching)
                      const matchScore = isGradientColor ? 
                          (rgbScore * 0.2 + labScore * 0.8) : 
                          (rgbScore * 0.3 + labScore * 0.7);
                      
                      // If this is a reasonable match, save it with its score
                      if (matchScore < 1.2) {  // Slightly more permissive threshold
                          matchedMappings.push({
                              mapping,
                              matchScore
                          });
                      }
                  }
              }
              
              // Sort matched mappings by score (best matches first)
              matchedMappings.sort((a, b) => a.matchScore - b.matchScore);
              
              let newColor;
              
              // If we found at least one mapping
              if (matchedMappings.length > 0) {
                  // For gradient colors, blend between closest matches if we have multiple matches
                  if (isGradientColor && matchedMappings.length > 1) {
                      // Get the best two matches
                      const bestMapping = matchedMappings[0].mapping;
                      const secondBestMapping = matchedMappings[1].mapping;
                      const bestScore = matchedMappings[0].matchScore;
                      const secondBestScore = matchedMappings[1].matchScore;
                      
                      // Calculate weights for blending based on scores
                      // Lower score gets higher weight
                      const totalWeight = (1 - bestScore) + (1 - secondBestScore);
                      const bestWeight = (1 - bestScore) / totalWeight;
                      const secondWeight = (1 - secondBestScore) / totalWeight;
                      
                      // Calculate pixel in LAB space for smooth blending
                      const pixelLab = rgbToLab(r, g, b);
                      
                      // Calculate LAB deltas for both mappings
                      const labDelta1 = [
                          bestMapping.replacementLab[0] - bestMapping.originalLab[0],
                          bestMapping.replacementLab[1] - bestMapping.originalLab[1],
                          bestMapping.replacementLab[2] - bestMapping.originalLab[2]
                      ];
                      
                      const labDelta2 = [
                          secondBestMapping.replacementLab[0] - secondBestMapping.originalLab[0],
                          secondBestMapping.replacementLab[1] - secondBestMapping.originalLab[1],
                          secondBestMapping.replacementLab[2] - secondBestMapping.originalLab[2]
                      ];
                      
                      // Blend the two transformations
                      const blendedLab = [
                          pixelLab[0] + (labDelta1[0] * bestWeight + labDelta2[0] * secondWeight),
                          pixelLab[1] + (labDelta1[1] * bestWeight + labDelta2[1] * secondWeight),
                          pixelLab[2] + (labDelta1[2] * bestWeight + labDelta2[2] * secondWeight)
                      ];
                      
                      // Convert back to RGB
                      newColor = labToRgb(...blendedLab);
                  } 
                  else {
                      // Use the best match
                      const bestMapping = matchedMappings[0].mapping;
                      const matchScore = matchedMappings[0].matchScore;
                      
                      // Calculate pixel in HSV space for transformation
                      const pixelHsv = rgbToHsv(r, g, b);
                      
                      // Determine how close the match is (fuzzy threshold based on gradient status)
                      const exactMatchThreshold = isGradientColor ? 0.4 : 0.3;
                      const exactMatch = matchScore < exactMatchThreshold;
                      
                      if (exactMatch) {
                          // Direct replacement for very close matches
                          newColor = bestMapping.replacementColor;
                      } else {
                          // Calculate relative shifts
                          const hueDiff = bestMapping.replacementHsv[0] - bestMapping.originalHsv[0];
                          const satRatio = bestMapping.originalHsv[1] > 5 ? 
                                           bestMapping.replacementHsv[1] / bestMapping.originalHsv[1] : 1;
                          const valRatio = bestMapping.originalHsv[2] > 5 ? 
                                           bestMapping.replacementHsv[2] / bestMapping.originalHsv[2] : 1;
                          
                          // Apply transformations with gradient-aware adjustments
                          let newHue = (pixelHsv[0] + hueDiff) % 360;
                          if (newHue < 0) newHue += 360;
                          
                          // Preserve more of the original variation for gradients
                          const preservationFactor = isGradientColor ? 0.3 : 0.15;
                          
                          let newSat = Math.max(0, Math.min(100, 
                              (pixelHsv[1] * satRatio * (1 - preservationFactor)) + 
                              (pixelHsv[1] * preservationFactor)));
                              
                          let newVal = Math.max(0, Math.min(100, 
                              (pixelHsv[2] * valRatio * (1 - preservationFactor)) + 
                              (pixelHsv[2] * preservationFactor)));
                          
                          // Convert back to RGB
                          newColor = hsvToRgb(newHue, newSat, newVal);
                      }
                  }
                  
                  // Apply new color
                  data[i] = newColor[0];
                  data[i + 1] = newColor[1];
                  data[i + 2] = newColor[2];
                  
                  // Cache this transformation
                  transformCache.set(colorKey, newColor);
              }
          }

          ctx.putImageData(imageDataObj, 0, 0);
          const dataUrl = canvasElement.toDataURL('image/png');
          console.timeEnd('colorMapping');
          resolve(dataUrl);
      };
      img.src = imageData;
  });
}
  // Helper methods
  calculateAdaptiveThreshold(color, baseThreshold) {
      const saturation = color.hsv[1];
      const value = color.hsv[2];
      return baseThreshold * (1 + (1 - saturation) * 0.5) * (1 + (1 - value) * 0.5);
  }
  
  calculateHSVDifference(hsv1, hsv2) {
      const hueDiff = Math.abs(hsv1[0] - hsv2[0]) / 360;
      const satDiff = Math.abs(hsv1[1] - hsv2[1]);
      const valDiff = Math.abs(hsv1[2] - hsv2[2]);
      return (hueDiff + satDiff + valDiff) / 3;
  }
  
  calculateColorImportance(color) {
      const saturationWeight = 0.3;
      const valueWeight = 0.2;
      const frequencyWeight = 0.5;
  
      return (color.hsv[1] * saturationWeight) +
             (color.hsv[2] * valueWeight) +
             (color.percentage * frequencyWeight);
  }
  
  filterDistinctColors(colors) {
      const distinct = [];
      const minDistance = 15; // Minimum distance for distinct colors
  
      for (const color of colors) {
          const isDistinct = !distinct.some(existingColor =>
              this.calculateColorDistance(color.lab, existingColor.lab) < minDistance &&
              this.calculateHSVDifference(color.hsv, existingColor.hsv) < 0.2
          );
  
          if (isDistinct) {
              distinct.push(color);
          }
      }
  
      return distinct;
  }
  
  rgbToHsv(r, g, b) {
      r /= 255;
      g /= 255;
      b /= 255;
  
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      const diff = max - min;
  
      let h = 0;
      let s = max === 0 ? 0 : diff / max;
      let v = max;
  
      if (max !== min) {
          switch (max) {
              case r: h = (g - b) / diff + (g < b ? 6 : 0); break;
              case g: h = (b - r) / diff + 2; break;
              case b: h = (r - g) / diff + 4; break;
          }
          h /= 6;
      }
  
      return [h, s, v];
  }


  async applyColorMapping(imageData, colorMapping, targetColor, newColor, totalLayers) {

    
    return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
            const canvasElement = document.createElement('canvas');
            const ctx = canvasElement.getContext('2d');
            canvasElement.width = img.width;
            canvasElement.height = img.height;

            ctx.drawImage(img, 0, 0);
            const imageDataObj = ctx.getImageData(0, 0, img.width, img.height);
            const data = imageDataObj.data;

            // Original color (to be replaced)
            const originalColor = targetColor;
            // New color (to replace with)
            const replacementColor = newColor;

            // Color conversion utilities
            function rgbToLab(r, g, b) {
                r /= 255; g /= 255; b /= 255;

                r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
                g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
                b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;

                let x = (r * 0.4124564 + g * 0.3575761 + b * 0.1804375) * 100;
                let y = (r * 0.2126729 + g * 0.7151522 + b * 0.0721750) * 100;
                let z = (r * 0.0193339 + g * 0.1191920 + b * 0.9503041) * 100;

                x /= 95.047; y /= 100; z /= 108.883;

                x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + 16/116;
                y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + 16/116;
                z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + 16/116;

                return [
                    116 * y - 16,   // L
                    500 * (x - y),   // a
                    200 * (y - z)    // b
                ];
            }

            function rgbToHsv(r, g, b) {
                r /= 255; g /= 255; b /= 255;
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                const d = max - min;
                let h, s = max === 0 ? 0 : d / max, v = max;

                if (max === min) {
                    h = 0;
                } else {
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    h /= 6;
                }
                return [h * 360, s * 100, v * 100];
            }

            function hsvToRgb(h, s, v) {
                let r, g, b;
                const i = Math.floor(h * 6);
                const f = h * 6 - i;
                const p = v * (1 - s);
                const q = v * (1 - f * s);
                const t = v * (1 - (1 - f) * s);

                switch (i % 6) {
                    case 0: r = v; g = t; b = p; break;
                    case 1: r = q; g = v; b = p; break;
                    case 2: r = p; g = v; b = t; break;
                    case 3: r = p; g = q; b = v; break;
                    case 4: r = t; g = p; b = v; break;
                    case 5: r = v; g = p; b = q; break;
                }

                return [
                    Math.round(r * 255),
                    Math.round(g * 255),
                    Math.round(b * 255)
                ];
            }

            // Calculate direct RGB distance
            function rgbDistance(r1, g1, b1, r2, g2, b2) {
                return Math.sqrt(
                    Math.pow(r1 - r2, 2) +
                    Math.pow(g1 - g2, 2) +
                    Math.pow(b1 - b2, 2)
                );
            }

            // Get color properties of the colors we care about
            const originalHsv = rgbToHsv(...originalColor);
            const replacementHsv = rgbToHsv(...replacementColor);
            const originalLab = rgbToLab(...originalColor);

            // Define stricter tolerance for color matching
            // These can be adjusted based on the specific colors in your images
            const RGB_TOLERANCE = 60;       // Direct RGB distance (0-441)
            const HUE_TOLERANCE = 15;       // Hue degrees (0-180)
            const SAT_TOLERANCE = 15;       // Saturation % (0-100)
            const VAL_TOLERANCE = 20;       // Value % (0-100)
            const LAB_TOLERANCE = 25;       // Lab distance

            // If original color is very dark or very light, we need different handling
            const isOriginalDark = originalHsv[2] < 20;
            const isOriginalLight = originalHsv[2] > 90 && originalHsv[1] < 15;
            const isOriginalGray = originalHsv[1] < 15;
            
            // Process each pixel
            for (let i = 0; i < data.length; i += 4) {
                if (data[i + 3] < 128) continue; // Skip transparent pixels

                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                // Direct RGB distance - fastest check
                const rgbDist = rgbDistance(r, g, b, originalColor[0], originalColor[1], originalColor[2]);
                
                // Only compute other color spaces if the RGB distance is within a reasonable range
                if (rgbDist > RGB_TOLERANCE * 1.5) continue;
                
                // Calculate color spaces
                const pixelHsv = rgbToHsv(r, g, b);
                
                // Calculate hue distance (accounting for circularity)
                let hueDist = Math.abs(pixelHsv[0] - originalHsv[0]);
                if (hueDist > 180) hueDist = 360 - hueDist;
                
                // Determine if color is similar based on HSV
                let isColorMatch = false;
                
                // Special case for grays, blacks, whites
                if (isOriginalGray) {
                    // For gray colors, focus on brightness and saturation
                    isColorMatch = 
                        pixelHsv[1] < 20 && // Low saturation
                        Math.abs(pixelHsv[2] - originalHsv[2]) < VAL_TOLERANCE; // Similar brightness
                } 
                else if (isOriginalDark) {
                    // For dark colors, focus more on hue
                    isColorMatch = 
                        pixelHsv[2] < 25 && // Dark
                        (pixelHsv[1] < 20 || hueDist < HUE_TOLERANCE * 1.5); // Either unsaturated or similar hue
                }
                else if (isOriginalLight) {
                    // For light colors, focus more on hue
                    isColorMatch = 
                        pixelHsv[2] > 85 && // Light
                        pixelHsv[1] < 20;  // Low saturation
                }
                else {
                    // For normal colors, use stricter HSV matching
                    isColorMatch = 
                        hueDist < HUE_TOLERANCE && 
                        Math.abs(pixelHsv[1] - originalHsv[1]) < SAT_TOLERANCE &&
                        Math.abs(pixelHsv[2] - originalHsv[2]) < VAL_TOLERANCE;
                }
                
                // If HSV check passes, do a more expensive Lab check for confirmation
                if (isColorMatch || rgbDist < RGB_TOLERANCE/2) {
                    const pixelLab = rgbToLab(r, g, b);
                    
                    const labDistance = Math.sqrt(
                        Math.pow(pixelLab[0] - originalLab[0], 2) +
                        Math.pow(pixelLab[1] - originalLab[1], 2) +
                        Math.pow(pixelLab[2] - originalLab[2], 2)
                    );
                    
                    // Final decision based on Lab distance or very close RGB match
                    if (labDistance < LAB_TOLERANCE || rgbDist < RGB_TOLERANCE/3) {
                        // Apply color transformation
                        if (labDistance < LAB_TOLERANCE/2 || rgbDist < RGB_TOLERANCE/4) {
                            // Direct replacement for very close matches
                            data[i] = replacementColor[0];
                            data[i + 1] = replacementColor[1];
                            data[i + 2] = replacementColor[2];
                        } else {
                            // For less exact matches, transform while preserving some variation
                            // Calculate relative shifts
                            const hueDiff = replacementHsv[0] - originalHsv[0];
                            const satRatio = originalHsv[1] > 5 ? replacementHsv[1] / originalHsv[1] : 1;
                            const valRatio = originalHsv[2] > 5 ? replacementHsv[2] / originalHsv[2] : 1;
                            
                            // Apply transformations
                            let newHue = (pixelHsv[0] + hueDiff) % 360;
                            if (newHue < 0) newHue += 360;
                            
                            let newSat = Math.max(0, Math.min(100, pixelHsv[1] * satRatio));
                            let newVal = Math.max(0, Math.min(100, pixelHsv[2] * valRatio));
                            
                            // Convert back to RGB
                            const newRGB = hsvToRgb(newHue / 360, newSat / 100, newVal / 100);
                            
                            data[i] = newRGB[0];
                            data[i + 1] = newRGB[1];
                            data[i + 2] = newRGB[2];
                        }
                    }
                }
            }

            ctx.putImageData(imageDataObj, 0, 0);
            const dataUrl = canvasElement.toDataURL('image/png');
            resolve(dataUrl);
        };
        img.src = imageData;
    });
}
// Helper functions
calculateDeltaE(lab1, lab2) {
    const deltaL = lab1[0] - lab2[0];
    const deltaA = lab1[1] - lab2[1];
    const deltaB = lab1[2] - lab2[2];
    return Math.sqrt(deltaL * deltaL + deltaA * deltaA + deltaB * deltaB);
}

hsvToRgbProcessor(hsv) {
    let h = hsv[0];
    let s = hsv[1];
    let v = hsv[2];
    
    let r, g, b;
    const i = Math.floor(h * 6);
    const f = h * 6 - i;
    const p = v * (1 - s);
    const q = v * (1 - f * s);
    const t = v * (1 - (1 - f) * s);

    switch (i % 6) {
        case 0: r = v; g = t; b = p; break;
        case 1: r = q; g = v; b = p; break;
        case 2: r = p; g = v; b = t; break;
        case 3: r = p; g = q; b = v; break;
        case 4: r = t; g = p; b = v; break;
        case 5: r = v; g = p; b = q; break;
    }

    return [
        Math.round(r * 255),
        Math.round(g * 255),
        Math.round(b * 255)
    ];
}
}  


async function processHarmony(layerCtx, totalLayers, layerCanvas, currentLayerIndex, harmonyType) {
  const loadingScreen = document.getElementById('loading-screen');
  loadingScreen.style.display = 'block';
  const analyzer = new ImageColorAnalyzer();
  const colorProcessor = new ColorProcessor();

  try {
    // Create a collection name for this harmony type
    const harmonyCollection = harmonyType.toLowerCase().replace(/\s+/g, '_');
    
    console.log(`Processing ${harmonyType} harmony for layer ${currentLayerIndex}`);
    
    // Initialize harmonySeeds if it doesn't exist yet
    if (!window.harmonySeeds) {
      window.harmonySeeds = {
        'Monochromatic': Date.now(),
        'Analogous': Date.now() + 100,
        'Complementary': Date.now() + 200,
        'Split Complementary': Date.now() + 300,
        'Triadic': Date.now() + 400,
        'Tetradic': Date.now() + 500,
        'Square': Date.now() + 600
      };
    }
    
    // Function to robustly extract colors (similar to getPersistentColors in displayColorPalette)
    async function getImageColors(maxAttempts = 10) {
      let validColors = [];
      let attempts = 0;
      
      // Keep trying until we get valid colors
      while (validColors.length === 0 && attempts < maxAttempts) {
        attempts++;
        
        // First try to get colors from localStorage
        if (localStorage.getItem('distinctColorsArrayColorPallet')) {
          try {
            const storedColorsString = localStorage.getItem('distinctColorsArrayColorPallet');
            const storedColors = JSON.parse(storedColorsString);

            if (Array.isArray(storedColors) && storedColors.length > 0) {
              validColors = storedColors.filter(color =>
                Array.isArray(color) &&
                color.length === 3 &&
                color.every(val => typeof val === 'number' && !isNaN(val))
              );
              
              if (validColors.length > 0) {
                console.log(`Found ${validColors.length} valid colors in localStorage`);
                break;
              }
            }
          } catch (parseError) {
            console.error("Error parsing colors from localStorage:", parseError);
          }
        }
        
        // Second, try to get colors from window.distinctColorsArrayColorPallet
        try {
          if (typeof window.distinctColorsArrayColorPallet === 'function') {
            // Try to get as function
            const newColors = await window.distinctColorsArrayColorPallet();
            if (Array.isArray(newColors)) {
              validColors = newColors.filter(color => 
                Array.isArray(color) && 
                color.length === 3 && 
                color.every(val => typeof val === 'number' && !isNaN(val) && val >= 0 && val <= 255)
              );
            }
          } else if (window.distinctColorsArrayColorPallet) {
            // Try to get as variable
            const newColors = window.distinctColorsArrayColorPallet;
            if (Array.isArray(newColors)) {
              validColors = newColors.filter(color => 
                Array.isArray(color) && 
                color.length === 3 && 
                color.every(val => typeof val === 'number' && !isNaN(val) && val >= 0 && val <= 255)
              );
            }
          }
        } catch (e) {
          console.warn("Error accessing distinctColorsArrayColorPallet:", e);
        }
        
        // Third, if still no colors, try to extract from the canvas
        if (validColors.length === 0 && layerCtx && layerCanvas) {
          try {
            const imageData = layerCtx.getImageData(0, 0, layerCanvas.width, layerCanvas.height);
            const extractedColors = await analyzer.getDistinctColors(imageData, 30, 0);
            
            if (Array.isArray(extractedColors) && extractedColors.length > 0) {
              validColors = extractedColors.filter(color =>
                Array.isArray(color) &&
                color.length === 3 &&
                color.every(val => typeof val === 'number' && !isNaN(val))
              );
              
              if (validColors.length > 0) {
                console.log(`Extracted ${validColors.length} valid colors from image`);
                break;
              }
            }
          } catch (extractError) {
            console.error("Error extracting colors from image:", extractError);
          }
        }
        
        // If still no valid colors, wait a bit and try again
        if (validColors.length === 0) {
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      }
      
      // If we STILL don't have valid colors after all attempts,
      // use default fallback colors
      if (validColors.length === 0) {
        console.warn("Using fallback colors after exhausting all options");
        validColors = [
          [0, 32, 46],    // dark blue
          [0, 63, 92],    // blue
          [44, 72, 117],  // purple-blue
          [138, 80, 143], // purple
          [188, 80, 144], // magenta
          [255, 99, 97],  // red
          [255, 133, 49], // orange
          [255, 166, 0],  // yellow
          [255, 211, 128] // light yellow
        ];
      }
      
      return validColors;
    }
    
    // Color conversion utilities with improved error handling
    function rgbToHsl(r, g, b) {
      try {
        r /= 255;
        g /= 255;
        b /= 255;
        
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;
        
        if (max === min) {
          h = s = 0; // achromatic
        } else {
          const d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          
          switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
          }
          
          h /= 6;
        }
        
        return [h * 360, s * 100, l * 100];
      } catch (e) {
        console.error("Error in rgbToHsl:", e);
        return [0, 0, 50]; // Default to gray
      }
    }
    
    function hslToRgb(h, s, l) {
      try {
        // Normalize to 0-1 range
        h = (typeof h === 'number' && !isNaN(h)) ? (h % 360) / 360 : 0;
        s = (typeof s === 'number' && !isNaN(s)) ? Math.min(100, Math.max(0, s)) / 100 : 0;
        l = (typeof l === 'number' && !isNaN(l)) ? Math.min(100, Math.max(0, l)) / 100 : 0.5;
        
        let r, g, b;
        
        if (s === 0) {
          r = g = b = l; // achromatic
        } else {
          const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1/6) return p + (q - p) * 6 * t;
            if (t < 1/2) return q;
            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
          };
          
          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          const p = 2 * l - q;
          
          r = hue2rgb(p, q, h + 1/3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1/3);
        }
        
        return [
          Math.round(r * 255),
          Math.round(g * 255),
          Math.round(b * 255)
        ];
      } catch (e) {
        console.error("Error in hslToRgb:", e);
        return [128, 128, 128]; // Default to gray
      }
    }
    
    // Find the color distance between two colors
    function colorDistance(color1, color2) {
      try {
        const rDiff = color1[0] - color2[0];
        const gDiff = color1[1] - color2[1];
        const bDiff = color1[2] - color2[2];
        return Math.sqrt(rDiff * rDiff + gDiff * gDiff + bDiff * bDiff);
      } catch (e) {
        return 1000; // Large distance on error
      }
    }
    
    // Calculate perceptual color difference (better than simple distance)
    function perceptualColorDifference(rgb1, rgb2) {
      try {
        // Convert to HSL for better perception
        const hsl1 = rgbToHsl(...rgb1);
        const hsl2 = rgbToHsl(...rgb2);
        
        // Weight hue changes most heavily
        let hueDiff = Math.abs(hsl1[0] - hsl2[0]);
        hueDiff = Math.min(hueDiff, 360 - hueDiff); // Handle wraparound
        
        const satDiff = Math.abs(hsl1[1] - hsl2[1]);
        const lightDiff = Math.abs(hsl1[2] - hsl2[2]);
        
        // Weighted perception formula
        return (hueDiff * 1.5 + satDiff + lightDiff * 1.2);
      } catch (e) {
        return 1000; // Large difference on error
      }
    }
    
    // Helper function to convert RGB to hex for logging
    function rgbToHex(r, g, b) {
      return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }
    
    // Helper function to create a visual log of the colors
    function logPalette(palette, paletteName) {
      if (!palette || palette.length === 0) {
        console.log(`${paletteName}: No colors`);
        return;
      }
      
      console.log(`${paletteName} (${palette.length} colors):`);
      
      // Create a visualization that shows all colors in the console
      const colorBoxes = palette.map(([r, g, b]) => {
        const hex = rgbToHex(r, g, b);
        return `%c ${hex} `;
      }).join('');
      
      const styles = palette.map(([r, g, b]) => {
        const hex = rgbToHex(r, g, b);
        return `background: ${hex}; color: ${isLightColor(r, g, b) ? '#000' : '#fff'}; padding: 3px; border-radius: 3px;`;
      });
      
      console.log(colorBoxes, ...styles);
      
      // Also log the colors in array format for easier inspection
      console.log("Palette colors:", palette.map(color => [...color]));
    }
    
    // Check if a color is light (for determining text color in logs)
    function isLightColor(r, g, b) {
      // Formula to calculate relative luminance
      return (r * 0.299 + g * 0.587 + b * 0.114) > 128;
    }
    
    // Generate harmony palettes from image colors
    async function generateHarmonyPalettes(imageColors) {
      if (!window[`${harmonyCollection}PaletteColors`]) {
        window[`${harmonyCollection}PaletteColors`] = {};
      }
      
      // Get the total number of colors to use
      const totalColors = imageColors.length;
      console.log(`Total distinct colors available: ${totalColors}`);
      
      // Create 10 variations for each harmony type
      for (let i = 0; i < 10; i++) {
        let palette = [];
        
        // For each variation, choose a different base color
        const baseColorIndex = i % totalColors;
        const baseColor = imageColors[baseColorIndex];
        
        console.log(`Generating ${harmonyType} palette ${i} using base color:`, [...baseColor]);
        
        // Get the HSL values of the base color
        const [baseH, baseS, baseL] = rgbToHsl(...baseColor);
        
        switch(harmonyType) {
          case 'Monochromatic':
            palette = generateMonochromaticPalette(baseColor, imageColors);
            break;
          case 'Analogous':
            palette = generateAnalogousPalette(baseColor, imageColors);
            break;
          case 'Complementary':
            palette = generateComplementaryPalette(baseColor, imageColors);
            break;
          case 'Split Complementary':
            palette = generateSplitComplementaryPalette(baseColor, imageColors);
            break;
          case 'Triadic':
            palette = generateTriadicPalette(baseColor, imageColors);
            break;
          case 'Tetradic':
            palette = generateTetradicPalette(baseColor, imageColors);
            break;
          case 'Square':
            palette = generateSquarePalette(baseColor, imageColors);
            break;
          default:
            // If harmony type is not recognized, use all distinct colors
            palette = [...imageColors];
        }
        
        // Log the generated palette
        logPalette(palette, `${harmonyType} Palette ${i}`);
        
        // Store the generated palette
        window[`${harmonyCollection}PaletteColors`][i] = palette;
      }
      
      // Select a random palette and apply it immediately
      const randomIndex = Math.floor(Math.random() * 10);
      console.log(`Auto-applying random ${harmonyType} palette ${randomIndex}`);
      
      // Apply the randomly selected palette without showing previews
      if (typeof processPallet === 'function') {
        await processPallet(
          layerCtx, 
          totalLayers, 
          layerCanvas, 
          currentLayerIndex, 
          null, 
          harmonyCollection,
          randomIndex,
          true
        );
        
        // Show success message
        const toast = document.createElement('div');
        toast.textContent = `Applied ${harmonyType} palette ${randomIndex}`;
        toast.style.position = 'fixed';
        toast.style.bottom = '20px';
        toast.style.left = '50%';
        toast.style.transform = 'translateX(-50%)';
        toast.style.backgroundColor = 'rgba(0,0,0,0.7)';
        toast.style.color = 'white';
        toast.style.padding = '10px 20px';
        toast.style.borderRadius = '4px';
        toast.style.zIndex = '10001';
        document.body.appendChild(toast);
        
        setTimeout(() => {
          document.body.removeChild(toast);
        }, 2000);
      } else {
        console.error('processPallet function not available');
      }
    }
    
    // Generate a monochromatic palette preserving the nature of the original image colors
    function generateMonochromaticPalette(baseColor, imageColors) {
      try {
        // Get the hue from the base color
        const [baseH, baseS, baseL] = rgbToHsl(...baseColor);
        
        // Create a new palette using the base hue but preserving the saturation and lightness
        // distribution from the original colors
        const monoPalette = imageColors.map((color) => {
          const [_, originalS, originalL] = rgbToHsl(...color);
          
          // Use base hue with original saturation and lightness
          return hslToRgb(baseH, originalS, originalL);
        });
        
        // Ensure base color is included
        if (!monoPalette.some(color => perceptualColorDifference(color, baseColor) < 20)) {
          monoPalette[0] = [...baseColor]; // Make a copy to avoid reference issues
        }
        
        // Ensure we have good variation in lightness/saturation for a proper monochromatic palette
        const hslValues = monoPalette.map(color => rgbToHsl(...color));
        
        // Check if we have enough lightness variation
        const lightnesses = hslValues.map(hsl => hsl[2]);
        const lightRange = Math.max(...lightnesses) - Math.min(...lightnesses);
        
        // If insufficient lightness variation, add more variation
        if (lightRange < 40) {
          // Add lighter and darker variations
          monoPalette.push(hslToRgb(baseH, baseS, Math.min(baseL + 30, 95)));
          monoPalette.push(hslToRgb(baseH, baseS, Math.max(baseL - 30, 15)));
        }
        
        return monoPalette;
      } catch (error) {
        console.error("Error generating monochromatic palette:", error);
        return [baseColor, ...imageColors.slice(0, Math.min(imageColors.length - 1, 8))];
      }
    }
    
    // Generate analogous palette preserving the structure of the image colors
    function generateAnalogousPalette(baseColor, imageColors) {
      try {
        // Get the hue from the base color
        const [baseH, baseS, baseL] = rgbToHsl(...baseColor);
        
        // Analogous colors are within ±30° of the base hue
        // Calculate the hue range for analogous colors
        const analogousRange = 30; // ±30 degrees
        
        // Create a palette by shifting the hues of original colors while
        // preserving their original saturation and lightness
        const analogousPalette = imageColors.map((color, i) => {
          // Get original HSL values
          const [originalH, originalS, originalL] = rgbToHsl(...color);
          
          // Calculate a hue shift based on the original hue's distance from the base hue
          let hueDiff = originalH - baseH;
          
          // Handle wraparound for hue (0-360)
          if (hueDiff > 180) hueDiff -= 360;
          if (hueDiff < -180) hueDiff += 360;
          
          // Scale the hue difference to fit within the analogous range
          // This maintains the relative hue positions of colors
          const scaledHueDiff = hueDiff * (analogousRange / 180);
          
          // Calculate the new hue
          let newHue = baseH + scaledHueDiff;
          if (newHue < 0) newHue += 360;
          if (newHue >= 360) newHue -= 360;
          
          // Create the new color with shifted hue but original saturation and lightness
          return hslToRgb(newHue, originalS, originalL);
        });
        
        // Ensure base color is included
        if (!analogousPalette.some(color => perceptualColorDifference(color, baseColor) < 20)) {
          analogousPalette[0] = baseColor;
        }
        
        return analogousPalette;
      } catch (error) {
        console.error("Error generating analogous palette:", error);
        return [baseColor, ...imageColors.slice(0, Math.min(imageColors.length - 1, 8))];
      }
    }
    
    // Generate a complementary palette preserving color structures
    function generateComplementaryPalette(baseColor, imageColors) {
      try {
        // Get the hue from the base color
        const [baseH, baseS, baseL] = rgbToHsl(...baseColor);
        
        // Complementary color is 180° from the base hue
        const complementH = (baseH + 180) % 360;
        
        // Group original colors into two categories:
        // 1) Colors closer to the base hue
        // 2) Colors closer to the complement hue
        
        // Create a new palette based on the original colors
        const complementaryPalette = imageColors.map((color, i) => {
          const [h, s, l] = rgbToHsl(...color);
          
          // Calculate the distance from both the base hue and complement hue
          let distFromBase = Math.abs(h - baseH);
          if (distFromBase > 180) distFromBase = 360 - distFromBase;
          
          let distFromComplement = Math.abs(h - complementH);
          if (distFromComplement > 180) distFromComplement = 360 - distFromComplement;
          
          // If the original color is closer to the base hue, keep it in that hemisphere
          // Otherwise, shift it to the complementary hemisphere
          let newHue;
          if (distFromBase <= distFromComplement) {
            // Color is closer to base hue - keep in base hemisphere
            // Adjust hue slightly to enhance complementary feel
            const shiftAmount = (distFromBase / 180) * 30; // max 30° shift
            newHue = (baseH + shiftAmount) % 360;
          } else {
            // Color is closer to complementary hue - shift to complement hemisphere
            const shiftAmount = (distFromComplement / 180) * 30; // max 30° shift
            newHue = (complementH + shiftAmount) % 360;
          }
          
          // Create the new color with adjusted hue but original saturation and lightness
          return hslToRgb(newHue, s, l);
        });
        
        // Ensure both base color and a true complement are represented
        let hasBase = false;
        let hasComplement = false;
        
        for (const color of complementaryPalette) {
          const [h] = rgbToHsl(...color);
          const distFromBase = Math.abs(h - baseH);
          const distFromComplement = Math.abs(h - complementH);
          
          if (distFromBase < 15) hasBase = true;
          if (distFromComplement < 15) hasComplement = true;
          
          if (hasBase && hasComplement) break;
        }
        
        // Add base color if missing
        if (!hasBase) {
          complementaryPalette[0] = baseColor;
        }
        
        // Add true complement if missing
        if (!hasComplement) {
          const pureComplement = hslToRgb(complementH, baseS, baseL);
          complementaryPalette[complementaryPalette.length - 1] = pureComplement;
        }
        
        return complementaryPalette;
      } catch (error) {
        console.error("Error generating complementary palette:", error);
        return [baseColor, ...imageColors.slice(0, Math.min(imageColors.length - 1, 8))];
      }
    }
    
    // Generate a split complementary palette preserving color structures
    function generateSplitComplementaryPalette(baseColor, imageColors) {
      try {
        // Get the hue from the base color
        const [baseH, baseS, baseL] = rgbToHsl(...baseColor);
        
        // Split complementary colors are 150° and 210° from the base hue
        const splitComp1H = (baseH + 150) % 360;
        const splitComp2H = (baseH + 210) % 360;
        
        // Group original colors into three categories:
        // 1) Colors closer to the base hue
        // 2) Colors closer to split complement 1
        // 3) Colors closer to split complement 2
        
        // Create a new palette based on the original colors
        const splitPalette = imageColors.map((color, i) => {
          const [h, s, l] = rgbToHsl(...color);
          
          // Calculate distance to each key hue
          let distFromBase = Math.abs(h - baseH);
          if (distFromBase > 180) distFromBase = 360 - distFromBase;
          
          let distFromSplit1 = Math.abs(h - splitComp1H);
          if (distFromSplit1 > 180) distFromSplit1 = 360 - distFromSplit1;
          
          let distFromSplit2 = Math.abs(h - splitComp2H);
          if (distFromSplit2 > 180) distFromSplit2 = 360 - distFromSplit2;
          
          // Find which key hue this color is closest to
          const minDist = Math.min(distFromBase, distFromSplit1, distFromSplit2);
          
          let newHue;
          if (minDist === distFromBase) {
            // Color is closest to base - keep near base
            newHue = baseH;
          } else if (minDist === distFromSplit1) {
            // Color is closest to split 1 - shift toward split 1
            newHue = splitComp1H;
          } else {
            // Color is closest to split 2 - shift toward split 2
            newHue = splitComp2H;
          }
          
          // Add a small variation to avoid all colors being exactly at the key hues
          const variation = (i % 5) - 2; // -2 to +2 degrees
          newHue = (newHue + variation + 360) % 360;
          
          // Create the new color with adjusted hue but original saturation and lightness
          return hslToRgb(newHue, s, l);
        });
        
        // Ensure all three key hues are represented
        let hasBase = false;
        let hasSplit1 = false;
        let hasSplit2 = false;
        
        for (const color of splitPalette) {
          const [h] = rgbToHsl(...color);
          
          if (Math.abs(h - baseH) < 15 || Math.abs(h - baseH - 360) < 15) hasBase = true;
          if (Math.abs(h - splitComp1H) < 15) hasSplit1 = true;
          if (Math.abs(h - splitComp2H) < 15) hasSplit2 = true;
          
          if (hasBase && hasSplit1 && hasSplit2) break;
        }
        
        // Add missing key colors if necessary
        if (!hasBase) splitPalette[0] = baseColor;
        if (!hasSplit1) splitPalette[1] = hslToRgb(splitComp1H, baseS, baseL);
        if (!hasSplit2) splitPalette[2] = hslToRgb(splitComp2H, baseS, baseL);
        
        return splitPalette;
      } catch (error) {
        console.error("Error generating split complementary palette:", error);
        return [baseColor, ...imageColors.slice(0, Math.min(imageColors.length - 1, 8))];
      }
    }
    
    // Generate a triadic palette preserving color structures
    function generateTriadicPalette(baseColor, imageColors) {
      try {
        // Get the hue from the base color
        const [baseH, baseS, baseL] = rgbToHsl(...baseColor);
        
        // Triadic colors are 120° and 240° from the base hue
        const triad1H = (baseH + 120) % 360;
        const triad2H = (baseH + 240) % 360;
        
        // Group original colors into three categories based on closest triad hue
        const triadicPalette = imageColors.map((color, i) => {
          const [h, s, l] = rgbToHsl(...color);
          
          // Calculate distance to each key hue
          let distFromBase = Math.abs(h - baseH);
          if (distFromBase > 180) distFromBase = 360 - distFromBase;
          
          let distFromTriad1 = Math.abs(h - triad1H);
          if (distFromTriad1 > 180) distFromTriad1 = 360 - distFromTriad1;
          
          let distFromTriad2 = Math.abs(h - triad2H);
          if (distFromTriad2 > 180) distFromTriad2 = 360 - distFromTriad2;
          
          // Find which key hue this color is closest to
          const minDist = Math.min(distFromBase, distFromTriad1, distFromTriad2);
          
          let newHue;
          if (minDist === distFromBase) {
            // Color is closest to base - keep near base
            newHue = baseH;
          } else if (minDist === distFromTriad1) {
            // Color is closest to triad1 - shift toward triad1
            newHue = triad1H;
          } else {
            // Color is closest to triad2 - shift toward triad2
            newHue = triad2H;
          }
          
          // Add a small variation to avoid all colors being exactly at the key hues
          const variation = (i % 7) - 3; // -3 to +3 degrees
          newHue = (newHue + variation + 360) % 360;
          
          // Create the new color with adjusted hue but original saturation and lightness
          return hslToRgb(newHue, s, l);
        });
        
        // Ensure all three key hues are represented
        let hasBase = false;
        let hasTriad1 = false;
        let hasTriad2 = false;
        
        for (const color of triadicPalette) {
          const [h] = rgbToHsl(...color);
          
          if (Math.abs(h - baseH) < 15 || Math.abs(h - baseH - 360) < 15) hasBase = true;
          if (Math.abs(h - triad1H) < 15) hasTriad1 = true;
          if (Math.abs(h - triad2H) < 15) hasTriad2 = true;
          
          if (hasBase && hasTriad1 && hasTriad2) break;
        }
        
        // Add missing key colors if necessary
        if (!hasBase) triadicPalette[0] = baseColor;
        if (!hasTriad1) triadicPalette[1] = hslToRgb(triad1H, baseS, baseL);
        if (!hasTriad2) triadicPalette[2] = hslToRgb(triad2H, baseS, baseL);
        
        return triadicPalette;
      } catch (error) {
        console.error("Error generating triadic palette:", error);
        return [baseColor, ...imageColors.slice(0, Math.min(imageColors.length - 1, 8))];
      }
    }
    
    // Generate a tetradic (rectangle) palette preserving color structures
    function generateTetradicPalette(baseColor, imageColors) {
      try {
        // Get the hue from the base color
        const [baseH, baseS, baseL] = rgbToHsl(...baseColor);
        
        // Tetradic colors are at 60°, 180°, and 240° from the base hue
        const tetrad1H = (baseH + 60) % 360;
        const tetrad2H = (baseH + 180) % 360;
        const tetrad3H = (baseH + 240) % 360;
        
        // Group original colors into four categories based on closest tetrad hue
        const tetradicPalette = imageColors.map((color, i) => {
          const [h, s, l] = rgbToHsl(...color);
          
          // Calculate distance to each key hue
          let distFromBase = Math.abs(h - baseH);
          if (distFromBase > 180) distFromBase = 360 - distFromBase;
          
          let distFromTetrad1 = Math.abs(h - tetrad1H);
          if (distFromTetrad1 > 180) distFromTetrad1 = 360 - distFromTetrad1;
          
          let distFromTetrad2 = Math.abs(h - tetrad2H);
          if (distFromTetrad2 > 180) distFromTetrad2 = 360 - distFromTetrad2;
          
          let distFromTetrad3 = Math.abs(h - tetrad3H);
          if (distFromTetrad3 > 180) distFromTetrad3 = 360 - distFromTetrad3;
          
          // Find which key hue this color is closest to
          const minDist = Math.min(distFromBase, distFromTetrad1, distFromTetrad2, distFromTetrad3);
          
          let newHue;
          if (minDist === distFromBase) {
            newHue = baseH;
          } else if (minDist === distFromTetrad1) {
            newHue = tetrad1H;
          } else if (minDist === distFromTetrad2) {
            newHue = tetrad2H;
          } else {
            newHue = tetrad3H;
          }
          
          // Add a small variation to avoid all colors being exactly at the key hues
          const variation = (i % 9) - 4; // -4 to +4 degrees
          newHue = (newHue + variation + 360) % 360;
          
          // Create the new color with adjusted hue but original saturation and lightness
          return hslToRgb(newHue, s, l);
        });
        
        // Ensure all four key hues are represented
        let hasBase = false;
        let hasTetrad1 = false;
        let hasTetrad2 = false;
        let hasTetrad3 = false;
        
        for (const color of tetradicPalette) {
          const [h] = rgbToHsl(...color);
          
          if (Math.abs(h - baseH) < 15 || Math.abs(h - baseH - 360) < 15) hasBase = true;
          if (Math.abs(h - tetrad1H) < 15) hasTetrad1 = true;
          if (Math.abs(h - tetrad2H) < 15) hasTetrad2 = true;
          if (Math.abs(h - tetrad3H) < 15) hasTetrad3 = true;
          
          if (hasBase && hasTetrad1 && hasTetrad2 && hasTetrad3) break;
        }
        
        // Add missing key colors if necessary
        if (!hasBase) tetradicPalette[0] = baseColor;
        if (!hasTetrad1) tetradicPalette[1] = hslToRgb(tetrad1H, baseS, baseL);
        if (!hasTetrad2) tetradicPalette[2] = hslToRgb(tetrad2H, baseS, baseL);
        if (!hasTetrad3) tetradicPalette[3] = hslToRgb(tetrad3H, baseS, baseL);
        
        return tetradicPalette;
      } catch (error) {
        console.error("Error generating tetradic palette:", error);
        return [baseColor, ...imageColors.slice(0, Math.min(imageColors.length - 1, 8))];
      }
    }
    
    // Generate a square palette preserving color structures
    function generateSquarePalette(baseColor, imageColors) {
      try {
        // Get the hue from the base color
        const [baseH, baseS, baseL] = rgbToHsl(...baseColor);
        
        // Square colors are at 90°, 180°, and 270° from the base hue
        const square1H = (baseH + 90) % 360;
        const square2H = (baseH + 180) % 360;
        const square3H = (baseH + 270) % 360;
        
        // Group original colors into four categories based on closest square hue
        const squarePalette = imageColors.map((color, i) => {
          const [h, s, l] = rgbToHsl(...color);
          
          // Calculate distance to each key hue
          let distFromBase = Math.abs(h - baseH);
          if (distFromBase > 180) distFromBase = 360 - distFromBase;
          
          let distFromSquare1 = Math.abs(h - square1H);
          if (distFromSquare1 > 180) distFromSquare1 = 360 - distFromSquare1;
          
          let distFromSquare2 = Math.abs(h - square2H);
          if (distFromSquare2 > 180) distFromSquare2 = 360 - distFromSquare2;
          
          let distFromSquare3 = Math.abs(h - square3H);
          if (distFromSquare3 > 180) distFromSquare3 = 360 - distFromSquare3;
          
          // Find which key hue this color is closest to
          const minDist = Math.min(distFromBase, distFromSquare1, distFromSquare2, distFromSquare3);
          
          let newHue;
          if (minDist === distFromBase) {
            newHue = baseH;
          } else if (minDist === distFromSquare1) {
            newHue = square1H;
          } else if (minDist === distFromSquare2) {
            newHue = square2H;
          } else {
            newHue = square3H;
          }
          
          // Add a small variation to avoid all colors being exactly at the key hues
          const variation = (i % 9) - 4; // -4 to +4 degrees
          newHue = (newHue + variation + 360) % 360;
          
          // Create the new color with adjusted hue but original saturation and lightness
          return hslToRgb(newHue, s, l);
        });
        
        // Ensure all four key hues are represented
        let hasBase = false;
        let hasSquare1 = false;
        let hasSquare2 = false;
        let hasSquare3 = false;
        
        for (const color of squarePalette) {
          const [h] = rgbToHsl(...color);
          
          if (Math.abs(h - baseH) < 15 || Math.abs(h - baseH - 360) < 15) hasBase = true;
          if (Math.abs(h - square1H) < 15) hasSquare1 = true;
          if (Math.abs(h - square2H) < 15) hasSquare2 = true;
          if (Math.abs(h - square3H) < 15) hasSquare3 = true;
          
          if (hasBase && hasSquare1 && hasSquare2 && hasSquare3) break;
        }
        
        // Add missing key colors if necessary
        if (!hasBase) squarePalette[0] = baseColor;
        if (!hasSquare1) squarePalette[1] = hslToRgb(square1H, baseS, baseL);
        if (!hasSquare2) squarePalette[2] = hslToRgb(square2H, baseS, baseL);
        if (!hasSquare3) squarePalette[3] = hslToRgb(square3H, baseS, baseL);
        
        return squarePalette;
      } catch (error) {
        console.error("Error generating square palette:", error);
        return [baseColor, ...imageColors.slice(0, Math.min(imageColors.length - 1, 8))];
      }
    }
    
    // Main execution flow
    
    // 1. Extract colors from the image using the robust method
    const imageColors = await getImageColors();
    
    if (!imageColors || imageColors.length === 0) {
      throw new Error("Could not extract colors from the image");
    }
    
    console.log(`Successfully extracted ${imageColors.length} colors from the image`);
    
    // 2. Generate the harmony palettes and auto-apply
    await generateHarmonyPalettes(imageColors);
    
  } catch (error) {
    console.error("Error while processing harmony:", error);
    alert(`Error processing ${harmonyType} harmony: ${error.message}`);
  } finally {
    loadingScreen.style.display = 'none';
  }
}

// Add keyboard shortcuts to test different harmony types
document.addEventListener('keydown', function(event) {
  if (event.ctrlKey && event.altKey) {
    const canvas = document.getElementById('layer_canvas_1');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    
    switch(event.key) {
      case '1':
        processHarmony(ctx, 1, canvas, 0, 'Monochromatic');
        break;
      case '2':
        processHarmony(ctx, 1, canvas, 0, 'Analogous');
        break;
      case '3':
        processHarmony(ctx, 1, canvas, 0, 'Complementary');
        break;
      case '4':
        processHarmony(ctx, 1, canvas, 0, 'Split Complementary');
        break;
      case '5':
        processHarmony(ctx, 1, canvas, 0, 'Triadic');
        break;
      case '6':
        processHarmony(ctx, 1, canvas, 0, 'Tetradic');
        break;
      case '7':
        processHarmony(ctx, 1, canvas, 0, 'Square');
        break;
    }
  }
});





// Function to check if two colors are similar
function isColorSimilar(color1, color2, threshold = 30) {
  // Calculate Euclidean distance between colors in RGB space
  const rDiff = color1[0] - color2[0];
  const gDiff = color1[1] - color2[1];
  const bDiff = color1[2] - color2[2];
  
  const distance = Math.sqrt(rDiff * rDiff + gDiff * gDiff + bDiff * bDiff);
  return distance < threshold;
}

// Add HSV conversion functions first
function rgbToHsv(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;

  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  let h, s, v = max;
  const d = max - min;
  s = max === 0 ? 0 : d / max;

  if (max === min) {
      h = 0;
  } else {
      switch (max) {
          case r: h = (g - b) / d + (g < b ? 6 : 0); break;
          case g: h = (b - r) / d + 2; break;
          case b: h = (r - g) / d + 4; break;
      }
      h /= 6;
  }

  return [h, s, v];
}

function hsvToRgb(hsv) {
  let h = hsv[0];
  let s = hsv[1];
  let v = hsv[2];
  
  let r, g, b;
  const i = Math.floor(h * 6);
  const f = h * 6 - i;
  const p = v * (1 - s);
  const q = v * (1 - f * s);
  const t = v * (1 - (1 - f) * s);

  switch (i % 6) {
      case 0: r = v; g = t; b = p; break;
      case 1: r = q; g = v; b = p; break;
      case 2: r = p; g = v; b = t; break;
      case 3: r = p; g = q; b = v; break;
      case 4: r = t; g = p; b = v; break;
      case 5: r = v; g = p; b = q; break;
  }

  return [
      Math.round(r * 255),
      Math.round(g * 255),
      Math.round(b * 255)
  ];
}



// Color Conversion Utilities
function rgbToHsl(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;

  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  let h, s, l = (max + min) / 2;

  if (max === min) {
      h = s = 0;
  } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

      switch (max) {
          case r: h = (g - b) / d + (g < b ? 6 : 0); break;
          case g: h = (b - r) / d + 2; break;
          case b: h = (r - g) / d + 4; break;
      }
      h /= 6;
  }

  return [h, s, l];
}

function hslToRgb(h, s, l) {
  // Validate and normalize inputs to ensure they're in the right range
  console.log(`hslToRgb input - h: ${h}, s: ${s}, l: ${l}`);
  
  // Normalize h to 0-1 range if needed
  if (h > 1) {
    h = h / 360;
  }
  
  // Normalize s and l to 0-1 range if needed
  if (s > 1) {
    s = s / 100;
  }
  
  if (l > 1) {
    l = l / 100;
  }
  
  // Safety checks
  h = Math.max(0, Math.min(1, h));
  s = Math.max(0, Math.min(1, s));
  l = Math.max(0, Math.min(1, l));
  
  console.log(`normalized - h: ${h}, s: ${s}, l: ${l}`);
  
  let r, g, b;

  if (s === 0) {
    r = g = b = l; // achromatic
  } else {
    const hue2rgb = (p, q, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };

    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;

    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }
  
  const rgb = [
    Math.round(r * 255),
    Math.round(g * 255),
    Math.round(b * 255)
  ];
  
  console.log(`Output RGB: ${rgb[0]}, ${rgb[1]}, ${rgb[2]}`);
  
  return rgb;
}


const harmonySeeds = {
  'Monochromatic': Date.now(),
  'Analogous': Date.now() + 100,
  'Complementary': Date.now() + 200,
  'Split Complementary': Date.now() + 300,
  'Triadic': Date.now() + 400,
  'Tetradic': Date.now() + 500,
  'Square': Date.now() + 600
};

function seededRandom(seed) {
  const a = 1664525;
  const c = 1013904223;
  const m = Math.pow(2, 32);
  let z = seed;
  
  return function() {
      z = (a * z + c) % m;
      return z / m;
  };
}


// Helper function to add subtle variations to colors
function addVariation(value, amount, min = 0, max = 1) {
  const variation = (Math.random() - 0.5) * 2 * amount;
  return Math.max(min, Math.min(max, value + variation));
}


document.addEventListener('DOMContentLoaded', function() {
  const harmonyButton = document.getElementById('harmonyButton');
  const harmonyMenu = document.getElementById('harmonyMenu');
  let selectedHarmony = '';

  // Toggle menu on button click
  harmonyButton.addEventListener('click', function(e) {
      e.stopPropagation();
      harmonyMenu.style.display = harmonyMenu.style.display === 'none' ? 'block' : 'none';
  });

  // Handle menu item selection
  document.querySelectorAll('.menu-item').forEach(item => {
      item.addEventListener('click', function(e) {
          e.stopPropagation();
          selectedHarmony = this.dataset.harmony;
          
          // Remove active class from all items
          document.querySelectorAll('.menu-item').forEach(i => i.classList.remove('active'));
          // Add active class to selected item
          this.classList.add('active');
          
          // Close menu
          harmonyMenu.style.display = 'none';
          
          // Process harmony
          const totalLayers = document.querySelectorAll('[id^="layer_canvas_"]').length;
          const firstCanvas = document.getElementById('layer_canvas_1');
          if (firstCanvas) {
              const ctx = firstCanvas.getContext('2d');
              processHarmony(ctx, totalLayers, firstCanvas, 0, selectedHarmony);
          }
      });
  });

  // Close menu when clicking outside
  document.addEventListener('click', function(e) {
      if (!harmonyButton.contains(e.target) && !harmonyMenu.contains(e.target)) {
          harmonyMenu.style.display = 'none';
      }
  });

  // Prevent menu from closing when clicking inside it
  harmonyMenu.addEventListener('click', function(e) {
      e.stopPropagation();
  });
});



class ImageAdjuster {
  constructor() {
        this.adjustments = {
            combined: {
                hue: 0,
                saturation: 0,
                brightness: 0,
                temperature: 0
            }
        };
        this.showIndividualLayers = false;
        this.setupEventListeners();
        this.originalImageData = {}; // Change to object to store data for each layer
    }

    setupEventListeners() {
        const toggleButton = document.getElementById('adjustmentToggle');
        const adjustmentPanel = document.getElementById('adjustmentPanel');

        toggleButton.addEventListener('click', () => {
            const isHidden = adjustmentPanel.style.display === 'none';
            adjustmentPanel.style.display = isHidden ? 'block' : 'none';
            if (isHidden) {
                this.createAdjustmentSliders();
            }
        });
    }

    createAdjustmentSliders() {
        const container = document.querySelector('.sliders-container');
        container.innerHTML = '';

        // Add toggle button for individual layers
        const toggleLayersBtn = document.createElement('button');
        toggleLayersBtn.textContent = this.showIndividualLayers ? 'Show Combined Layer' : 'Show Individual Layers';
        toggleLayersBtn.className = 'toggle-layers-btn';
        toggleLayersBtn.style.cssText = `
            margin-bottom: 15px;
            padding: 8px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
        `;
        toggleLayersBtn.addEventListener('click', () => {
            this.showIndividualLayers = !this.showIndividualLayers;
            this.createAdjustmentSliders();
        });
        container.appendChild(toggleLayersBtn);

        if (!this.showIndividualLayers) {
            // Create combined layer controls
            const combinedDiv = document.createElement('div');
            combinedDiv.className = 'layer-adjustments';
            combinedDiv.innerHTML = `
                <h4>All Layers</h4>
                <div class="slider-group">
                    <label>Hue</label>
                    <input type="range" min="-180" max="180" value="${this.adjustments.combined.hue}" 
                           data-layer="combined" data-adjustment="hue">
                </div>
                <div class="slider-group">
                    <label>Saturation</label>
                    <input type="range" min="-100" max="100" value="${this.adjustments.combined.saturation}" 
                           data-layer="combined" data-adjustment="saturation">
                </div>
                <div class="slider-group">
                    <label>Brightness</label>
                    <input type="range" min="-100" max="100" value="${this.adjustments.combined.brightness}" 
                           data-layer="combined" data-adjustment="brightness">
                </div>
                <div class="slider-group">
                    <label>Temperature</label>
                    <input type="range" min="-100" max="100" value="${this.adjustments.combined.temperature}" 
                           data-layer="combined" data-adjustment="temperature">
                </div>
            `;
            container.appendChild(combinedDiv);

            this.setupSliderListeners(combinedDiv);
        } else {
            // Create individual layer controls
            const layerCanvases = document.querySelectorAll('[id^="layer_canvas_"]');
            
            layerCanvases.forEach(layerCanvas => {
                const layer = layerCanvas.id.split('_')[2];
                
                // Initialize layer adjustments if they don't exist
                if (!this.adjustments[layer]) {
                    this.adjustments[layer] = {
                        hue: 0,
                        saturation: 0,
                        brightness: 0,
                        temperature: 0
                    };
                }

                const layerDiv = document.createElement('div');
                layerDiv.className = 'layer-adjustments';
                layerDiv.innerHTML = `
                    <h4>Layer ${layer}</h4>
                    <div class="slider-group">
                        <label>Hue</label>
                        <input type="range" min="-180" max="180" value="${this.adjustments[layer].hue}" 
                               data-layer="${layer}" data-adjustment="hue">
                    </div>
                    <div class="slider-group">
                        <label>Saturation</label>
                        <input type="range" min="-100" max="100" value="${this.adjustments[layer].saturation}" 
                               data-layer="${layer}" data-adjustment="saturation">
                    </div>
                    <div class="slider-group">
                        <label>Brightness</label>
                        <input type="range" min="-100" max="100" value="${this.adjustments[layer].brightness}" 
                               data-layer="${layer}" data-adjustment="brightness">
                    </div>
                    <div class="slider-group">
                        <label>Temperature</label>
                        <input type="range" min="-100" max="100" value="${this.adjustments[layer].temperature}" 
                               data-layer="${layer}" data-adjustment="temperature">
                    </div>
                `;

                container.appendChild(layerDiv);
                this.setupSliderListeners(layerDiv);
            });
        }
    }

    setupSliderListeners(containerDiv) {
        containerDiv.querySelectorAll('input[type="range"]').forEach(slider => {
            slider.addEventListener('input', (e) => {
                const layer = e.target.dataset.layer;
                const adjustment = e.target.dataset.adjustment;
                
                // Initialize layer adjustments if they don't exist
                if (!this.adjustments[layer]) {
                    this.adjustments[layer] = {
                        hue: 0,
                        saturation: 0,
                        brightness: 0,
                        temperature: 0
                    };
                }

                this.adjustments[layer][adjustment] = parseInt(e.target.value);
                
                if (layer === 'combined') {
                    // Apply to all layers
                    const layerCanvases = document.querySelectorAll('[id^="layer_canvas_"]');
                    layerCanvases.forEach(canvas => {
                        const layerNum = canvas.id.split('_')[2];
                        // Initialize layer adjustments if they don't exist
                        if (!this.adjustments[layerNum]) {
                            this.adjustments[layerNum] = {
                                hue: 0,
                                saturation: 0,
                                brightness: 0,
                                temperature: 0
                            };
                        }
                        this.adjustments[layerNum][adjustment] = parseInt(e.target.value);
                        this.applyAdjustments(layerNum);
                    });
                } else {
                    this.applyAdjustments(layer);
                }
            });
        });
    }

    applyAdjustments(layer) {
    const layerCanvas = document.getElementById(`layer_canvas_${layer}`);
    if (!layerCanvas) return;

    if (!this.adjustments[layer]) {
        this.adjustments[layer] = {
            hue: 0,
            saturation: 0,
            brightness: 0,
            temperature: 0
        };
    }

    const ctx = layerCanvas.getContext('2d');
    const imageData = ctx.getImageData(0, 0, layerCanvas.width, layerCanvas.height);
    const data = imageData.data;

    // Store original image data if not already stored for this layer
    if (!this.originalImageData[layer]) {
        this.originalImageData[layer] = new Uint8ClampedArray(data);
    }

    for (let i = 0; i < data.length; i += 4) {
        // Start from original values for this layer
        let r = this.originalImageData[layer][i];
        let g = this.originalImageData[layer][i + 1];
        let b = this.originalImageData[layer][i + 2];

            // Apply temperature adjustment
            const temp = this.adjustments[layer].temperature;
            if (temp !== 0) {
                const adjustment = temp / 100;
                if (adjustment > 0) {
                    // Warming: increase red, decrease blue
                    r = Math.min(255, r + (adjustment * 30));
                    b = Math.max(0, b - (adjustment * 30));
                } else {
                    // Cooling: decrease red, increase blue
                    r = Math.max(0, r - (Math.abs(adjustment) * 30));
                    b = Math.min(255, b + (Math.abs(adjustment) * 30));
                }
            }

            // Convert to HSL for other adjustments
            let [h, s, l] = this.rgbToHsl(r, g, b);

            // Apply other adjustments
            h = (h + this.adjustments[layer].hue) % 360;
            if (h < 0) h += 360;
            s = Math.max(0, Math.min(100, s + this.adjustments[layer].saturation));
            l = Math.max(0, Math.min(100, l + this.adjustments[layer].brightness));

            // Convert back to RGB
            [r, g, b] = this.hslToRgb(h, s, l);

            // Set final values
            data[i] = Math.round(Math.max(0, Math.min(255, r)));
            data[i + 1] = Math.round(Math.max(0, Math.min(255, g)));
            data[i + 2] = Math.round(Math.max(0, Math.min(255, b)));
            // Alpha channel remains unchanged
        }

        ctx.putImageData(imageData, 0, 0);
    }


    rgbToHsl(r, g, b) {
        r /= 255;
        g /= 255;
        b /= 255;

        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;

        if (max === min) {
            h = s = 0;
        } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }

        return [h * 360, s * 100, l * 100];
    }

    hslToRgb(h, s, l) {
        h /= 360;
        s /= 100;
        l /= 100;

        let r, g, b;

        if (s === 0) {
            r = g = b = l;
        } else {
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            };

            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;

            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
        }

        return [r * 255, g * 255, b * 255];
    }
}


let distinctColorsArray = [];
let distinctColorsArrayColorPallet = [];
// Initialize the adjuster
const imageAdjuster = new ImageAdjuster();


      function showLayerInfoButton(layerIndex) {
        // Save current canvas state before showing modal
        const canvas = document.getElementById(`layer_canvas_${layerIndex + 1}`);
        if (canvas) {
            const currentState = canvas.toDataURL();
            canvas.setAttribute('data-current-state', currentState);
        }

        $('#colorPickerModal').modal('show');
        updateLayersWithNewColorCount(layerIndex + 1);
      }
      function showLayerInfo() {
         contextMenu.style.display = 'none';
         $('#colorPickerModal').modal('show');
         const layerIndex = contextMenu.dataset.layerIndex; // Assuming contextMenu is defined

         updateLayersWithNewColorCount(layerIndex);
       }
      document.addEventListener('DOMContentLoaded', function() {
        const layerColors = {};
        const loadingScreen = document.getElementById('loading-screen');
        const totalLayers = {{ layers|length }};
        let loadedImagesCount = 0;
        const loader = document.getElementById('loading-screen');
        function showContextMenu(event, layerIndex, layerName) {

          event.preventDefault();

          // Set the layer name in the context menu
          layerNameDisplay.innerText = layerName;

          // Get the clicked thumbnail’s coordinates
          const thumbnail = event.target.getBoundingClientRect();
          const toolbarWidth = document.querySelector('.toolbar').offsetWidth;

          // Position the context menu aligned to the toolbar, on the left side of the thumbnail
          contextMenu.style.left = `${thumbnail.left - toolbarWidth - 20}px`; // Adjust as needed
          contextMenu.style.top = `${thumbnail.top + window.scrollY}px`;
          contextMenu.style.display = 'block';
          contextMenu.dataset.layerIndex = layerIndex;

          // Temporarily disable pointer events to avoid immediate hiding
          setTimeout(() => {
            contextMenu.style.pointerEvents = 'auto';
          }, 0);
        }

        // Hide the context menu on clicking outside
        document.addEventListener('click', function(event) {
          if (contextMenu.style.display === 'block' && !contextMenu.contains(event.target) && !event.target.classList.contains('thumbnail')) {
            contextMenu.style.display = 'none';
          }
        });
        function checkIfAllImagesLoaded() {
            if (loadedImagesCount === totalLayers) {
                loadingScreen.style.display = 'none';
                createColorButtons();
            }
        }

      
        function isColorInArray(color, array) {
          return array.some(existingColor =>
              existingColor[0] === color[0] &&
              existingColor[1] === color[1] &&
              existingColor[2] === color[2]
          );
        }
        let distinctColorsArray = [];
        let singleLayerDistinctColorsArray = [];
        let distinctColorsArrayColorPallet = [];

        {% for layer in layers %}
        let img{{ forloop.counter }} = new Image();
        img{{ forloop.counter }}.src = "{{ layer.path }}";
        let canvas{{ forloop.counter }} = document.getElementById('layer_canvas_{{ forloop.counter }}');
        let ctx{{ forloop.counter }} = canvas{{ forloop.counter }}.getContext('2d', { willReadFrequently: true });
        let latestImageData{{ forloop.counter }} = null;
        img{{ forloop.counter }}.onload = function() {
          canvas{{ forloop.counter }}.width = img{{ forloop.counter }}.width;
          canvas{{ forloop.counter }}.height = img{{ forloop.counter }}.height;
          ctx{{ forloop.counter }}.drawImage(img{{ forloop.counter }}, 0, 0);
            layerStates.saveOriginalState({{ forloop.counter }});
            {% comment %} latestImageData{{ forloop.counter }} = ctx{{ forloop.counter }}.getImageData(0, 0, canvas{{ forloop.counter }}.width, canvas{{ forloop.counter }}.height); {% endcomment %}
            const imageData{{ forloop.counter }} = ctx{{ forloop.counter }}.getImageData(0, 0, canvas{{ forloop.counter }}.width, canvas{{ forloop.counter }}.height);

            // Add distinct colors to the set (ensures no duplicates)
            let colorCount = 0;
            let distinctColorTolarance = 0;
            
            if(totalLayers === 1) {
                // For single layer, get more colors with less tolerance
                distinctColorTolarance = 100; // Lower tolerance to detect more color variations
                colorCount = 20;  // Get more colors for single layer
            } else if(totalLayers > 5) {
                distinctColorTolarance = 180;
                colorCount = 7;
            } else {
                distinctColorTolarance = 190;
                colorCount = 7;
            }
            
            const analysis = analyzeImageLayer(ctx{{ forloop.counter }});
            let { avgLightness, hueTolerance, lightnessTolerance } = analysis;
            hueTolerance = hueTolerance*100;
            if(lightnessTolerance<0.5) lightnessTolerance=0.7;
            
            // Now this should return more colors for single layer
            let distinctColors{{ forloop.counter }} = getDistinctColors(imageData{{ forloop.counter }}, 30, 50);
            console.log(distinctColors{{ forloop.counter }})
            //console.info(distinctColors{{forloop.counter}});
            

            distinctColors{{ forloop.counter }}.forEach((color, index) => {
              if (!isColorInArray(color, distinctColorsArray)) {
                // Remove the index == 0 condition to allow more colors
                // if(index == 0){  // Remove this condition
                  distinctColorsArrayColorPallet.push(color);
                // }  // Remove this
                distinctColorsArray.push(color);
              }
            });

    


            // Create a thumbnail
            const thumbnailCanvas = document.createElement('canvas');
            const thumbnailSize = 30;
            thumbnailCanvas.width = thumbnailSize;
            thumbnailCanvas.height = thumbnailSize;
            const thumbnailCtx = thumbnailCanvas.getContext('2d');
            thumbnailCtx.drawImage(img{{ forloop.counter }}, 0, 0, thumbnailSize, thumbnailSize);
            document.getElementById('thumbnail_{{ forloop.counter }}').src = thumbnailCanvas.toDataURL();

            // Increment the loaded image counter and check if all images are loaded
            loadedImagesCount++;
            checkIfAllImagesLoaded();
          };
          img{{ forloop.counter }}.onerror = function() {
              //console.error(`Failed to load image {{ forloop.counter }}`);
              loadedImagesCount++;
              checkIfAllImagesLoaded();
          };



          let layerName{{ forloop.counter }} = "{{ layer.name }}"; // Store the layer name
          let thumbnail{{ forloop.counter }} = document.getElementById('thumbnail_{{ forloop.counter }}');
          let layerNameElement{{ forloop.counter }} = document.querySelector(`#toggleLayer{{ forloop.counter }}`).nextElementSibling;
          if (thumbnail{{ forloop.counter }}) {
            thumbnail{{ forloop.counter }}.addEventListener('click', function(event) {
              showContextMenu(event, {{ forloop.counter }}, layerName{{ forloop.counter }});
            });
          }

          if (layerNameElement{{ forloop.counter }}) {
            layerNameElement{{ forloop.counter }}.addEventListener('click', function(event) {
              showContextMenu(event, {{ forloop.counter }}, layerName{{ forloop.counter }});
            });
          }
          loader.style.display = 'block';
          
          setTimeout(() => {
            const buttons = document.querySelectorAll('#image-color-pickers button');
            const rgbColors = generateUniqueRGBColorArray(distinctColorsArrayColorPallet.length+1);
            layerColors[{{ forloop.counter }}] = {
                targetColors: distinctColorsArrayColorPallet,
                newColors: rgbColors
            };
            localStorage.setItem('distinctColorsArrayColorPallet', JSON.stringify(distinctColorsArrayColorPallet));
            const layerIndex = {{ forloop.counter }};
            const totalLayers = {{ layers|length }};
            
            // For single layer mode, we need to handle differently
            if (totalLayers === 1) {
                // Generate multiple palettes for single layer
                for (let i = 0; i < 10; i++) {
            
                    displayColorPalette(i, distinctColorsArrayColorPallet, 'trending', distinctColorsArrayColorPallet.length+1, totalLayers);
                    displayColorPalette(i, distinctColorsArrayColorPallet, 'ss', distinctColorsArrayColorPallet.length+1, totalLayers);
                    displayColorPalette(i, distinctColorsArrayColorPallet, 'aw', distinctColorsArrayColorPallet.length+1, totalLayers);
                }
            } else {
                // For multi-layer mode
                displayColorPalette(layerIndex, rgbColors, 'trending', distinctColorsArrayColorPallet.length+1, totalLayers);
                displayColorPalette(layerIndex, rgbColors, 'ss', distinctColorsArrayColorPallet.length+1, totalLayers);
                displayColorPalette(layerIndex, rgbColors, 'aw', distinctColorsArrayColorPallet.length+1, totalLayers);
            }
        
            const layerCanvas = document.getElementById(`layer_canvas_${layerIndex}`);
            const layerCtx = layerCanvas.getContext('2d', { willReadFrequently: true });
        

            
            // Helper function to set up palette buttons consistently

        }, 1000); // 1-second delay
          {% endfor %}
      });
  




      function getDominantColor(imageData) {
  const data = imageData.data;
  const colorCounts = {};
  const allColors = new Map();
  let totalPixels = 0;

  for (let i = 0; i < data.length; i += 4) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];
    const a = data[i + 3];

    if (a === 0) continue;
    if ((r === 0 && g === 0 && b === 0) || (r === 255 && g === 255 && b === 255)) continue;

    const [h, s, l] = rgbToHsl(r, g, b);

    if (s < 0.05) continue;

    const colorName = getDominantColorName([r, g, b]);
    const existingColor = allColors.get(colorName);

    if (existingColor) {
      existingColor.pixelCount++;
    } else {
      allColors.set(colorName, { rgb: [r, g, b], colorName, pixelCount: 1 });
    }

    totalPixels++;
  }

  let maxCount = 0;
  let dominantColor = null;

  for (const [colorName, colorInfo] of allColors.entries()) {
    if (colorInfo.pixelCount > maxCount) {
      maxCount = colorInfo.pixelCount;
      dominantColor = colorInfo;
    }
  }

  if (dominantColor) {
    const nonDominantColors = [];
    for (const [colorName, colorInfo] of allColors.entries()) {
      if (colorName !== dominantColor.colorName) {
        const pixelPercentage = (colorInfo.pixelCount / totalPixels) * 100;
        nonDominantColors.push({ ...colorInfo, pixelPercentage });
      }
    }

    return {
      referenceColor: dominantColor.rgb,
      dominantHue: rgbToHsl(...dominantColor.rgb)[0],
      tolerance: {
        hue: 45 / 360,
        saturation: 0.4,
        lightness: 0.45
      },
      isSingleShade: false,
      nonDominantColors,
      dominantColorName: dominantColor.colorName
    };
  }

  return null;
}

// Add this shuffle function at the top level
function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}

function shuffleSinglePalette(layerIndex) {
  const paletteContainer = document.getElementById(`colorPalette_${layerIndex}`);
  if (!paletteContainer) return;

  // Toggle the state for this palette
  window.paletteToggleState[layerIndex] = !window.paletteToggleState[layerIndex];

  if (window.paletteToggleState[layerIndex]) {
      // If toggled on, generate and apply new colors
      const swatches = Array.from(paletteContainer.querySelectorAll('.color-swatch'));
      if (swatches.length === 0) return;

      const colors = swatches.map(swatch => {
          const style = window.getComputedStyle(swatch);
          const bgcolor = style.backgroundColor;
          return bgcolor.match(/\d+/g).map(Number);
      });

      // Shuffle colors
      const shuffledColors = shuffleArray([...colors]);

      // Apply shuffled colors
      swatches.forEach((swatch, index) => {
          swatch.style.backgroundColor = `rgb(${shuffledColors[index].join(',')})`;
      });

      // Store the shuffled colors
      window.trendingPaletteColors = window.trendingPaletteColors || {};
      window.trendingPaletteColors[layerIndex] = shuffledColors;
  } else {
      // If toggled off, revert to original colors
      const originalColors = window.originalPaletteColors[layerIndex];
      if (originalColors) {
          displayColorPalette(layerIndex, originalColors);
      }
  }
}



// Add this function to your code
function shufflePalette(paletteIndex, collection = 'trending') {
    // Get the stored full palette
    const fullPalette = window[`${collection}PaletteColors`] && 
                        window[`${collection}PaletteColors`][paletteIndex];
    
    if (!fullPalette || fullPalette.length === 0) {
        console.error(`No palette found to shuffle for ${collection}[${paletteIndex}]`);
        return;
    }
    
    // Function to convert RGB to HSL
    function rgbToHsl(r, g, b) {
        r /= 255; g /= 255; b /= 255;
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;

        if (max === min) {
            h = s = 0;
        } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            
            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }

        return [h * 360, s * 100, l * 100];
    }

    // Function to convert HSL to RGB
    function hslToRgb(h, s, l) {
        h /= 360; s /= 100; l /= 100;
        let r, g, b;

        if (s === 0) {
            r = g = b = l;
        } else {
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            };

            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;

            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
        }

        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }
    
    // Apply a new random transformation to THIS SPECIFIC palette
    const hueShift = Math.floor(Math.random() * 360);
    const satFactor = 0.7 + (Math.random() * 0.6);
    const lightFactor = 0.8 + (Math.random() * 0.4);
    
    // Create a new transformed palette
    const newPalette = fullPalette.map(color => {
        try {
            const [h, s, l] = rgbToHsl(...color);
            
            // Apply transformations
            const newHue = (h + hueShift) % 360;
            const newSat = Math.min(100, s * satFactor);
            const newLight = Math.min(95, Math.max(5, l * lightFactor));
            
            return hslToRgb(newHue, newSat, newLight);
        } catch (e) {
            console.warn("Error transforming color:", e);
            return [128, 128, 128]; // Gray fallback
        }
    });
    
    // Update only THIS palette in storage
    window[`${collection}PaletteColors`][paletteIndex] = newPalette;
    
    // Apply collection-specific adjustments
    let displayPalette = [...newPalette];
    try {
        if (collection === 'ss') {
            displayPalette = displayPalette.map(color => {
                const [h, s, l] = rgbToHsl(...color);
                return hslToRgb(h, Math.min(100, s * 1.2), Math.min(100, l * 1.1));
            });
        } else if (collection === 'aw') {
            displayPalette = displayPalette.map(color => {
                const [h, s, l] = rgbToHsl(...color);
                return hslToRgb(h, s * 0.9, l * 0.85);
            });
        }
    } catch (e) {
        console.warn("Error applying collection adjustments:", e);
        displayPalette = [...newPalette];
    }
    
    // Update the UI for this specific palette only
    const paletteContainer = document.getElementById(`${collection}_colorPalette_${paletteIndex}`);
    if (!paletteContainer) {
        console.error(`Palette container not found: ${collection}_colorPalette_${paletteIndex}`);
        return;
    }
    
    // Prepare display colors - ONLY for this specific palette
    function prepareDisplayColors(colors, displayCount = 6) {
        if (!colors || colors.length === 0) return [];
        
        // Always include the first color
        let displayColors = [colors[0]];
        
        if (colors.length > displayCount) {
            // Select remaining display colors evenly distributed
            const step = (colors.length - 1) / (displayCount - 1);
            for (let i = 1; i < displayCount; i++) {
                const idx = Math.min(Math.floor(1 + (i - 1) * step), colors.length - 1);
                displayColors.push(colors[idx]);
            }
        } else if (colors.length < displayCount) {
            // Add remaining colors
            for (let i = 1; i < colors.length; i++) {
                displayColors.push(colors[i]);
            }
            
            // If still not enough, duplicate some colors
            while (displayColors.length < displayCount) {
                const idx = displayColors.length % colors.length;
                displayColors.push([...colors[idx]]);
            }
        } else {
            // We have exactly the right number of colors
            displayColors = [...colors];
        }
        
        return displayColors;
    }
    
    const displayColors = prepareDisplayColors(displayPalette);
    
    // Clear the container
    paletteContainer.innerHTML = '';
    
    // Function to convert RGB to HEX
    function rgbToHex(r, g, b) {
        return '#' + [r, g, b].map(x => {
            const hex = x.toString(16);
            return hex.length === 1 ? '0' + hex : hex;
        }).join('');
    }
    
    // Function to get color name
    function getColorName(rgb) {
        try {
            const [r, g, b] = rgb;
            
            // Convert RGB to HSV for better color categorization
            const rNorm = r / 255;
            const gNorm = g / 255;
            const bNorm = b / 255;
            const max = Math.max(rNorm, gNorm, bNorm);
            const min = Math.min(rNorm, gNorm, bNorm);
            const diff = max - min;
            
            // Calculate Hue
            let h = 0;
            if (max !== min) {
                if (max === rNorm) {
                    h = (60 * ((gNorm - bNorm) / diff) + 360) % 360;
                } else if (max === gNorm) {
                    h = (60 * ((bNorm - rNorm) / diff) + 120) % 360;
                } else {
                    h = (60 * ((rNorm - gNorm) / diff) + 240) % 360;
                }
            }
            
            // Calculate Value (brightness)
            const v = max;
            
            // Determine hue category
            let hueName;
            if (h < 15 || h >= 345) hueName = "Red";
            else if (h >= 15 && h < 45) hueName = "Orange";
            else if (h >= 45 && h < 75) hueName = "Yellow";
            else if (h >= 75 && h < 165) hueName = "Green";
            else if (h >= 165 && h < 195) hueName = "Cyan";
            else if (h >= 195 && h < 255) hueName = "Blue";
            else if (h >= 255 && h < 285) hueName = "Purple";
            else if (h >= 285 && h < 345) hueName = "Pink";
            
            // Simplified shade prefix
            let shadePrefix = "";
            if (v < 0.4) shadePrefix = "Dark";
            else if (v > 0.7) shadePrefix = "Light";
            
            return shadePrefix ? `${shadePrefix} ${hueName}` : hueName;
        } catch (e) {
            console.warn("Error determining color name:", e);
            return "Unknown";
        }
    }
    
    // Create container for the palette
    const clickableContainer = document.createElement('div');
    clickableContainer.classList.add('palette-clickable-container');
    paletteContainer.appendChild(clickableContainer);
    
    // Add data attributes
    clickableContainer.dataset.paletteIndex = paletteIndex;
    clickableContainer.dataset.collection = collection;
    
    // Add click handler
    clickableContainer.addEventListener('click', function() {
        try {
            const pIndex = parseInt(this.dataset.paletteIndex, 10);
            const collName = this.dataset.collection;
            
            // Get the FULL palette from storage
            const fullPalette = window[`${collName}PaletteColors`] && 
                                window[`${collName}PaletteColors`][pIndex];
            
            if (!fullPalette || fullPalette.length === 0) {
                console.error(`No full palette found for ${collName}[${pIndex}]`);
                return;
            }
            console.log(`Clicked on palette `);
            // Call processPallet with the FULL palette
            if (typeof window.processPallet === 'function') {
                window.processPallet(null, 1, null, 0, null, fullPalette, pIndex);
            }
        } catch (e) {
            console.error("Error in palette click handler:", e);
        }
    });
    
    // Display the colors
    displayColors.forEach((color, idx) => {
        const swatch = document.createElement('div');
        swatch.classList.add('color-swatch');
        swatch.style.backgroundColor = `rgb(${color.join(',')})`;
        
        // Updated tooltip with HEX value
        const hexValue = rgbToHex(color[0], color[1], color[2]);
        swatch.title = `${getColorName(color)}: ${hexValue}`;
        
        if (collection === 'ss') {
            swatch.classList.add('ss-swatch');
        } else if (collection === 'aw') {
            swatch.classList.add('aw-swatch');
        }
        
        clickableContainer.appendChild(swatch);
    });
    
    // Add "Show All" button
    const showAllButton = document.createElement('div');
    showAllButton.classList.add('show-all-colors-btn');
    showAllButton.innerHTML = '+';
    showAllButton.title = 'Show all colors in palette';
    clickableContainer.appendChild(showAllButton);
    
    // Add event listener to show all colors in a modal
    showAllButton.addEventListener('click', function(e) {
        e.stopPropagation(); // Prevent triggering the parent container's click
        
        const fullPalette = window[`${collection}PaletteColors`][paletteIndex];
        if (!fullPalette || fullPalette.length === 0) {
            console.error('No full palette found to display');
            return;
        }
        
        showFullPaletteModal(fullPalette, collection, paletteIndex);
    });
}


function handleShuffleColors() {
  console.log("Starting color shuffle process");
  
  // Show loader
  showLoader('Shuffling colors...');
  
  // Use setTimeout to ensure the loader is rendered before processing starts
  setTimeout(() => {
    try {
      const imageColorPickerContainer = document.getElementById('image-color-pickers');
      if (!imageColorPickerContainer) {
        console.error("Color picker container not found");
        hideLoader();
        return;
      }
      
      const colorButtons = Array.from(imageColorPickerContainer.getElementsByClassName('pcr-button'));
      console.log(`Found ${colorButtons.length} color buttons total`);
      
      if (colorButtons.length === 0) {
        console.log("No color buttons found");
        hideLoader();
        return;
      }

      // Get all color data with their locked status
      const allColorData = colorButtons.map((button, originalIndex) => {
        const style = window.getComputedStyle(button);
        const bgcolor = style.backgroundColor;
        const layerIndexAttr = button.dataset.layerIndex;
        const layerIndex = layerIndexAttr ? parseInt(layerIndexAttr) : originalIndex;
        const colorArray = bgcolor.match(/\d+/g).map(Number);
        const isLocked = button.dataset.locked === 'true';
        
        console.log(`Button ${originalIndex}: Layer ${layerIndex}, Color: ${colorArray.join(',')}, Locked: ${isLocked}`);
        
        return {
          color: colorArray,
          layerIndex: layerIndex,
          element: button,
          isLocked: isLocked,
          originalIndex: originalIndex
        };
      });
      
      // Get only unlocked colors for shuffling
      const unlockedColors = allColorData.filter(data => !data.isLocked);
      console.log(`Found ${unlockedColors.length} unlocked colors to shuffle`);
      
      if (unlockedColors.length === 0) {
        console.log('All colors are locked, nothing to shuffle');
        hideLoader();
        return;
      }
      
      if (unlockedColors.length === 1 && colorButtons.length === 1) {
        // Single unlocked color case - generate a new color variation
        handleSingleColorVariation(unlockedColors[0]);
        return;
      }
      
      // Check if we're dealing with a single layer (multiple color buttons for one canvas)
      const canvasElements = document.querySelectorAll('canvas[id^="layer_canvas_"]');
      const isSingleLayer = canvasElements.length === 1;
      
      if (isSingleLayer) {
        // Handle single layer with multiple color regions
        handleSingleLayerColorShuffle(allColorData, unlockedColors);
      } else {
        // Handle multiple layers (original logic)
        handleMultiLayerColorShuffle(allColorData, unlockedColors);
      }
        
    } catch (error) {
      console.error("Error in handleShuffleColors:", error);
      hideLoader();
    }
  }, 50); // Small delay to ensure the loader UI renders
}

// New function to handle single layer with multiple color regions
function handleSingleLayerColorShuffle(allColorData, unlockedColors) {
  console.log("Processing single layer with multiple color regions");
  
  // Get the canvas
  const canvas = document.querySelector('canvas[id^="layer_canvas_"]');
  if (!canvas) {
    console.error("Canvas not found");
    hideLoader();
    return;
  }
  
  try {
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    
    // Save current state
    const actualLayerIndex = 1; // Single layer case always uses layer 1
    if (layerStates && typeof layerStates.saveEditedState === 'function') {
      layerStates.saveEditedState(actualLayerIndex);
    }
    
    // Create color mapping for transformation
    // Map from original colors to new colors
    const colorMap = new Map();
    
    // Get only the unlocked color values
    const unlockedColorValues = unlockedColors.map(data => data.color);
    
    // Shuffle only the unlocked colors
    const shuffledUnlockedColors = shuffleArray([...unlockedColorValues]);
    
    // Create mapping for unlocked colors
    unlockedColors.forEach((data, index) => {
      const originalColor = data.color;
      const newColor = shuffledUnlockedColors[index];
      
      // RGB string for map key
      const originalColorKey = originalColor.join(',');
      
      colorMap.set(originalColorKey, newColor);
      
      // Update button appearance
      data.element.style.backgroundColor = `rgb(${newColor.join(',')})`;
      
      console.log(`Mapping color ${originalColorKey} to ${newColor.join(',')}`);
    });
    
    // Process the image data, applying the color mapping with tolerance
    const tolerance = 15; // Color matching tolerance
    
    for (let i = 0; i < data.length; i += 4) {
      const r = data[i];
      const g = data[i + 1];
      const b = data[i + 2];
      
      // Skip transparent pixels
      if (data[i + 3] === 0) continue;
      
      // Find if this color matches any of our unlocked colors within tolerance
      let matched = false;
      
      for (const [origColorStr, newColor] of colorMap.entries()) {
        const origColor = origColorStr.split(',').map(Number);
        
        // Check if within tolerance range
        if (
          Math.abs(r - origColor[0]) <= tolerance &&
          Math.abs(g - origColor[1]) <= tolerance &&
          Math.abs(b - origColor[2]) <= tolerance
        ) {
          // Calculate how much to adjust this specific pixel
          const rDiff = newColor[0] - origColor[0];
          const gDiff = newColor[1] - origColor[1];
          const bDiff = newColor[2] - origColor[2];
          
          // Apply the same relative change to maintain color variations
          data[i] = Math.max(0, Math.min(255, r + rDiff));
          data[i + 1] = Math.max(0, Math.min(255, g + gDiff));
          data[i + 2] = Math.max(0, Math.min(255, b + bDiff));
          
          matched = true;
          break;
        }
      }
      
      // If no match found, this pixel's color remains unchanged (effectively locked)
    }
    
    // Put the modified image data back to the canvas
    ctx.putImageData(imageData, 0, 0);
    
  } catch (error) {
    console.error("Error in single layer color shuffle:", error);
  } finally {
    // Always hide the loader when finished
    hideLoader();
  }
}

// Function to handle multiple layers color shuffle (original logic)
function handleMultiLayerColorShuffle(allColorData, unlockedColors) {
  // Get only the color values from unlocked items
  const colorValues = unlockedColors.map(data => data.color);
  
  // Shuffle the color values
  const shuffledColorValues = shuffleArray([...colorValues]);
  console.log("Shuffled colors:", shuffledColorValues);
  
  // Store original colors for processing
  const originalColorsMap = new Map();
  
  // Save all layer states before making changes
  if (layerStates && typeof layerStates.saveEditedState === 'function') {
    allColorData.forEach(data => {
      const actualLayerIndex = data.layerIndex + 1;  // Adjust for canvas ID format
      layerStates.saveEditedState(actualLayerIndex);
      originalColorsMap.set(data.layerIndex, data.color);
    });
  }
  
  // Apply shuffled colors to unlocked buttons and process canvases
  const processPromises = [];
  
  unlockedColors.forEach((data, shuffleIndex) => {
    const newColor = shuffledColorValues[shuffleIndex];
    const button = data.element;
    const layerIndex = data.layerIndex;
    const actualLayerIndex = layerIndex + 1;  // Adjust for canvas ID format
    const originalColor = originalColorsMap.get(layerIndex);
    
    console.log(`Applying shuffled color ${newColor.join(',')} to layer ${actualLayerIndex} (was ${originalColor.join(',')})`);
    
    // Update button color
    button.style.backgroundColor = `rgb(${newColor.join(',')})`;
    
    const canvas = document.getElementById(`layer_canvas_${actualLayerIndex}`);
    if (!canvas) {
      console.warn(`Canvas for layer ${actualLayerIndex} not found`);
      return;
    }
    
    // Process the layer with the new color
    const processPromise = new Promise((resolve) => {
      if (layerStates && typeof layerStates.hasEditedState === 'function' && 
          layerStates.hasEditedState(actualLayerIndex)) {
        const img = new Image();
        img.onload = async () => {
          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(img, 0, 0);
          await processLayerAsync(ctx, originalColor, newColor);
          resolve();
        };
        img.src = layerStates.getEditedState(actualLayerIndex);
      } else {
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        resolve(processLayerAsync(ctx, originalColor, newColor));
      }
    });
    
    processPromises.push(processPromise);
  });

  Promise.all(processPromises)
    .then(() => {
      console.log('All unlocked layers processed successfully');
      hideLoader();
    })
    .catch(error => {
      console.error('Error during color processing:', error);
      hideLoader();
    });
}
// Handle the special case of a single color
function handleSingleColorVariation(colorData) {
  console.log("Processing single color variation");
  
  const button = colorData.element;
  const layerIndex = colorData.layerIndex + 1; // Adjust for canvas ID format
  const originalColor = colorData.color;
  
  const canvas = document.getElementById(`layer_canvas_${layerIndex}`);
  if (!canvas) {
    console.error(`Canvas for layer ${layerIndex} not found`);
    hideLoader();
    return;
  }
  
  // Save current state
  layerStates.saveEditedState(layerIndex);
  
  // Generate variations of the color
  const variations = generateColorVariations(originalColor);
  const shuffledVariations = shuffleArray(variations);
  const newColor = shuffledVariations[0]; // Use the first variation
  
  console.log(`Changing color from ${originalColor.join(',')} to ${newColor.join(',')}`);
  
  // Update button color
  button.style.backgroundColor = `rgb(${newColor.join(',')})`;
  
  // Process the layer with new color
  if (layerStates.hasEditedState(layerIndex)) {
    const img = new Image();
    img.onload = async () => {
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0);
      await processLayerAsync(ctx, originalColor, newColor);
      hideLoader();
    };
    img.src = layerStates.getEditedState(layerIndex);
  } else {
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    processLayerAsync(ctx, originalColor, newColor)
      .then(() => hideLoader())
      .catch(error => {
        console.error("Error processing single color:", error);
        hideLoader();
      });
  }
}

// Helper functions for loader
function showLoader(message = 'Loading...') {
  // Check if the loader already exists
  let loader = document.getElementById('color-shuffle-loader');
  
  if (!loader) {
    // Create loader element
    loader = document.createElement('div');
    loader.id = 'color-shuffle-loader';
    loader.classList.add('color-shuffle-loader');
    
    // Style the loader
    loader.style.position = 'fixed';
    loader.style.top = '0';
    loader.style.left = '0';
    loader.style.width = '100%';
    loader.style.height = '100%';
    loader.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
    loader.style.display = 'flex';
    loader.style.justifyContent = 'center';
    loader.style.alignItems = 'center';
    loader.style.zIndex = '9999';
    
    // Create spinner and message
    const content = document.createElement('div');
    content.style.backgroundColor = 'white';
    content.style.padding = '20px';
    content.style.borderRadius = '8px';
    content.style.textAlign = 'center';
    
    const spinner = document.createElement('div');
    spinner.classList.add('spinner');
    spinner.style.width = '40px';
    spinner.style.height = '40px';
    spinner.style.margin = '0 auto 15px';
    spinner.style.border = '5px solid #f3f3f3';
    spinner.style.borderTop = '5px solid #3498db';
    spinner.style.borderRadius = '50%';
    spinner.style.animation = 'spin 1s linear infinite';
    
    const messageElem = document.createElement('div');
    messageElem.textContent = message;
    
    // Add spinner and message to content
    content.appendChild(spinner);
    content.appendChild(messageElem);
    
    // Add content to loader
    loader.appendChild(content);
    
    // Add animation style
    const style = document.createElement('style');
    style.textContent = `
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
    `;
    document.head.appendChild(style);
    
    // Add to DOM
    document.body.appendChild(loader);
  } else {
    // Update existing loader message
    const messageElem = loader.querySelector('div > div:not(.spinner)');
    if (messageElem) {
      messageElem.textContent = message;
    }
    
    // Make sure it's visible
    loader.style.display = 'flex';
  }
}

function hideLoader() {
  const loader = document.getElementById('color-shuffle-loader');
  if (loader) {
    loader.style.display = 'none';
  }
}
// Helper function to generate color variations
function generateColorVariations(baseColor) {
  const variations = [];
  
  // Add the original color
  variations.push([...baseColor]);
  
  // Generate some variations by adjusting hue
  for (let i = 1; i <= 3; i++) {
      const hslColor = rgbToHsl(baseColor[0], baseColor[1], baseColor[2]);
      hslColor[0] = (hslColor[0] + (i * 30)) % 360; // Rotate hue by 30 degrees
      const rgbColor = hslToRgb(hslColor[0], hslColor[1], hslColor[2]);
      variations.push(rgbColor);
  }
  
  return variations;
}

// Add a utility function to check if colors are significantly different
function areColorsDifferent(color1, color2, threshold = 5) {
    return Math.abs(color1[0] - color2[0]) > threshold ||
           Math.abs(color1[1] - color2[1]) > threshold ||
           Math.abs(color1[2] - color2[2]) > threshold;
}

// Modify your createColorButtons function to add layer index to buttons

function createColorButtons() {
  const imageColorAnalyzer = new ImageColorAnalyzer();
  const imageColorPickerContainer = document.getElementById('image-color-pickers');
  imageColorPickerContainer.innerHTML = '';
  
  const canvasElements = document.querySelectorAll('canvas[id^="layer_canvas_"]');
  const isSingleLayer = canvasElements.length === 1;

  if (isSingleLayer) {
      // Handle single layer case - create buttons for all distinct colors
      const canvas = canvasElements[0];
      const ctx = canvas.getContext('2d');
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const distinctColors = getDistinctColors(imageData, 30, 50); // Lower tolerance, more colors

      distinctColors.forEach((color, index) => {
          // Create wrapper div for button and lock
          const wrapper = document.createElement('div');
          wrapper.className = 'color-button-wrapper';
          
          // Create color button
          const button = document.createElement('button');
          button.className = 'pcr-button color-picker';
          button.style.backgroundColor = `rgb(${color.join(',')})`;
          button.dataset.layerIndex = 0;
          button.dataset.locked = 'false';
          
          // Create lock overlay
          const lockOverlay = document.createElement('div');
          lockOverlay.className = 'lock-overlay';
          lockOverlay.innerHTML = `
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-unlock" viewBox="0 0 16 16">
                  <path d="M11 1a2 2 0 0 0-2 2v4a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h5V3a3 3 0 0 1 6 0v4a.5.5 0 0 1-1 0V3a2 2 0 0 0-2-2zM3 8a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1H3z"/>
              </svg>`;

          // Add lock overlay click handler
          lockOverlay.addEventListener('click', (e) => {
              e.stopPropagation();
              const isLocked = button.dataset.locked === 'true';
              button.dataset.locked = !isLocked;
              lockOverlay.innerHTML = !isLocked ? 
                  `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-lock" viewBox="0 0 16 16">
                      <path d="M8 1a2 2 0 0 1 2 2v4H6V3a2 2 0 0 1 2-2zm3 6V3a3 3 0 0 0-6 0v4a2 2 0 0 0-2 2v5a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2zM5 8h6a1 1 0 0 1 1 1v5a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V9a1 1 0 0 1 1-1z"/>
                  </svg>` :
                  `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-unlock" viewBox="0 0 16 16">
                      <path d="M11 1a2 2 0 0 0-2 2v4a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h5V3a3 3 0 0 1 6 0v4a.5.5 0 0 1-1 0V3a2 2 0 0 0-2-2zM3 8a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1H3z"/>
                  </svg>`;
          });

          wrapper.appendChild(button);
          wrapper.appendChild(lockOverlay);
          imageColorPickerContainer.appendChild(wrapper);
          button.dataset.layerIndex = index;
          
          button.addEventListener('click', () => {
            
              showLayerInfoButton(index);
          });
      });
  } else {
      // Original multiple layer logic
      canvasElements.forEach((canvas, index) => {
          const img = new Image();

          img.onload = () => {
            const canvas = document.getElementById(`layer_canvas_${layerIndex}`);
            const ctx = canvas.getContext('2d');
            console.log('im fucking triggered')
        
            // Save the current state of the canvas
            const currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        
            // Check if the canvas is already populated
            const isEmpty = currentImageData.data.every(value => value === 0);
        
            // Only reset the canvas if it's empty
            if (isEmpty) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);
            } else {
                // Restore the previous state if the canvas is not empty
                ctx.putImageData(currentImageData, 0, 0);
            }

              imageColorAnalyzer.analyzeImageColors(img)
                  .then(colorAnalysis => {
                      if (colorAnalysis) {
                          const dominantColor = colorAnalysis.dominantColor;

                          // Create wrapper div for button and lock
                          const wrapper = document.createElement('div');
                          wrapper.className = 'color-button-wrapper';
                          
                          // Create color button
                          const button = document.createElement('button');
                          button.className = 'pcr-button color-picker';
                          button.style.backgroundColor = `rgb(${dominantColor.join(',')})`;
                          button.dataset.layerIndex = index;
                          button.dataset.locked = 'false';
                          
                          // Create lock overlay
                          const lockOverlay = document.createElement('div');
                          lockOverlay.className = 'lock-overlay';
                          lockOverlay.innerHTML = `
                              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-unlock" viewBox="0 0 16 16">
                                  <path d="M11 1a2 2 0 0 0-2 2v4a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h5V3a3 3 0 0 1 6 0v4a.5.5 0 0 1-1 0V3a2 2 0 0 0-2-2zM3 8a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1H3z"/>
                              </svg>`;

                          // Add lock overlay click handler
                          lockOverlay.addEventListener('click', (e) => {
                              e.stopPropagation();
                              const isLocked = button.dataset.locked === 'true';
                              button.dataset.locked = !isLocked;
                              lockOverlay.innerHTML = !isLocked ? 
                                  `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-lock" viewBox="0 0 16 16">
                                      <path d="M8 1a2 2 0 0 1 2 2v4H6V3a2 2 0 0 1 2-2zm3 6V3a3 3 0 0 0-6 0v4a2 2 0 0 0-2 2v5a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2zM5 8h6a1 1 0 0 1 1 1v5a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V9a1 1 0 0 1 1-1z"/>
                                  </svg>` :
                                  `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-unlock" viewBox="0 0 16 16">
                                      <path d="M11 1a2 2 0 0 0-2 2v4a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h5V3a3 3 0 0 1 6 0v4a.5.5 0 0 1-1 0V3a2 2 0 0 0-2-2zM3 8a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1H3z"/>
                                  </svg>`;
                          });

                          wrapper.appendChild(button);
                          wrapper.appendChild(lockOverlay);
                          imageColorPickerContainer.appendChild(wrapper);
                          
                          button.addEventListener('click', () => {
                              showLayerInfoButton(index);
                          });
                      }
                  })
                  .catch(error => {
                      console.error(`Error analyzing colors for layer ${index}:`, error);
                  });
          };

          img.src = canvas.toDataURL('image/png');
      });
  }
}
// Add event listener for shuffle button
document.querySelector('.btn-success2').addEventListener('click', handleShuffleColors);

// Add this to your existing DOMContentLoaded event listener
document.addEventListener('DOMContentLoaded', function() {
    const layerColors = {};
    const totalLayers = {{ layers|length }};
    let loadedImagesCount = 0;

    function checkIfAllImagesLoaded() {
        if (loadedImagesCount === totalLayers) {
            const loadingScreen = document.getElementById('loading-screen');
            loadingScreen.style.display = 'none';

            // Generate unique RGB color palettes for the trending palettes
            const trendingPalettes = generateUniqueRGBColorPalettes(totalLayers, totalLayers);

      
        }
    }

    {% for layer in layers %}
    let img{{ forloop.counter }} = new Image();
    img{{ forloop.counter }}.src = "{{ layer.path }}";
    let canvas{{ forloop.counter }} = document.getElementById('layer_canvas_{{ forloop.counter }}');
    let ctx{{ forloop.counter }} = canvas{{ forloop.counter }}.getContext('2d', { willReadFrequently: true });
    img{{ forloop.counter }}.onload = function() {
        canvas{{ forloop.counter }}.width = img{{ forloop.counter }}.width;
        canvas{{ forloop.counter }}.height = img{{ forloop.counter }}.height;
        ctx{{ forloop.counter }}.drawImage(img{{ forloop.counter }}, 0, 0);
        loadedImagesCount++;
        checkIfAllImagesLoaded();
    };
    img{{ forloop.counter }}.onerror = function() {
        loadedImagesCount++;
        checkIfAllImagesLoaded();
    };
    {% endfor %}
});

function generateUniqueRGBColorPalettes(count, totalLayers) {
    const palettes = [];

    for (let i = 0; i < count; i++) {
        const colors = generateUniqueRGBColorArray(totalLayers);
        palettes.push(colors);
    }

    return palettes;
}

function exportTiff() {
  return new Promise((resolve, reject) => {
      const loadingScreen = document.getElementById('loading-screen');
      loadingScreen.style.display = 'block';
      
      const formData = new FormData();
      const layers = [];
      
      // Get all layer canvases in correct order
      const layerCanvases = Array.from(document.querySelectorAll('[id^="layer_canvas_"]'))
          .sort((a, b) => {
              const indexA = parseInt(a.id.split('_').pop());
              const indexB = parseInt(b.id.split('_').pop());
              return indexA - indexB;
          });
      
      // Collect all layer data matching the read format
      layerCanvases.forEach((canvas) => {
          // Get the actual positions from the canvas or its wrapper
          const wrapper = canvas.closest('.layer-wrapper') || canvas.parentElement;
          const position_top = parseInt(wrapper.style.top) || 0;
          const position_left = parseInt(wrapper.style.left) || 0;
          
          // Get original dimensions from data attributes
          const original_width = parseInt(canvas.getAttribute('data-original-width') || 0);
          const original_height = parseInt(canvas.getAttribute('data-original-height') || 0);

          const layerData = {
              name: canvas.getAttribute('data-layer-name') || canvas.id,
              position_top: position_top,
              position_left: position_left,
              width: canvas.width,
              height: canvas.height,
              original_width: original_width,
              original_height: original_height,
              imageData: canvas.toDataURL('image/png', 1.0)
          };
          
          console.log(`Exporting Layer: ${layerData.name}, Position: (${layerData.position_left}, ${layerData.position_top}), Size: ${layerData.width}x${layerData.height}, Original Size: ${layerData.original_width}x${layerData.original_height}`);
          layers.push(layerData);
      });
      
      formData.append('layers_data', JSON.stringify(layers));
      
      // Send data to server
      fetch('export_tiff/', {
          method: 'POST',
          headers: {
              'X-CSRFToken': getCookie('csrftoken')
          },
          body: formData
      })
      .then(response => {
          if (!response.ok) {
              return response.text().then(text => {
                  try {
                      const json = JSON.parse(text);
                      throw new Error(json.error || 'Export failed');
                  } catch (e) {
                      throw new Error('Export failed: ' + text);
                  }
              });
          }
          return response.blob();
      })
      .then(blob => {
          const url = window.URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'exported.tif';
          document.body.appendChild(a);
          a.click();
          window.URL.revokeObjectURL(url);
          a.remove();
          resolve();
      })
      .catch(error => {
          console.error('Export failed:', error);
          reject(error);
      })
      .finally(() => {
          loadingScreen.style.display = 'none';
      });
  });
}

// Event listener setup
document.addEventListener('DOMContentLoaded', function() {
  const exportButton = document.querySelector('.btn.btn-success4') || document.getElementById('exportTiffButton');
  
  if (exportButton) {
      exportButton.addEventListener('click', function() {
          const loadingScreen = document.getElementById('loading-screen');
          if (loadingScreen) {
              loadingScreen.style.display = 'block';
          }

          exportTiff()
              .then(() => {
                  console.log('Export completed successfully');
              })
              .catch(error => {
                  console.error('Export failed:', error);
                  alert('Export failed: ' + error.message);
              })
              .finally(() => {
                  if (loadingScreen) {
                      loadingScreen.style.display = 'none';
                  }
              });
      });
  }
});

// Helper function to get CSRF token
function getCookie(name) {
  let cookieValue = null;
  if (document.cookie && document.cookie !== '') {
      const cookies = document.cookie.split(';');
      for (let i = 0; i < cookies.length; i++) {
          const cookie = cookies[i].trim();
          if (cookie.substring(0, name.length + 1) === (name + '=')) {
              cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
              break;
          }
      }
  }
  return cookieValue;
}

    </script>
  </body>
</html>
