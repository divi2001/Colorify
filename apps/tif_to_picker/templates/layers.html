{% load static %}

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>COLORIFY</title>
    <!-- Add Bootstrap CSS -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <link rel="stylesheet" type="text/css" href="{% static 'css/layers.css' %}">
    <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>
    <!-- Add Bootstrap Icons -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css"
      rel="stylesheet"
    />
    
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@simonwep/pickr/dist/themes/nano.min.css"
    />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    
    <script src="https://cdn.jsdelivr.net/npm/@simonwep/pickr"></script>
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/color-thief/2.3.0/color-thief.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <script src="
https://cdn.jsdelivr.net/npm/jimp@1.6.0/dist/browser/index.min.js
"></script>

        
        <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Add mockups button handler to the existing navigation structure
            const mockupsButton = document.getElementById('mockupsButton');
            if (mockupsButton) {
                mockupsButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    
                    // Set this button as active
                    const navButtons = document.querySelectorAll('.mostLeftUl li a');
                    navButtons.forEach(button => {
                        button.classList.remove('active');
                    });
                    this.classList.add('active');
                    
                    // Make sure secondaryColumn is visible
                    const secondaryColumn = document.getElementById('secondaryColumn');
                    secondaryColumn.style.display = 'flex';
                    
                    // Hide all content sections inside secondaryColumn
                    const contentSections = document.querySelectorAll('#secondaryColumn .sidebar-content');
                    contentSections.forEach(content => {
                        if (content) content.style.display = 'none';
                    });
                    
                    // Show the mockups content
                    const mockupsContent = document.getElementById('mockupsContent');
                    if (mockupsContent) {
                        mockupsContent.style.display = 'block';
                    }
                    
                    // If the sidebar is collapsed, uncollapse it
                    if (secondaryColumn.classList.contains('collapsed')) {
                        const toggleButton = secondaryColumn.querySelector('button');
                        toggleSidebar('secondaryColumn', toggleButton);
                    }
                });
            }
                

        });
        // Function to load mockups via AJAX
function loadMockups() {
    fetch('/tif-editor/api/mockups/')
        .then(response => response.json())
        .then(data => {
            console.log('API Response:', data); // Debug log
            if (data.success) {
                console.log('Mockups data:', data.mockups); // Debug log
                renderMockups(data.mockups);
            } else {
                console.error('Error loading mockups:', data.error);
                showToast('Failed to load mockups', 'error');
            }
        })
        .catch(error => {
            console.error('Network error:', error);
            showToast('Network error while loading mockups', 'error');
        });
}

function renderMockups(mockups) {
    const mockupsGrid = document.querySelector('.mockups-grid');
    
    if (!mockupsGrid) {
        console.error('Mockups grid container not found');
        return;
    }
    
    // Clear existing content
    mockupsGrid.innerHTML = '';
    
    if (mockups.length === 0) {
        mockupsGrid.innerHTML = '<p class="text-center text-muted">No mockups available.</p>';
        return;
    }
    
    // Create mockup items
    mockups.forEach(mockup => {
        const mockupItem = document.createElement('div');
        mockupItem.className = 'mockup-item';
        mockupItem.dataset.mockupId = mockup.id;
        
        // Use the complete data URL or fallback to placeholder
        let imageSrc = '/static/images/placeholder.png';
        if (mockup.has_image && mockup.image_data_url) {
            imageSrc = mockup.image_data_url;
        }
        
        mockupItem.innerHTML = `
            <img src="${imageSrc}" alt="${mockup.name}" 
                 style="max-width: 100%; height: auto;"
                 onload="console.log('✓ Image loaded:', '${mockup.name}')"
                 onerror="console.error('✗ Image failed:', '${mockup.name}'); this.src='/static/images/placeholder.png'">
            <div class="mockup-info">
                <span class="mockup-name">${mockup.name}</span>
                <button class="btn btn-sm btn-primary apply-mockup-btn">Apply</button>
            </div>
        `;
        
        mockupsGrid.appendChild(mockupItem);
    });
}

// Updated apply mockup function
document.addEventListener('click', function(e) {
    if (e.target.classList.contains('apply-mockup-btn')) {
        e.preventDefault();
        
        const mockupItem = e.target.closest('.mockup-item');
        const mockupId = mockupItem.dataset.mockupId;
        const mockupName = mockupItem.querySelector('.mockup-name').textContent;
        const mockupImg = mockupItem.querySelector('img');
        const mockupDataUrl = mockupImg.src; // This will be the data URL
        
        applyMockupOverlay(mockupId, mockupDataUrl, mockupName);
    }
});
// Updated DOMContentLoaded event
document.addEventListener('DOMContentLoaded', function() {
    // Add mockups button handler
    const mockupsButton = document.getElementById('mockupsButton');
    if (mockupsButton) {
        mockupsButton.addEventListener('click', function(e) {
            e.preventDefault();
            
            // Set this button as active
            const navButtons = document.querySelectorAll('.mostLeftUl li a');
            navButtons.forEach(button => {
                button.classList.remove('active');
            });
            this.classList.add('active');
            
            // Make sure secondaryColumn is visible
            const secondaryColumn = document.getElementById('secondaryColumn');
            secondaryColumn.style.display = 'flex';
            
            // Hide all content sections inside secondaryColumn
            const contentSections = document.querySelectorAll('#secondaryColumn .sidebar-content');
            contentSections.forEach(content => {
                if (content) content.style.display = 'none';
            });
            
            // Show the mockups content
            const mockupsContent = document.getElementById('mockupsContent');
            if (mockupsContent) {
                mockupsContent.style.display = 'block';
                
                // Load mockups via AJAX
                loadMockups();
            }
            
            // If the sidebar is collapsed, uncollapse it
            if (secondaryColumn.classList.contains('collapsed')) {
                const toggleButton = secondaryColumn.querySelector('button');
                toggleSidebar('secondaryColumn', toggleButton);
            }
        });
    }
    
    // Updated click handlers for dynamic mockup apply buttons
    document.addEventListener('click', function(e) {
        if (e.target.classList.contains('apply-mockup-btn')) {
            e.preventDefault();
            
            const mockupItem = e.target.closest('.mockup-item');
            const mockupId = mockupItem.dataset.mockupId;
            const mockupName = mockupItem.querySelector('.mockup-name').textContent;
            const mockupUrl = mockupItem.querySelector('img').src;
            
            applyMockupOverlay(mockupId, mockupUrl, mockupName);
        }
    });
});
        </script>  
        <style>
                .canvas-container {
        position: relative;
        overflow: hidden;

        width: {{width}}px;
        height: {{height}}px;
      }
           #harmonyMenu {
            display: none;
        }
      .loader {
        width: 120px;
        height: 22px;
        border-radius: 20px;
        color: #514b82;
        border: 2px solid;
        position: relative;
      }
      .loader::before {
        content: "";
        position: absolute;
        margin: 2px;
        inset: 0 100% 0 0;
        border-radius: inherit;
        background: currentColor;
        animation: l6 2s infinite;
      }
      @keyframes l6 {
          100% {inset:0}
      }

      .fav-count {
  display: none !important;
}

        </style>
  </head>

  <body>
    <div id="loading-screen" class="fixed inset-0 flex items-center justify-center bg-white bg-opacity-95 z-50">
    <div class="text-center">
      <div class="mb-4">
        <div class="w-16 h-16 border-4 border-blue-200 border-t-blue-600 rounded-full animate-spin mx-auto"></div>
      </div>
      <div class="text-blue-600 font-semibold text-lg">Processing...</div>
      <div class="text-gray-500 text-sm mt-2">Please wait while we prepare your image</div>
    </div>
  </div>

    <!-- Main Content Area  -->
    <main class="d-flex">
      <!-- Left Sidebar -->
      <div
        id="leftMostColumn"
        class="sidebar d-flex flex-column"
        style="flex: 0 0 12%"
      >
        <button
          class="btn btn-primary btn-sm m-2 d-flex align-items-center"
          onclick="toggleSidebar('leftMostColumn', this)"
        >
          <i class="bi bi-caret-left-fill ms-auto"></i>
        </button>
        <div class="header-logo" style="margin:0 auto;" >
          <a href="{% url 'home' %}">
            <img src="{% static 'images/logo.png' %}" alt="Colorify Logo" style="max-width: 100%; height: auto; max-height: 40px;">
          </a>
        </div>
        <ul class="mostLeftUl">
          <li>
            <a href="#" id="inspirationButton">
              <i class="bi bi-brightness-alt-high me-2 mx-1"></i>
              <span class="textSpan">Inspiration</span>
            </a>
          </li>
          <li>
            <a href="#" id="trendingButton">
              <i class="bi bi-graph-up-arrow mx-1"></i>
              <span class="textSpan">Trending</span>
            </a>
          </li>
          <li>
            <a href="#" id="effectsButton">
              <i class="bi bi-magic mx-1"></i>
              <span class="textSpan">Effects</span>
            </a>
          </li>
         <li>
            <a href="#" id="favoriteButton">
              <i class="bi bi-star mx-1"></i>
              <span class="textSpan">Favourite</span>
            </a>
          </li>  
          <li>
            <a href="#" id="harmonyButton">
              <i class="bi bi-palette2 mx-1"></i>
              <span class="textSpan">Harmony</span>
            </a>
          </li>
          {% comment %} <li>
            <a href="#" id="paletteGeneratorButton">
              <i class="bi bi-eyedropper mx-1"></i>
              <span class="textSpan">Color Picker</span>
            </a>
          </li> {% endcomment %}
          {% comment %} <li>
            <a href="#" id="baseColorButton">
              <i class="bi bi-palette mx-1"></i>
              <span class="textSpan">Base Color</span>
            </a>
          </li> {% endcomment %}
          <li>
            <a href="#" id="ssCollectionButton">
              <i class="bi bi-collection mx-1"></i>
              <span class="textSpan">SS Collection</span>
            </a>
          </li>
          <li>
            <a href="#" id="awCollectionButton">
              <i class="bi bi-collection mx-1"></i>
              <span class="textSpan">AW Collection</span>
            </a>
          </li>
         <li>
          <a href="#" id="mockupsButton">
            <i class="bi bi-brush-fill mx-1"></i>
            <span class="textSpan">mockups</span>
          </a>
        </li>
        <li>
    <a href="{% url 'profile-dashboard' %}" class="block text-sm text-gray-700 hover:bg-gray-100" role="menuitem" tabindex="-1">
        <i class="bi bi-person-circle mx-1"></i>
        <span class="textSpan">Your Profile</span>
    </a>
</li>
{% comment %} <li>
    <a href="#" class="block text-sm text-gray-700 hover:bg-gray-100" role="menuitem" tabindex="-1">
        <i class="bi bi-gear-fill mx-1"></i>
        <span class="textSpan">Settings</span>
    </a>
</li> {% endcomment %}
<li>
    <a href="{% url 'account_logout' %}" class="block text-sm text-gray-700 hover:bg-gray-100" role="menuitem" tabindex="-1">
        <i class="bi bi-box-arrow-right mx-1"></i>
        <span class="textSpan">Sign out</span>
    </a>
</li>

        </ul>
      </div>


        <div id="secondaryColumn" class="sidebar d-flex flex-column" style="flex: 0 0 20% ;>
          <button class="btn-sm m-2 d-flex align-items-center nav-btn"  style="border: none; background: #fff">
              <i class="bi bi-caret-left-fill ms-auto"></i>
          </button>
          
          <!-- Trending Content -->
     
          <div class="sidebar-content" id="trendingContent" style="display: none;">
            <h4 class="ms-auto me-auto">Trending Palette</h4>
            <hr />
            <div class="layer-toggles d-flex gap-3 justify-content-center flex-wrap">
              {% if layers|length == 1 %}
              {% for i in "01234567890123456789012345" %}
                  <div class="layer-toggle-item d-flex flex-column gap-2">
                      <div id="trending_colorPalette_{{ forloop.counter0 }}" class="color-palette d-flex flex-column"></div>
                          <button type="button" 
                                  id="trending_fav_btn_{{ forloop.counter0 }}" 
                                  class="btn favorite-btn {% if is_favorite %}active{% endif %}"
                                  data-palette-type="TR"
                                  data-colors-id="{{ forloop.counter0 }}"
                                  onclick="toggleFavorite(this, 'trending')">
                              <i class="bi {% if is_favorite %}bi-star-fill{% else %}bi-star{% endif %}"></i>
                              <span class="fav-count">{{ favorites_count|default:0 }}</span>
                          </button>
                  </div>
              {% endfor %}
          {% else %}
          
                    {% for layer in layers %}
                        <div class="layer-toggle-item d-flex flex-column gap-2">
                            <div id="trending_colorPalette_{{ forloop.counter }}" class="color-palette d-flex flex-column"></div>
                            <div class="d-flex align-items-center justify-content-between w-100">
                              
                                <button type="button" 
                                        id="trending_fav_btn_{{ forloop.counter }}" 
                                        class="btn favorite-btn"
                                        data-palette-type="TR"
                                        data-colors-id="{{ forloop.counter }}"
                                        onclick="toggleFavorite(this, 'trending')">
                                    <i class="bi bi-star"></i>
                                    <span class="fav-count">0</span>
                                </button>
                               
                            </div>
                        </div>
                    {% endfor %}
                {% endif %}
            </div>
        </div>
    
        <div class="sidebar-content m-4" id="inspirationContent">
          <h4 class="ms-auto me-auto">Inspirations</h4>
          <div class="inspiration-content">
              <div class="pdf-grid">

              </div>
          </div>
      </div>
      <div class="sidebar-content" id="effectsContent" style="display: none;">
        <h4 class="ms-auto me-auto">Effects</h4>
        <div class="effects-grid">
            <div class="effect-item" data-effect="grayscale">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Grayscale">
                    <div class="effect-name">Grayscale</div>
                </div>
            </div>
            <div class="effect-item" data-effect="sepia">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Sepia">
                    <div class="effect-name">Sepia</div>
                </div>
            </div>
            <div class="effect-item" data-effect="brightness">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Brightness">
                    <div class="effect-name">Brightness</div>
                </div>
            </div>
            <div class="effect-item" data-effect="contrast">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Contrast">
                    <div class="effect-name">Contrast</div>
                </div>
            </div>
            <div class="effect-item" data-effect="blur">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Blur">
                    <div class="effect-name">Blur</div>
                </div>
            </div>
            <div class="effect-item" data-effect="sharpen">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Sharpen">
                    <div class="effect-name">Sharpen</div>
                </div>
            </div>
            <div class="effect-item" data-effect="vintage">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Vintage">
                    <div class="effect-name">Vintage</div>
                </div>
            </div>
            <div class="effect-item" data-effect="colorize">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Colorize">
                    <div class="effect-name">Colorize</div>
                </div>
            </div>
            <div class="effect-item" data-effect="duotone">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Duotone">
                    <div class="effect-name">Duotone</div>
                </div>
            </div>
            <div class="effect-item" data-effect="noise">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Noise">
                    <div class="effect-name">Noise</div>
                </div>
            </div>
            <div class="effect-item" data-effect="vignette">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Vignette">
                    <div class="effect-name">Vignette</div>
                </div>
            </div>
            <div class="effect-item" data-effect="posterize">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Posterize">
                    <div class="effect-name">Posterize</div>
                </div>
            </div>
            <div class="effect-item" data-effect="saturation">
                <div class="effect-preview">
                    <img src="https://i.pinimg.com/1200x/91/a1/8d/91a18dfb5479bda15a1bade67619a943.jpg" alt="Saturation">
                    <div class="effect-name">Saturation</div>
                </div>
            </div>
        </div>
    </div>

<div class="sidebar-content" id="paletteGeneratorContent" style="display: none;">
  <h4 class="ms-auto me-auto">Color Picker</h4>
  <hr />
  
  <!-- Controls -->
  <div class="palette-generator-controls px-3 mb-3">
    <div class="d-flex align-items-center justify-content-between mb-2">
      <label class="form-label mb-0">Color Pickers:</label>
      <div class="cursor-controls">
        <button class="btn btn-sm btn-outline-primary me-1" id="decreaseCursors" title="Remove cursor">
          <i class="bi bi-dash"></i>
        </button>
        <span id="cursorCount" class="mx-2">3</span>
        <button class="btn btn-sm btn-outline-primary ms-1" id="increaseCursors" title="Add cursor">
          <i class="bi bi-plus"></i>
        </button>
      </div>
    </div>
    
    <button class="btn btn-primary btn-sm w-100 mb-2" id="resetCursors">
      <i class="bi bi-arrow-clockwise"></i> Reset Positions
    </button>
    
    <button class="btn btn-success btn-sm w-100" id="savePalette">
      <i class="bi bi-check-circle"></i> Save Palette
    </button>
  </div>
  
  <!-- Generated Palettes Display -->
  <div class="generated-palettes-container">
    <div class="layer-toggles d-flex gap-3 justify-content-center flex-wrap" id="generatedPalettesDisplay">
      <!-- Generated palettes will appear here -->
    </div>
  </div>
</div>
    <!-- Harmony Content -->
<!-- Harmony Content -->
<div class="sidebar-content" id="harmonyContent" style="display: none;">
  <h4 class="ms-auto me-auto">Color Harmony</h4>
  
  <!-- Harmony Type Selector -->
  <div class="harmony-selector mb-3 px-3">
    <label for="harmonyTypeSelect" class="form-label">Harmony Type:</label>
    <select class="form-select form-select-sm" id="harmonyTypeSelect">
      <option value="Monochromatic">Monochromatic</option>
      <option value="Analogous">Analogous</option>
      <option value="Complementary">Complementary</option>
      <option value="Split Complementary">Split Complementary</option>
      <option value="Triadic">Triadic</option>
      <option value="Tetradic">Tetradic</option>
      <option value="Square">Square</option>
    </select>
    
    <!-- Background Variation Selector -->
    <label for="backgroundVariationSelect" class="form-label mt-2">Background Style:</label>
    <select class="form-select form-select-sm" id="backgroundVariationSelect">
      <option value="regular">Regular</option>
      <option value="dark">Dark</option>
      <option value="faint">Faint</option>
      <option value="mixed">Mixed (All Variations)</option>
    </select>
    
    <button class="btn btn-primary btn-sm mt-2 w-100" id="generateHarmonyBtn">
      <i class="bi bi-magic"></i> Generate Harmony
    </button>
  </div>
  
  <hr />
  
  <!-- Loading indicator -->
  <div id="harmonyLoadingIndicator" class="text-center py-3" style="display: none;">
    <div class="spinner-border spinner-border-sm" role="status">
      <span class="visually-hidden">Loading...</span>
    </div>
    <div class="mt-2">Generating harmony palettes...</div>
  </div>
  
  <!-- Harmony Palettes Container -->
  <div class="layer-toggles d-flex gap-3 justify-content-center flex-wrap" id="harmonyPalettesContainer">
    <!-- Palettes will be generated here dynamically -->
  </div>
</div>
     <!-- SS Collection Content -->
     <div class="sidebar-content" id="ssCollectionContent" style="display: none;">
      <h4 class="ms-auto me-auto">SS Collection</h4>
      <hr />
      <div class="layer-toggles d-flex gap-3 justify-content-center flex-wrap">
          {% if layers|length == 1 %}
              {% for i in "0123456789" %}
                  <div class="layer-toggle-item d-flex flex-column gap-2">
                      <div id="ss_colorPalette_{{ forloop.counter0 }}" class="color-palette d-flex flex-column"></div>
                      <div class="d-flex align-items-center justify-content-between w-100">
                         
                          <button type="button" 
                                  id="ss_fav_btn_{{ forloop.counter0 }}" 
                                  class="btn favorite-btn"
                                  data-palette-type="SS"
                                  data-colors-id="{{ forloop.counter0 }}"
                                  onclick="toggleFavorite(this, 'ss')">
                              <i class="bi bi-star"></i>
                              <span class="fav-count">0</span>
                          </button>
                          
                      </div>
                  </div>
              {% endfor %}
          {% else %}
              {% for layer in layers %}
                  <div class="layer-toggle-item d-flex flex-column gap-2">
                      <div id="ss_colorPalette_{{ forloop.counter }}" class="color-palette d-flex flex-column"></div>
                      <div class="d-flex align-items-center justify-content-between w-100">
                          <button type="button" 
                                  id="ss_fav_btn_{{ forloop.counter }}" 
                                  class="btn favorite-btn"
                                  data-palette-type="SS"
                                  data-colors-id="{{ forloop.counter }}"
                                  onclick="toggleFavorite(this, 'ss')">
                              <i class="bi bi-star"></i>
                              <span class="fav-count">0</span>
                          </button>
                      </div>
                  </div>
              {% endfor %}
          {% endif %}
      </div>
  </div>
  

<div class="sidebar-content" id="favCollectionContent" style="display: none;">
  <h4 class="ms-auto me-auto">Favourite Collection</h4>
  <hr />
  <div class="layer-toggles d-flex gap-3 justify-content-center flex-wrap">
      
    {% for layer in layers %}

    <div class="layer-toggle-item d-flex flex-column gap-2">
        <div id="fav_colorPalette_{{ forloop.counter }}" class="color-palette d-flex flex-column"></div>
        <div class="d-flex align-items-center justify-content-between w-100">
        <button type="button" id="" class="btn">
          <i class="bi bi-star"></i>
      </button>
        </div>
    </div>
    {% endfor %}
</div>
</div> 
<!-- Base Color Content -->
<!-- Base Color Content -->
<div class="sidebar-content" id="baseColorContent" style="display: none;">
  <h4 class="ms-auto me-auto">Base Colors</h4>
  <div class="base-colors-grid">
    <!-- Color blocks will be generated here -->
  </div>

  <!-- Hidden palettes section - modified to support 70 palettes -->
  <div class="base-palettes-section" style="display: none;">
    <hr/>
    <div class="base-palettes-container">
      <!-- The palette containers will be generated dynamically via JavaScript -->
    </div>
  </div>
</div>

<!-- AW Collection Content -->
<div class="sidebar-content" id="awCollectionContent" style="display: none;">
  <h4 class="ms-auto me-auto">AW Collection</h4>
  <hr />
  <div class="layer-toggles d-flex gap-3 justify-content-center flex-wrap">
      {% if layers|length == 1 %}
          {% for i in "0123456789" %}
              <div class="layer-toggle-item d-flex flex-column gap-2">
                  <div id="aw_colorPalette_{{ forloop.counter0 }}" class="color-palette d-flex flex-column"></div>
                  <div class="d-flex align-items-center justify-content-between w-100">
                      <button type="button" 
                              id="aw_fav_btn_{{ forloop.counter0 }}" 
                              class="btn favorite-btn"
                              data-palette-type="AW"
                              data-colors-id="{{ forloop.counter0 }}"
                              onclick="toggleFavorite(this, 'aw')">
                          <i class="bi bi-star"></i>
                          <span class="fav-count">0</span>
                      </button>
                  </div>
              </div>
          {% endfor %}
      {% else %}
          {% for layer in layers %}
              <div class="layer-toggle-item d-flex flex-column gap-2">
                  <div id="aw_colorPalette_{{ forloop.counter }}" class="color-palette d-flex flex-column"></div>
                  <div class="d-flex align-items-center justify-content-between w-100">
                      <button type="button" 
                              id="aw_fav_btn_{{ forloop.counter }}" 
                              class="btn favorite-btn"
                              data-palette-type="AW"
                              data-colors-id="{{ forloop.counter }}"
                              onclick="toggleFavorite(this, 'aw')">
                          <i class="bi bi-star"></i>
                          <span class="fav-count">0</span>
                      </button>
                  </div>
              </div>
          {% endfor %}
      {% endif %}
  </div>
</div>

<div class="sidebar-content" id="mockupsContent" style="display: none;">
    <h4 class="ms-auto me-auto">Mockups</h4>
    <div class="mockups-grid">
        <!-- Mockups will be loaded here via AJAX -->
        <div class="text-center">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading mockups...</span>
            </div>
        </div>
    </div>
</div>
      </div>


      <!-- Main Content -->
      <div id="mainContent" class="content">
        <div class="d-flex align-items-center justify-content-between">
          <h2 class="fs-4 fw-bold">Workspace</h2>
          <div class="zoom-controls">
            <label for="zoomSlider" class="me-2">Zoom:</label>
            <input
              type="range"
              id="zoomSlider"
              class="zoom-slider"
              min="5"
              max="150"
              value="5"
              step="1"
            />
          </div>
        </div>
        <hr />

        <div class="zoom-wrapper" id="zoomWrapper">
          <div class="canvas-container">
            {% for layer in layers %}
              <div
                class="layer"
                id="layer_{{ forloop.counter }}"
                style="top: {{ layer.layer_position_from_top }}px; left: {{ layer.layer_position_from_left }}px;"
                {% if layer.ml_label is not None %}data-ml-label="{{ layer.ml_label }}"{% endif %}
                data-dpi-x="{{ layer.dpi_x|default:300 }}"
                data-dpi-y="{{ layer.dpi_y|default:300 }}"
              >
                <canvas 
                  id="layer_canvas_{{ forloop.counter }}" 
                  data-original-src="{{ layer.path }}"
                  data-original-width="{{ layer.original_width }}"
                  data-original-height="{{ layer.original_height }}"
                  data-dpi-x="{{ layer.dpi_x|default:500 }}"
                  data-dpi-y="{{ layer.dpi_y|default:500 }}"
                  data-original-physical-width-inches="{{ layer.physical_width_inches }}"
                  data-original-physical-height-inches="{{ layer.physical_height_inches }}"
                ></canvas>
                <!-- Removed the visible ml-label-indicator div -->
              </div>
            {% endfor %}
          </div>
        </div>
      </div>

     
       



      <!-- Color Picker Modal -->
      <div
        class="modal fade"
        id="colorPickerModal"
        tabindex="-1"
        role="dialog"
        aria-labelledby="colorPickerModalLabel"
        aria-hidden="true"
        data-backdrop="false"
      >
        <div class="modal-dialog" role="document">
          <div class="modal-content">
            <div class="modal-header">
              <h5 class="modal-title" id="colorPickerModalLabel">
                Select Layer Color
              </h5>
              <div style="text-align: center; margin-bottom: 20px">
                <label for="color-count-slider">Number of Colors: </label>
                <input
                  type="range"
                  id="color-count-slider"
                  min="1"
                  max="50"
                  value="50"
                  oninput="updateColorCountDisplay()"
                />
                <span id="color-count-display">50</span>
              </div>
            </div>
            <div class="modal-body">
              <div
                class="color-picker-container pickr-container"
                id="color-pickers"
              ></div>
              {% comment %} <button
                id="generatePallateColorsBtn"
                class="btn btn-warning mt-2"
                onclick="generatePallateColors()"
              >
                Generate New Colors
              </button> {% endcomment %}
            </div>
            <div class="modal-footer">
              <button
                type="button"
                class="btn btn-secondary"
                data-dismiss="modal"
                onclick="hideModal()"
              >
                Close
              </button>
            </div>
          </div>
        </div>
      </div>
    </main>

  <!-- Footer -->
<footer class="bg-light text-center py-2 mt-auto visualizer_toolbar d-flex align-items-center justify-content-center gap-4">
     
<div id="visualizer_buttons_left">
    <div class="d-flex align-items-center gap-2">
        <div class="upload-wrapper">
            <form id="uploadForm" method="post" enctype="multipart/form-data">
                {% csrf_token %}
                <input type="file" id="fileInput" name="image_file" accept=".png,.jpg,.jpeg" style="display: none;">
                <button type="button" class="btn btn-outline-dark upload-btn m-0 p-2 px-3 bg-linear-blue" onclick="document.getElementById('fileInput').click();">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-cloud-upload" viewBox="0 0 16 16">
                        <path fill-rule="evenodd" d="M4.406 1.342A5.53 5.53 0 0 1 8 0c2.69 0 4.923 2 5.166 4.579C14.758 4.804 16 6.137 16 7.773 16 9.569 14.502 11 12.687 11H10a.5.5 0 0 1 0-1h2.688C13.979 10 15 8.988 15 7.773c0-1.216-1.02-2.228-2.313-2.228h-.5v-.5C12.188 2.825 10.328 1 8 1a4.53 4.53 0 0 0-2.941 1.1c-.757.652-1.153 1.438-1.153 2.055v.448l-.445.049C2.064 4.805 1 5.952 1 7.318 1 8.785 2.23 10 3.781 10H6a.5.5 0 0 1 0 1H3.781C1.708 11 0 9.366 0 7.318c0-1.763 1.266-3.223 2.942-3.593.143-.863.698-1.723 1.464-2.383"/>
                        <path fill-rule="evenodd" d="M7.646 4.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 5.707V14.5a.5.5 0 0 1-1 0V5.707L5.354 7.854a.5.5 0 1 1-.708-.708z"/>
                    </svg>
                    Upload
                </button>
            </form>
        </div>
    </div>
</div>

    
    <div class="image-adjustments">
      <button type="button" class="btn shadow-lg " id="adjustmentToggle">
        <svg width="19" height="19" viewBox="0 0 34 33" fill="none" xmlns="http://www.w3.org/2000/svg">
          <g clip-path="url(#clip0_384_2340)">
            <path
              d="M32.186 15.2545H13.3887C12.7572 12.7733 10.2339 11.2738 7.75261 11.9053C6.10713 12.3241 4.82225 13.609 4.40344 15.2545H1.90915C1.26599 15.2545 0.744629 15.7759 0.744629 16.419C0.744629 17.0622 1.26599 17.5835 1.90915 17.5835H4.40351C5.035 20.0647 7.55836 21.5641 10.0396 20.9326C11.6851 20.5138 12.97 19.2289 13.3888 17.5835H32.186C32.8291 17.5835 33.3505 17.0621 33.3505 16.4189C33.3505 15.7758 32.8291 15.2545 32.186 15.2545ZM8.89611 18.748C7.60987 18.748 6.56715 17.7053 6.56715 16.419C6.56715 15.1328 7.60987 14.09 8.89611 14.09C10.1824 14.09 11.2251 15.1328 11.2251 16.419C11.2251 17.7053 10.1824 18.748 8.89611 18.748Z"
              fill="#3C4CD1" />
            <path
              d="M32.1862 3.60947H28.5274C27.8959 1.12828 25.3726 -0.371188 22.8913 0.260301C21.2458 0.679109 19.9609 1.96399 19.5421 3.60947H1.90939C1.26623 3.60947 0.744873 4.13084 0.744873 4.77399C0.744873 5.41715 1.26623 5.93851 1.90939 5.93851H19.5421C20.1736 8.4197 22.697 9.91917 25.1782 9.28768C26.8237 8.86887 28.1086 7.58399 28.5274 5.93851H32.1862C32.8294 5.93851 33.3507 5.41715 33.3507 4.77399C33.3507 4.13084 32.8294 3.60947 32.1862 3.60947ZM24.0348 7.10296C22.7486 7.10296 21.7058 6.06023 21.7058 4.77399C21.7058 3.48775 22.7486 2.44502 24.0348 2.44502C25.3211 2.44502 26.3638 3.48775 26.3638 4.77399C26.3638 6.06023 25.3211 7.10296 24.0348 7.10296Z"
              fill="#3C4CD1" />
            <path
              d="M32.186 26.8993H26.1981C25.5667 24.4181 23.0433 22.9186 20.562 23.5501C18.9165 23.9689 17.6317 25.2538 17.2129 26.8993H1.90915C1.26599 26.8993 0.744629 27.4206 0.744629 28.0637C0.744629 28.7068 1.26599 29.2282 1.90915 29.2282H17.2129C17.8444 31.7094 20.3678 33.2089 22.849 32.5774C24.4945 32.1586 25.7794 30.8737 26.1982 29.2282H32.186C32.8291 29.2282 33.3505 28.7069 33.3505 28.0637C33.3505 27.4206 32.8291 26.8993 32.186 26.8993ZM21.7055 30.3928C20.4193 30.3928 19.3766 29.35 19.3766 28.0638C19.3766 26.7775 20.4193 25.7348 21.7055 25.7348C22.9918 25.7348 24.0345 26.7775 24.0345 28.0638C24.0345 29.35 22.9918 30.3928 21.7055 30.3928Z"
              fill="#3C4CD1" />
          </g>
          <defs>
            <clipPath id="clip0_384_2340">
              <rect width="32.6059" height="32.6059" fill="white" transform="translate(0.744873 0.115967)" />
            </clipPath>
          </defs>
        </svg>
      </button>
      <div id="adjustmentPanel" class="adjustment-panel" style="display: none;">
          <div class="sliders-container"></div>
      </div>
    </div>
    
    <!-- Fullscreen Toggle Button -->
    <button type="button" class="btn shadow-lg" id="fullscreenToggle" title="Toggle Fullscreen (F11)">
      <svg width="19" height="19" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M3 3V9M3 3H9M3 3L9 9M21 3V9M21 3H15M21 3L15 9M3 21V15M3 21H9M3 21L9 15M21 21V15M21 21H15M21 21L15 15" stroke="#3C4CD1" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </button>
   
    </div>
  </div>
<script>
document.addEventListener('DOMContentLoaded', function() {
    const leftBtn = document.getElementById('scroll-left');
    const rightBtn = document.getElementById('scroll-right');
    
    function scrollLeft() {
        // Try multiple possible scroll containers
        const containers = [
            document.querySelector('.scroll-container'),
            document.getElementById('image-color-pickers'),
            document.querySelector('.palette-selector')
        ];
        
        for (let container of containers) {
            if (container && container.scrollWidth > container.clientWidth) {
                const scrollAmount = container.clientWidth * 0.3;
                container.scrollLeft = Math.max(0, container.scrollLeft - scrollAmount);
                break;
            }
        }
    }
    
    function scrollRight() {
        // Try multiple possible scroll containers
        const containers = [
            document.querySelector('.scroll-container'),
            document.getElementById('image-color-pickers'),
            document.querySelector('.palette-selector')
        ];
        
        for (let container of containers) {
            if (container && container.scrollWidth > container.clientWidth) {
                const scrollAmount = container.clientWidth * 0.3;
                const maxScroll = container.scrollWidth - container.clientWidth;
                container.scrollLeft = Math.min(maxScroll, container.scrollLeft + scrollAmount);
                break;
            }
        }
    }
    
    if (leftBtn) leftBtn.addEventListener('click', scrollLeft);
    if (rightBtn) rightBtn.addEventListener('click', scrollRight);
});</script>

<style>
.scroll-container,
.palette-selector,
#image-color-pickers {
    overflow-x: auto !important;
    scroll-behavior: smooth !important;
}

.color-picker-container {
    display: flex !important;
    white-space: nowrap !important;
}
    </style>
  <div id="visualizer_palette" class="palette-wrapper">
      <!-- Left Scroll Button -->
      <button id="scroll-left" class="btn btn-outline-info"><</button>
      <div class="palette-selector has-btns is-sortable has-picker is-lockable is-sortable has-picker is-lockable scroll-container" style="height: 100%;" data-colors="10">
          <div class="color-picker-container mt-1 rounded-2" style="width: fit-content;overflow: visible;" id="image-color-pickers"></div>
      </div>
      <button id="scroll-right" class="btn btn-outline-info">></button>
  </div>
  <button type="button" class="btn btn-success2 shadow-lg">
    <svg width="20" height="20" viewBox="0 0 33 33" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path
        d="M19.3118 12.7204C20.2116 11.807 21.2664 11.3242 22.3622 11.3242H26.2204L24.7538 12.7908C24.6119 12.9327 24.4993 13.1012 24.4225 13.2867C24.3457 13.4721 24.3061 13.6708 24.3061 13.8716C24.3061 14.0723 24.3457 14.271 24.4225 14.4565C24.4993 14.6419 24.6119 14.8104 24.7538 14.9523C25.0404 15.239 25.4292 15.4 25.8346 15.4C26.0353 15.4 26.234 15.3605 26.4195 15.2837C26.6049 15.2068 26.7734 15.0943 26.9153 14.9523L30.9911 10.8766C31.133 10.7347 31.2456 10.5662 31.3224 10.3807C31.3992 10.1953 31.4388 9.99654 31.4388 9.79583C31.4388 9.59511 31.3992 9.39635 31.3224 9.21091C31.2456 9.02547 31.133 8.85698 30.9911 8.71505L26.9153 4.63932C26.7734 4.49739 26.6049 4.38481 26.4195 4.308C26.234 4.23118 26.0353 4.19165 25.8346 4.19165C25.6338 4.19165 25.4351 4.23118 25.2497 4.308C25.0642 4.38481 24.8957 4.49739 24.7538 4.63932C24.6119 4.78125 24.4993 4.94974 24.4225 5.13518C24.3457 5.32062 24.3061 5.51937 24.3061 5.72009C24.3061 5.92081 24.3457 6.11956 24.4225 6.305C24.4993 6.49044 24.6119 6.65893 24.7538 6.80086L26.2204 8.26742H22.3622C20.0744 8.26742 17.9771 9.41812 16.468 11.3292C17.1472 12.3407 17.6686 13.4496 18.0142 14.6179C18.3375 13.9172 18.7761 13.2758 19.3118 12.7204Z"
        fill="#3C4CD1" />
      <path
        d="M12.3627 20.1175C11.4628 21.0308 10.408 21.5136 9.31225 21.5136H3.41829C3.01294 21.5136 2.62418 21.6746 2.33755 21.9613C2.05092 22.2479 1.88989 22.6367 1.88989 23.042C1.88989 23.4474 2.05092 23.8361 2.33755 24.1228C2.62418 24.4094 3.01294 24.5704 3.41829 24.5704H9.31225C11.6 24.5704 13.6974 23.4197 15.2065 21.5086C14.5272 20.4972 14.0058 19.3883 13.66 18.22C13.3368 18.9206 12.8983 19.562 12.3627 20.1175Z"
        fill="#3C4CD1" />
      <path
        d="M26.9156 17.8854C26.7737 17.7434 26.6052 17.6309 26.4197 17.554C26.2343 17.4772 26.0355 17.4377 25.8348 17.4377C25.6341 17.4377 25.4354 17.4772 25.2499 17.554C25.0645 17.6309 24.896 17.7434 24.7541 17.8854C24.6121 18.0273 24.4995 18.1958 24.4227 18.3812C24.3459 18.5667 24.3064 18.7654 24.3064 18.9661C24.3064 19.1669 24.3459 19.3656 24.4227 19.551C24.4995 19.7365 24.6121 19.905 24.7541 20.0469L26.2207 21.5135H22.3625C21.2667 21.5135 20.2119 21.0307 19.3121 20.1173C18.3449 19.1357 17.6439 17.7197 17.3383 16.1302C16.4479 11.5006 13.1475 8.26733 9.31225 8.26733H3.41829C3.01294 8.26733 2.62418 8.42836 2.33755 8.71499C2.05092 9.00162 1.88989 9.39038 1.88989 9.79573C1.88989 10.2011 2.05092 10.5898 2.33755 10.8765C2.62418 11.1631 3.01294 11.3241 3.41829 11.3241H9.31225C10.408 11.3241 11.4628 11.8069 12.3627 12.7203C13.3298 13.7019 14.0307 15.1179 14.3364 16.7074C15.2268 21.3369 18.5272 24.5703 22.3625 24.5703H26.2207L24.7541 26.0368C24.4674 26.3235 24.3064 26.7122 24.3064 27.1176C24.3064 27.523 24.4674 27.9117 24.7541 28.1984C25.0407 28.485 25.4295 28.646 25.8348 28.646C26.2402 28.646 26.629 28.485 26.9156 28.1984L30.9913 24.1226C31.1333 23.9807 31.2459 23.8122 31.3227 23.6268C31.3995 23.4413 31.439 23.2426 31.439 23.0419C31.439 22.8412 31.3995 22.6424 31.3227 22.457C31.2459 22.2715 31.1333 22.103 30.9913 21.9611L26.9156 17.8854Z"
        fill="#3C4CD1" />
    </svg>
</button>


{% comment %} <div class="harmony-container">
  <button type="button" class="btn shadow-lg" id="harmonyButton">
    <svg width="20" height="20" viewBox="0 0 34 33" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path
        d="M7.69539 17.8844C6.91996 17.8844 6.46696 17.0055 6.91804 16.3738L9.19939 13.18L7.93224 8.66352C7.73201 7.94992 8.38976 7.28364 9.11004 7.48571L13.6265 8.75287L16.8203 6.47152C17.4513 6.02094 18.3309 6.47266 18.3309 7.24887V11.3504L22.0167 14.0551C22.6998 14.5563 22.4375 15.6362 21.601 15.7687L20.2474 15.9831L31.9226 26.3235C33.5103 27.7129 33.5925 30.1613 32.1001 31.6535C30.6084 33.1454 28.1582 33.0626 26.7737 31.4803L16.4296 19.8007L16.2153 21.1543C16.0828 21.9906 15.0027 22.2532 14.5016 21.57L11.7969 17.8843H7.69539V17.8844ZM28.2078 30.2179C28.8759 30.9815 30.0421 31.0098 30.7492 30.3026C31.4508 29.6011 31.4362 28.4367 30.6601 27.7575L22.3717 20.4168L20.8633 21.9252L28.2078 30.2179ZM19.5943 20.4923L20.9388 19.1478L17.8028 16.3703L16.9517 16.5051L16.8168 17.3563L19.5943 20.4923ZM13.0509 16.3639L14.6866 18.5929C16.1333 9.45991 13.753 24.4867 15.1732 15.5207C15.238 15.112 15.5586 14.7914 15.9673 14.7267C16.6508 14.6184 18.4071 14.3402 19.0395 14.24L16.8105 12.6043C16.5652 12.4244 16.4204 12.1384 16.4204 11.8342V9.10505L14.3646 10.5736C14.129 10.7418 13.8299 10.7943 13.5512 10.716L10.2311 9.78445L11.1626 13.1046C11.2408 13.3833 11.1884 13.6823 11.0202 13.9179L9.5517 15.9737H12.2808C12.585 15.9738 12.871 16.1186 13.0509 16.3639Z"
        fill="#3C4CD1" />
      <path
        d="M4.5745 3.55524H4.00133V4.12841C4.00133 4.65598 3.57361 5.0837 3.04604 5.0837C2.51847 5.0837 2.09076 4.65598 2.09076 4.12841V3.55524H1.51759C0.990013 3.55524 0.5623 3.12753 0.5623 2.59995C0.5623 2.07238 0.990013 1.64467 1.51759 1.64467H2.09076V1.0715C2.09076 0.543924 2.51847 0.116211 3.04604 0.116211C3.57361 0.116211 4.00133 0.543924 4.00133 1.0715V1.64467H4.5745C5.10207 1.64467 5.52979 2.07238 5.52979 2.59995C5.52979 3.12753 5.10214 3.55524 4.5745 3.55524Z"
        fill="#3C4CD1" />
      <path
        d="M14.8284 4.638H14.2552V5.21117C14.2552 5.73875 13.8275 6.16646 13.2999 6.16646C12.7724 6.16646 12.3447 5.73875 12.3447 5.21117V4.638H11.7715C11.2439 4.638 10.8162 4.21029 10.8162 3.68272C10.8162 3.15514 11.2439 2.72743 11.7715 2.72743H12.3447V2.15426C12.3447 1.62669 12.7724 1.19897 13.2999 1.19897C13.8275 1.19897 14.2552 1.62669 14.2552 2.15426V2.72743H14.8284C15.356 2.72743 15.7837 3.15514 15.7837 3.68272C15.7837 4.21029 15.356 4.638 14.8284 4.638Z"
        fill="#3C4CD1" />
      <path
        d="M5.08409 14.3818C5.08409 14.9094 4.65638 15.3371 4.12881 15.3371C3.60123 15.3371 3.17352 14.9094 3.17352 14.3818V13.8087H2.60035C2.07278 13.8087 1.64506 13.3809 1.64506 12.8534C1.64506 12.3258 2.07278 11.8981 2.60035 11.8981H3.17352V11.3249C3.17352 10.7973 3.60123 10.3696 4.12881 10.3696C4.65638 10.3696 5.08409 10.7973 5.08409 11.3249V11.8981H5.65726C6.18484 11.8981 6.61255 12.3258 6.61255 12.8534C6.61255 13.3809 6.18484 13.8087 5.65726 13.8087H5.08409V14.3818Z"
        fill="#3C4CD1" />
      <path
        d="M1.51759 21.0687H2.09076V20.4956C2.09076 19.968 2.51847 19.5403 3.04604 19.5403C3.57361 19.5403 4.00133 19.968 4.00133 20.4956V21.0687H4.5745C5.10207 21.0687 5.52979 21.4965 5.52979 22.024C5.52979 22.5516 5.10207 22.9793 4.5745 22.9793H4.00133V23.5525C4.00133 24.0801 3.57361 24.5078 3.04604 24.5078C2.51847 24.5078 2.09076 24.0801 2.09076 23.5525V22.9793H1.51759C0.990013 22.9793 0.5623 22.5516 0.5623 22.024C0.5623 21.4965 0.990013 21.0687 1.51759 21.0687Z"
        fill="#3C4CD1" />
      <path
        d="M23.9988 3.55524H23.4256V4.12841C23.4256 4.65598 22.9979 5.0837 22.4704 5.0837C21.9428 5.0837 21.5151 4.65598 21.5151 4.12841V3.55524H20.9419C20.4143 3.55524 19.9866 3.12753 19.9866 2.59995C19.9866 2.07238 20.4143 1.64467 20.9419 1.64467H21.5151V1.0715C21.5151 0.543924 21.9428 0.116211 22.4704 0.116211C22.9979 0.116211 23.4256 0.543924 23.4256 1.0715V1.64467H23.9988C24.5264 1.64467 24.9541 2.07238 24.9541 2.59995C24.9541 3.12753 24.5265 3.55524 23.9988 3.55524Z"
        fill="#3C4CD1" />
      <path
        d="M27.53 7.569L23.9636 9.60694C23.5076 9.86761 22.9232 9.71164 22.6602 9.25151C22.3985 8.79342 22.5576 8.20993 23.0157 7.94812L26.5821 5.91017C27.04 5.64849 27.6236 5.80758 27.8855 6.2656C28.1472 6.72376 27.988 7.30725 27.53 7.569Z"
        fill="#3C4CD1" />
      <path
        d="M29.6047 13.2993C29.5196 13.2993 29.8828 13.3415 25.4091 12.7823C24.8855 12.7169 24.5142 12.2394 24.5797 11.7159C24.6451 11.1923 25.1227 10.8204 25.6461 10.8865L29.722 11.396C30.2455 11.4614 30.6169 11.9389 30.5513 12.4624C30.491 12.9456 30.0795 13.2993 29.6047 13.2993Z"
        fill="#3C4CD1" />
      <path
        d="M8.3946 22.5692C8.65641 22.1111 9.23996 21.9519 9.69799 22.2137C10.156 22.4755 10.3152 23.059 10.0534 23.5171L8.01548 27.0835C7.83913 27.3921 7.51682 27.5651 7.18521 27.5651C6.46435 27.5651 5.989 26.7791 6.35666 26.1356L8.3946 22.5692Z"
        fill="#3C4CD1" />
      <path
        d="M12.1622 24.133C12.6859 24.0673 13.1632 24.439 13.2286 24.9624L13.7381 29.0383C13.8092 29.6067 13.3665 30.1121 12.789 30.1121C12.3143 30.1121 11.9027 29.7585 11.8424 29.2752L11.3329 25.1993C11.2673 24.6759 11.6387 24.1984 12.1622 24.133Z"
        fill="#3C4CD1" />
    </svg>
      Generate
  </button> {% endcomment %}
  <div class="harmony-menu" id="harmonyMenu" style="display: none;">
      <div class="menu-item" data-harmony="Monochromatic">Monochromatic</div>
      <div class="menu-item" data-harmony="Analogous">Analogous</div>
      <div class="menu-item" data-harmony="Complementary">Complementary</div>
      <div class="menu-item" data-harmony="Split Complementary">Split Complementary</div>
      <div class="menu-item" data-harmony="Triadic">Triadic</div>
      <div class="menu-item" data-harmony="Tetradic">Tetradic</div>
      <div class="menu-item" data-harmony="Square">Square</div>
  </div>
</div>

<div class="harmony-menu" id="harmonyMenu" style="display: none;">
  <div class="menu-item" data-harmony="Monochromatic">Monochromatic</div>
  <div class="menu-item" data-harmony="Analogous">Analogous</div>
  <div class="menu-item" data-harmony="Complementary">Complementary</div>
  <div class="menu-item" data-harmony="Split Complementary">Split Complementary</div>
  <div class="menu-item" data-harmony="Triadic">Triadic</div>
  <div class="menu-item" data-harmony="Tetradic">Tetradic</div>
  <div class="menu-item" data-harmony="Square">Square</div>
</div>

  <div id="visualizer_buttons" class="rounded-2 d-flex bg-linear-blue">
      <button type="button" class="btn btn-success4">
        <svg width="22" height="22" viewBox="0 0 33 32" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path
            d="M23.2749 28.3968C22.9097 28.803 22.4518 29.115 21.9402 29.3062C21.4286 29.4974 20.8784 29.5623 20.3363 29.4952H6.07123C3.57168 29.4952 2.50497 28.4285 2.50497 25.929V6.90888C2.50497 4.40932 3.57168 3.34261 6.07123 3.34261H14.3925V6.90888C14.2994 7.71194 14.3892 8.52565 14.655 9.28915C14.9207 10.0526 15.3557 10.7462 15.9274 11.3178C16.499 11.8895 17.1925 12.3244 17.956 12.5902C18.7195 12.856 19.5332 12.9457 20.3363 12.8527H23.9026V16.4189C23.9026 16.7342 24.0278 17.0366 24.2507 17.2595C24.4737 17.4824 24.7761 17.6077 25.0913 17.6077C25.4066 17.6077 25.709 17.4824 25.9319 17.2595C26.1548 17.0366 26.2801 16.7342 26.2801 16.4189V11.6639C26.2802 11.5078 26.2495 11.3532 26.1896 11.2091C26.1298 11.0649 26.042 10.934 25.9314 10.8239L16.4213 1.3138C16.3112 1.20317 16.1803 1.11541 16.0361 1.05557C15.892 0.995725 15.7374 0.96498 15.5813 0.965102H6.07123C5.26818 0.872024 4.45446 0.961736 3.69097 1.22753C2.92748 1.49332 2.23397 1.92831 1.66231 2.49996C1.09066 3.07161 0.655674 3.76512 0.389882 4.52862C0.12409 5.29211 0.0343773 6.10582 0.127455 6.90888V25.929C0.0343773 26.732 0.12409 27.5457 0.389882 28.3092C0.655674 29.0727 1.09066 29.7662 1.66231 30.3379C2.23397 30.9095 2.92748 31.3445 3.69097 31.6103C4.45446 31.8761 5.26818 31.9658 6.07123 31.8728H20.3363C21.2537 31.9506 22.1762 31.8025 23.0231 31.4414C23.87 31.0802 24.6155 30.5171 25.1944 29.8012C25.3806 29.5466 25.4581 29.2285 25.4098 28.9169C25.3615 28.6052 25.1913 28.3255 24.9368 28.1393C24.6823 27.953 24.3642 27.8756 24.0525 27.9239C23.7408 27.9722 23.4611 28.1423 23.2749 28.3968ZM16.77 6.90888V5.02431L22.2209 10.4751H20.3363C17.8367 10.4751 16.77 9.40844 16.77 6.90888ZM32.2714 23.599L29.1014 26.769C28.8761 26.979 28.578 27.0933 28.27 27.0879C27.9621 27.0825 27.6682 26.9577 27.4504 26.7399C27.2326 26.5221 27.1079 26.2283 27.1024 25.9203C27.097 25.6123 27.2113 25.3143 27.4213 25.0889L28.5609 23.9477H17.1663C16.851 23.9477 16.5486 23.8225 16.3257 23.5995C16.1028 23.3766 15.9775 23.0742 15.9775 22.759C15.9775 22.4437 16.1028 22.1413 16.3257 21.9184C16.5486 21.6954 16.851 21.5702 17.1663 21.5702H28.5609L27.4213 20.429C27.2113 20.2036 27.097 19.9056 27.1024 19.5976C27.1079 19.2897 27.2326 18.9958 27.4504 18.778C27.6682 18.5602 27.9621 18.4355 28.27 18.43C28.578 18.4246 28.8761 18.5389 29.1014 18.7489L32.2714 21.9189C32.3809 22.0302 32.4681 22.1615 32.5282 22.3056C32.6179 22.5227 32.6415 22.7615 32.5958 22.992C32.5501 23.2224 32.4372 23.4326 32.2714 23.599Z"
            fill="white" />
        </svg>
      </button>

  </div>
  <div class="control-buttons">
  {% comment %} <button 
    id="editLayerBtn" 
    class="rounded-2 btn btn-success4 bg-linear-blue"
    onclick="editLayer(1)"
  >
    <i style="font-size: 18px; color: #ffffff" class="fa fa-edit"></i> 
  </button> {% endcomment %}
  {% comment %} <button 
    id="resetLayerBtn" 
    class="rounded-2 btn btn-success4 bg-linear-blue"
    onclick="resetLayer(1)"
  >
  <i style="font-size: 18px; color: #ffffff;" class="fa fa-refresh"></i>
  </button> {% endcomment %}
</div>


<script>
// Fullscreen toggle functionality
document.addEventListener('DOMContentLoaded', function() {
    const fullscreenBtn = document.getElementById('fullscreenToggle');
    let isFullscreen = false;

    // Check if already in fullscreen mode
    function updateFullscreenState() {
        isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || 
                         document.mozFullScreenElement || document.msFullscreenElement);
        
        // Update button icon based on state
        const svg = fullscreenBtn.querySelector('svg');
        if (isFullscreen) {
            // Exit fullscreen icon (compress)
            svg.innerHTML = '<path d="M8 3V5M8 3H6M8 3L6 5M16 3V5M16 3H18M16 3L18 5M8 21V19M8 21H6M8 21L6 19M16 21V19M16 21H18M16 21L18 19" stroke="#3C4CD1" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>';
            fullscreenBtn.title = "Exit Fullscreen (F11)";
        } else {
            // Enter fullscreen icon (expand)
            svg.innerHTML = '<path d="M3 3V9M3 3H9M3 3L9 9M21 3V9M21 3H15M21 3L15 9M3 21V15M3 21H9M3 21L9 15M21 21V15M21 21H15M21 21L15 15" stroke="#3C4CD1" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>';
            fullscreenBtn.title = "Toggle Fullscreen (F11)";
        }
    }

    // Toggle fullscreen function
    function toggleFullscreen() {
        if (!isFullscreen) {
            // Enter fullscreen
            if (document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen();
            } else if (document.documentElement.webkitRequestFullscreen) {
                document.documentElement.webkitRequestFullscreen();
            } else if (document.documentElement.mozRequestFullScreen) {
                document.documentElement.mozRequestFullScreen();
            } else if (document.documentElement.msRequestFullscreen) {
                document.documentElement.msRequestFullscreen();
            }
        } else {
            // Exit fullscreen
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
        }
    }

    // Event listeners
    fullscreenBtn.addEventListener('click', toggleFullscreen);

    // Listen for fullscreen changes
    document.addEventListener('fullscreenchange', updateFullscreenState);
    document.addEventListener('webkitfullscreenchange', updateFullscreenState);
    document.addEventListener('mozfullscreenchange', updateFullscreenState);
    document.addEventListener('MSFullscreenChange', updateFullscreenState);

    // Listen for F11 key
    document.addEventListener('keydown', function(e) {
        if (e.key === 'F11') {
            e.preventDefault();
            toggleFullscreen();
        }
    });

    // Initialize state
    updateFullscreenState();
});
</script>
</footer>

<style>
.upload-wrapper {
  position: relative;
  display: inline-block;
  line-height: 0;
}
#fileInput {
  display: none;
}
#uploadForm {
  margin: 0 !important;
  padding: 0 !important;
  display: inline-block;
  line-height: 0;
}
button {
  margin: 0 !important;
  line-height: 1;
}
</style>

<script>
document.getElementById('fileInput').onchange = function() {
  if (this.files.length > 0) {
      document.getElementById('uploadForm').submit();
  }
};
</script>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script>

      </script>
    <script>


      document.addEventListener('DOMContentLoaded', function() {
        const trendingButton = document.getElementById('trendingButton');
        const secondaryColumn = document.getElementById('secondaryColumn');
    
        // Initially hide the secondary column
        secondaryColumn.style.display = 'none';
    
        trendingButton.addEventListener('click', function(e) {
            e.preventDefault();
            
            // Toggle the secondary column
            if (secondaryColumn.style.display === 'none') {
                secondaryColumn.style.display = 'flex';
                // If the sidebar is collapsed, uncollapse it
                if (secondaryColumn.classList.contains('collapsed')) {
                    const toggleButton = secondaryColumn.querySelector('button');
                    toggleSidebar('secondaryColumn', toggleButton);
                }
            } else {
                secondaryColumn.style.display = 'none';
            }
        });
    });


      // Function to toggle sidebar collapsed state and change the icon
      function toggleSidebar(id, button) {
        const sidebar = document.getElementById(id);
        const icon = button.querySelector("i");
        const mostLeftUl = sidebar.querySelectorAll(
          ".mostLeftUl li a .textSpan"
        );
        mostLeftUl.forEach((span) => {
          if (span.style.display === "none") {
            span.style.display = "inline"; // Show the span
          } else {
            span.style.display = "none"; // Hide the span
          }
        });

        sidebar.classList.toggle("collapsed");

        // Update the icon based on the collapse state
        if (sidebar.classList.contains("collapsed")) {

          icon.classList.remove("bi-caret-left-fill", "bi-caret-right-fill");
          icon.classList.add("bi-caret-right-fill");
          //mostLeftUl.style.display = "none";
        } else {

          icon.classList.remove("bi-caret-left-fill", "bi-caret-right-fill");
          icon.classList.add("bi-caret-left-fill");
          //mostLeftUl.style.display = "inline";
        }
      }
      function hideModal(){
        $('#colorPickerModal').modal('hide');
      }


      document.addEventListener('DOMContentLoaded', function() {
        const secondaryColumn = document.getElementById('secondaryColumn');
        const navButtons = document.querySelectorAll('.mostLeftUl li a');
        const inspirationButton = document.getElementById('inspirationButton');
    const contents = {
        trendingContent: document.getElementById('trendingContent'),
        inspirationContent: document.getElementById('inspirationContent'),
        ssCollectionContent: document.getElementById('ssCollectionContent'),
        awCollectionContent: document.getElementById('awCollectionContent'),
        baseColorContent: document.getElementById('baseColorContent'),
        effectsContent: document.getElementById('effectsContent'),
        favCollectionContent: document.getElementById('favCollectionContent'),
        mockupsContent: document.getElementById('mockupsContent'),
        harmonyContent: document.getElementById('harmonyContent'),
        paletteGeneratorContent: document.getElementById('paletteGeneratorContent')
    };
    
        // Function to show content
        function showContent(contentId) {
            // Hide all content sections
            Object.values(contents).forEach(content => {
                if (content) content.style.display = 'none';
            });
            
            // Show the selected content
            const selectedContent = document.getElementById(contentId);
            if (selectedContent) selectedContent.style.display = 'block';
        }
    
        // Function to handle active state
        function setActiveButton(activeButton) {
            navButtons.forEach(button => {
                button.classList.remove('active');
            });
            activeButton.classList.add('active');
        }
    
        // Effect application logic
        const effectItems = document.querySelectorAll('.effect-item');
        effectItems.forEach(item => {
            item.addEventListener('click', function() {
                const effect = this.dataset.effect;
                applyEffectToLayers(effect);
            });
        });
    
        // Initialize base colors
        generateBaseColors();
    
        // Add click handlers for all navigation buttons
    navButtons.forEach(button => {
        button.addEventListener('click', function(e) {
            e.preventDefault();
            setActiveButton(this);
            
            // Updated contentMap to include ALL menu items
            const contentMap = {
                'trendingButton': 'trendingContent',
                'inspirationButton': 'inspirationContent',
                'effectsButton': 'effectsContent',
                'ssCollectionButton': 'ssCollectionContent',
                'awCollectionButton': 'awCollectionContent',
                'baseColorButton': 'baseColorContent',
                'favoriteButton': 'favCollectionContent',
                'mockupsButton': 'mockupsContent',
                'harmonyButton': 'harmonyContent',
                'paletteGeneratorButton': 'paletteGeneratorContent'
            };

            const contentId = contentMap[this.id];
            
            if (contentId) {
                secondaryColumn.style.display = 'flex';
                showContent(contentId);
                
                // Special handling for specific content types
                if (this.id === 'baseColorButton') {
                    const basePalettesSection = document.querySelector('.base-palettes-section');
                    if (basePalettesSection) {
                        basePalettesSection.style.display = selectedBaseColor ? 'block' : 'none';
                    }
                }
                
                // Special handling for palette generator
                if (this.id === 'paletteGeneratorButton') {
                    initializePaletteGenerator();
                }
                
                // Special handling for harmony
                if (this.id === 'harmonyButton') {
                    // Initialize harmony functionality if needed
                    console.log('Harmony section opened');
                }
                
            } else {
                // If no content is mapped, hide secondary column
                secondaryColumn.style.display = 'none';
            }
            
            // If the sidebar is collapsed, uncollapse it
            if (secondaryColumn.classList.contains('collapsed')) {
                const toggleButton = secondaryColumn.querySelector('button');
                toggleSidebar('secondaryColumn', toggleButton);
            }
        });
    });
    
        // Set initial state
        window.onload = function() {
            // Show Inspiration content by default
            secondaryColumn.style.display = 'flex';
            showContent('inspirationContent');
            setActiveButton(inspirationButton);
        };
    });
    const layerStates = {
      editedImages: {},
      originalImages: {},
      currentStates: {}, // Add this to track current states
      history: {}, // Add this to track state history
      maxHistoryLength: 10, // Maximum number of states to keep in history
  
      saveEditedState: function(layerIndex) {
          const canvas = document.getElementById(`layer_canvas_${layerIndex}`);
          if (canvas) {
              const dataUrl = canvas.toDataURL();
              this.editedImages[layerIndex] = dataUrl;
              
              // Add to history
              if (!this.history[layerIndex]) {
                  this.history[layerIndex] = [];
              }
              
              this.history[layerIndex].push(dataUrl);
              
              // Keep history within size limit
              if (this.history[layerIndex].length > this.maxHistoryLength) {
                  this.history[layerIndex].shift();
              }
              
              // Update current state
              this.currentStates[layerIndex] = dataUrl;
          }
      },
  
      saveOriginalState: function(layerIndex) {
          const canvas = document.getElementById(`layer_canvas_${layerIndex}`);
          if (canvas) {
              const dataUrl = canvas.toDataURL();
              this.originalImages[layerIndex] = dataUrl;
              
              // Initialize history with original state
              this.history[layerIndex] = [dataUrl];
              this.currentStates[layerIndex] = dataUrl;
          }
      },
  
      getEditedState: function(layerIndex) {
          return this.editedImages[layerIndex];
      },
  
      getOriginalState: function(layerIndex) {
          return this.originalImages[layerIndex];
      },
  
      getCurrentState: function(layerIndex) {
          return this.currentStates[layerIndex] || this.originalImages[layerIndex];
      },
  
      hasEditedState: function(layerIndex) {
          return !!this.editedImages[layerIndex];
      },
  
      hasOriginalState: function(layerIndex) {
          return !!this.originalImages[layerIndex];
      },
  
      // New methods for state management
      undoLastChange: function(layerIndex) {
          if (this.history[layerIndex] && this.history[layerIndex].length > 1) {
              this.history[layerIndex].pop(); // Remove current state
              const previousState = this.history[layerIndex][this.history[layerIndex].length - 1];
              this.currentStates[layerIndex] = previousState;
              this.applyState(layerIndex, previousState);
              return true;
          }
          return false;
      },
  
      resetToOriginal: function(layerIndex) {
          if (this.hasOriginalState(layerIndex)) {
              this.history[layerIndex] = [this.originalImages[layerIndex]];
              this.currentStates[layerIndex] = this.originalImages[layerIndex];
              this.applyState(layerIndex, this.originalImages[layerIndex]);
              return true;
          }
          return false;
      },
  
      applyState: function(layerIndex, state) {
          const canvas = document.getElementById(`layer_canvas_${layerIndex}`);
          if (canvas && state) {
              const ctx = canvas.getContext('2d');
              const img = new Image();
              img.onload = function() {
                  ctx.clearRect(0, 0, canvas.width, canvas.height);
                  ctx.drawImage(img, 0, 0);
              };
              img.src = state;
          }
      },
  
      // Method to check if we can undo
      canUndo: function(layerIndex) {
          return this.history[layerIndex] && this.history[layerIndex].length > 1;
      },
  
      // Method to get state history
      getHistory: function(layerIndex) {
          return this.history[layerIndex] || [];
      },
  
      // Method to clear all states for a layer
      clearStates: function(layerIndex) {
          delete this.editedImages[layerIndex];
          delete this.currentStates[layerIndex];
          this.history[layerIndex] = [];
          if (this.originalImages[layerIndex]) {
              this.history[layerIndex] = [this.originalImages[layerIndex]];
              this.currentStates[layerIndex] = this.originalImages[layerIndex];
          }
      },
  
      // Method to save intermediate state
      saveIntermediateState: function(layerIndex) {
          const canvas = document.getElementById(`layer_canvas_${layerIndex}`);
          if (canvas) {
              const dataUrl = canvas.toDataURL();
              if (!this.history[layerIndex]) {
                  this.history[layerIndex] = [];
              }
              this.history[layerIndex].push(dataUrl);
              this.currentStates[layerIndex] = dataUrl;
              
              // Keep history within size limit
              if (this.history[layerIndex].length > this.maxHistoryLength) {
                  this.history[layerIndex].shift();
              }
          }
      },
  
      // Method to restore to a specific state in history
      restoreToState: function(layerIndex, stateIndex) {
          if (this.history[layerIndex] && this.history[layerIndex][stateIndex]) {
              const state = this.history[layerIndex][stateIndex];
              this.currentStates[layerIndex] = state;
              this.applyState(layerIndex, state);
              // Trim history to this point
              this.history[layerIndex] = this.history[layerIndex].slice(0, stateIndex + 1);
              return true;
          }
          return false;
      }
  };





// Function to apply harmony palette
async function applyHarmonyPalette(paletteIndex, paletteCollectionName) {
  try {
    const canvas = document.getElementById('layer_canvas_1');
    if (!canvas) {
      showToast('Canvas not found');
      return;
    }
    
    const ctx = canvas.getContext('2d');
    const palette = window[paletteCollectionName][paletteIndex];
    
    if (!palette) {
      showToast('Palette not found');
      return;
    }
    
    // Create backup in truePaletteColors
    if (!window.truePaletteColors) {
      window.truePaletteColors = {};
    }
    window.truePaletteColors[paletteIndex] = palette;
    
    if (typeof processPallet === 'function') {
      await processPallet(ctx, 1, canvas, 0, null, "true", paletteIndex, true);
      showToast(`Applied harmony palette ${paletteIndex}`);
    } else {
      showToast('Error: processPallet function not available');
    }
  } catch (error) {
    console.error('Error applying harmony palette:', error);
    showToast(`Error applying palette: ${error.message}`);
  }
}

// Function to regenerate a specific harmony palette
async function regenerateHarmonyPalette(paletteIndex, harmonyType) {
  try {
    const canvas = document.getElementById('layer_canvas_1');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    
    // Regenerate just this palette
    showToast('Regenerating palette...');
    
    // This would need to be implemented to regenerate a single palette
    // For now, regenerate all palettes
    await processHarmony(ctx, 1, canvas, 0, harmonyType, true);
    
  } catch (error) {
    console.error('Error regenerating harmony palette:', error);
    showToast('Error regenerating palette');
  }
}

// Function to apply harmony palette
async function applyHarmonyPalette(paletteIndex, paletteCollectionName) {
  try {
    const canvas = document.getElementById('layer_canvas_1');
    if (!canvas) {
      showToast('Canvas not found');
      return;
    }
    
    const ctx = canvas.getContext('2d');
    const palette = window[paletteCollectionName][paletteIndex];
    
    if (!palette) {
      showToast('Palette not found');
      return;
    }
    
    // Create backup in truePaletteColors
    if (!window.truePaletteColors) {
      window.truePaletteColors = {};
    }
    window.truePaletteColors[paletteIndex] = palette;
    
    if (typeof processPallet === 'function') {
      await processPallet(ctx, 1, canvas, 0, null, "true", paletteIndex, true);
      showToast(`Applied harmony palette ${paletteIndex}`);
    } else {
      showToast('Error: processPallet function not available');
    }
  } catch (error) {
    console.error('Error applying harmony palette:', error);
    showToast(`Error applying palette: ${error.message}`);
  }
}

// Function to regenerate a specific harmony palette
async function regenerateHarmonyPalette(paletteIndex, harmonyType) {
  try {
    const canvas = document.getElementById('layer_canvas_1');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    
    // Regenerate just this palette
    showToast('Regenerating palette...');
    
    // This would need to be implemented to regenerate a single palette
    // For now, regenerate all palettes
    await processHarmony(ctx, 1, canvas, 0, harmonyType, true);
    
  } catch (error) {
    console.error('Error regenerating harmony palette:', error);
    showToast('Error regenerating palette');
  }
}

{% comment %} effect js  {% endcomment %}

document.addEventListener('DOMContentLoaded', function() {
  // Add effects button handler
  const effectsButton = document.getElementById('effectsButton');
  if (effectsButton) {
      effectsButton.addEventListener('click', function(e) {
          e.preventDefault();
          secondaryColumn.style.display = 'flex';
          showContent('effectsContent');
          if (secondaryColumn.classList.contains('collapsed')) {
              const toggleButton = secondaryColumn.querySelector('button');
              toggleSidebar('secondaryColumn', toggleButton);
          }
      });
  }

  // Effect application logic
  const effectItems = document.querySelectorAll('.effect-item');
  effectItems.forEach(item => {
      item.addEventListener('click', function() {
          const effect = this.dataset.effect;
          applyEffectToLayers(effect);
      });
  });
});

function applyEffectToLayers(effect) {
  const totalLayers = document.querySelectorAll('[id^="layer_canvas_"]').length;
  
  for (let layer = 1; layer <= totalLayers; layer++) {
      const colorButton = document.querySelector(`.color-picker[data-layer-index="${layer-1}"]`);
      if (colorButton && colorButton.dataset.locked === 'true') {
          console.log(`Layer ${layer} is locked, skipping effect`);
          continue;
      }

      const canvas = document.getElementById(`layer_canvas_${layer}`);
      if (!canvas) continue;

      const ctx = canvas.getContext('2d');
      if (!ctx) continue;

      if (!layerStates.hasOriginalState(layer)) {
          layerStates.saveOriginalState(layer);
      }

      switch(effect) {
          case 'grayscale':
              applyGrayscale(ctx, canvas.width, canvas.height);
              break;
          case 'sepia':
              applySepia(ctx, canvas.width, canvas.height);
              break;
          case 'brightness':
              applyBrightness(ctx, canvas.width, canvas.height, 1.5);
              break;
          case 'contrast':
              applyContrast(ctx, canvas.width, canvas.height, 1.5);
              break;
          case 'blur':
              applyBlur(ctx, canvas.width, canvas.height);
              break;
          case 'sharpen':
              applySharpen(ctx, canvas.width, canvas.height);
              break;
          case 'vintage':
              applyVintage(ctx, canvas.width, canvas.height);
              break;
          case 'colorize':
              applyColorize(ctx, canvas.width, canvas.height, '#ff6b6b');
              break;
          case 'duotone':
              applyDuotone(ctx, canvas.width, canvas.height, '#ff6b6b', '#4ecdc4');
              break;
          case 'noise':
              applyNoise(ctx, canvas.width, canvas.height, 20);
              break;
          case 'vignette':
              applyVignette(ctx, canvas.width, canvas.height);
              break;
          case 'posterize':
              applyPosterize(ctx, canvas.width, canvas.height, 4);
              break;
          case 'saturation':
              applySaturation(ctx, canvas.width, canvas.height, 1.5);
              break;
      }

      layerStates.saveEditedState(layer);
  }
}

function applyGrayscale(ctx, width, height) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  
  for (let i = 0; i < data.length; i += 4) {
      const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
      data[i] = avg;     // Red
      data[i + 1] = avg; // Green
      data[i + 2] = avg; // Blue
  }
  
  ctx.putImageData(imageData, 0, 0);
}

function applySepia(ctx, width, height) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  
  for (let i = 0; i < data.length; i += 4) {
      const r = data[i];
      const g = data[i + 1];
      const b = data[i + 2];
      
      data[i] = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189));
      data[i + 1] = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168));
      data[i + 2] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131));
  }
  
  ctx.putImageData(imageData, 0, 0);
}

function applyBrightness(ctx, width, height, factor) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  
  for (let i = 0; i < data.length; i += 4) {
      data[i] = Math.min(255, data[i] * factor);
      data[i + 1] = Math.min(255, data[i + 1] * factor);
      data[i + 2] = Math.min(255, data[i + 2] * factor);
  }
  
  ctx.putImageData(imageData, 0, 0);
}

function applyContrast(ctx, width, height, factor) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  
  for (let i = 0; i < data.length; i += 4) {
      for (let j = 0; j < 3; j++) {
          data[i + j] = ((data[i + j] - 128) * factor) + 128;
      }
  }
  
  ctx.putImageData(imageData, 0, 0);
}

function applyBlur(ctx, width, height) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  const kernel = [
      [1/9, 1/9, 1/9],
      [1/9, 1/9, 1/9],
      [1/9, 1/9, 1/9]
  ];
  
  const result = new Uint8ClampedArray(data.length);
  
  for (let y = 1; y < height - 1; y++) {
      for (let x = 1; x < width - 1; x++) {
          for (let c = 0; c < 3; c++) {
              let sum = 0;
              for (let ky = -1; ky <= 1; ky++) {
                  for (let kx = -1; kx <= 1; kx++) {
                      const idx = ((y + ky) * width + (x + kx)) * 4 + c;
                      sum += data[idx] * kernel[ky + 1][kx + 1];
                  }
              }
              result[(y * width + x) * 4 + c] = sum;
          }
          result[(y * width + x) * 4 + 3] = data[(y * width + x) * 4 + 3];
      }
  }
  
  imageData.data.set(result);
  ctx.putImageData(imageData, 0, 0);
}

function applySharpen(ctx, width, height) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  const kernel = [
      [0, -1, 0],
      [-1, 5, -1],
      [0, -1, 0]
  ];
  
  const result = new Uint8ClampedArray(data.length);
  
  for (let y = 1; y < height - 1; y++) {
      for (let x = 1; x < width - 1; x++) {
          for (let c = 0; c < 3; c++) {
              let sum = 0;
              for (let ky = -1; ky <= 1; ky++) {
                  for (let kx = -1; kx <= 1; kx++) {
                      const idx = ((y + ky) * width + (x + kx)) * 4 + c;
                      sum += data[idx] * kernel[ky + 1][kx + 1];
                  }
              }
              result[(y * width + x) * 4 + c] = Math.min(255, Math.max(0, sum));
          }
          result[(y * width + x) * 4 + 3] = data[(y * width + x) * 4 + 3];
      }
  }
  
  imageData.data.set(result);
  ctx.putImageData(imageData, 0, 0);
}

function applyVintage(ctx, width, height) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  
  for (let i = 0; i < data.length; i += 4) {
      const r = data[i];
      const g = data[i + 1];
      const b = data[i + 2];
      
      data[i] = r * 0.9 + 20;
      data[i + 1] = g * 0.7 + 20;
      data[i + 2] = b * 0.5 + 30;
  }
  
  ctx.putImageData(imageData, 0, 0);
}

function applyColorize(ctx, width, height, color) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  
  // Convert hex color to RGB
  const r = parseInt(color.substr(1,2), 16);
  const g = parseInt(color.substr(3,2), 16);
  const b = parseInt(color.substr(5,2), 16);
  
  for (let i = 0; i < data.length; i += 4) {
      const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
      data[i] = avg * (r / 255);
      data[i + 1] = avg * (g / 255);
      data[i + 2] = avg * (b / 255);
  }
  
  ctx.putImageData(imageData, 0, 0);
}

function applyDuotone(ctx, width, height, color1, color2) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  
  // Convert hex colors to RGB
  const r1 = parseInt(color1.substr(1,2), 16);
  const g1 = parseInt(color1.substr(3,2), 16);
  const b1 = parseInt(color1.substr(5,2), 16);
  
  const r2 = parseInt(color2.substr(1,2), 16);
  const g2 = parseInt(color2.substr(3,2), 16);
  const b2 = parseInt(color2.substr(5,2), 16);
  
  for (let i = 0; i < data.length; i += 4) {
      const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
      const t = avg / 255;
      
      data[i] = r1 + (r2 - r1) * t;
      data[i + 1] = g1 + (g2 - g1) * t;
      data[i + 2] = b1 + (b2 - b1) * t;
  }
  
  ctx.putImageData(imageData, 0, 0);
}

function applyNoise(ctx, width, height, amount) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  
  for (let i = 0; i < data.length; i += 4) {
      const noise = (Math.random() - 0.5) * amount;
      data[i] = Math.min(255, Math.max(0, data[i] + noise));
      data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + noise));
      data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + noise));
  }
  
  ctx.putImageData(imageData, 0, 0);
}

function applyVignette(ctx, width, height) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  const centerX = width / 2;
  const centerY = height / 2;
  const radius = Math.sqrt(centerX * centerX + centerY * centerY);
  
  for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
          const idx = (y * width + x) * 4;
          const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
          const vignette = 1 - Math.pow(distance / radius, 2);
          
          data[idx] *= vignette;
          data[idx + 1] *= vignette;
          data[idx + 2] *= vignette;
      }
  }
  
  ctx.putImageData(imageData, 0, 0);
}

function applyPosterize(ctx, width, height, levels) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  const step = 255 / (levels - 1);
  
  for (let i = 0; i < data.length; i += 4) {
      data[i] = Math.round(data[i] / step) * step;
      data[i + 1] = Math.round(data[i + 1] / step) * step;
      data[i + 2] = Math.round(data[i + 2] / step) * step;
  }
  
  ctx.putImageData(imageData, 0, 0);
}

function applySaturation(ctx, width, height, factor) {
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;
  
  for (let i = 0; i < data.length; i += 4) {
      const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
      data[i] = avg + (data[i] - avg) * factor;
      data[i + 1] = avg + (data[i + 1] - avg) * factor;
      data[i + 2] = avg + (data[i + 2] - avg) * factor;
  }
  
  ctx.putImageData(imageData, 0, 0);
}
{% comment %} effect js end  {% endcomment %}


{% comment %} for pdf {% endcomment %}
// Function to download PDF
function loadInspirationContent() {
  const inspirationContent = document.getElementById('inspirationContent');

  // Show loading state
  inspirationContent.innerHTML = '<div class="text-center"><div class="spinner-border" role="status"></div></div>';

  fetch('inspiration-pdfs/') // Update this URL to match your URL configuration
      .then(response => response.json())
      .then(data => {
          let htmlContent = `
              <h4 class="ms-auto me-auto">Inspirations</h4>
              <div class="inspiration-content">
                  <div class="pdf-grid">
          `;

          data.pdfs.forEach(pdf => {
              htmlContent += `
                  <div class="pdf-item">
                      <div class="pdf-preview" data-pdf-id="${pdf.id}">
                          <img src="${pdf.preview_image}" alt="${pdf.title}">
                          <div class="pdf-info">
                              <span class="pdf-name">${pdf.title}</span>
                              <div class="pdf-actions">
                                  <span class="pdf-likes">
                                      <i class="bi ${pdf.liked ? 'bi-star-fill' : 'bi-star'}"></i> 
                                      <span class="likes-count">${pdf.likes_count}</span>
                                  </span>
                                  <button class="btn btn-sm btn-primary download-btn">
                                      <i class="bi bi-download"></i>
                                  </button>
                              </div>
                          </div>
                      </div>
                  </div>
              `;
          });

          htmlContent += `
                  </div>
              </div>
          `;

          inspirationContent.innerHTML = htmlContent;
          initializePDFEvents(); // Call this after adding the content
      })
      .catch(error => {
          console.error('Error:', error);
          inspirationContent.innerHTML = '<div class="alert alert-danger">Error loading PDFs</div>';
      });
}

function toggleLike(pdfId, element) {
  fetch('inspiration-pdfs/', {
      method: 'POST',
      headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'X-CSRFToken': getCookie('csrftoken'),
      },
      body: `pdf_id=${pdfId}`
  })
  .then(response => response.json())
  .then(data => {
      // Update the like button and count based on the response
      element.className = data.liked ? 'bi bi-star-fill' : 'bi-star';
      element.closest('.pdf-likes').querySelector('.likes-count').textContent = data.likes_count;
  })
  .catch(error => console.error('Error:', error));
}

function getCookie(name) {
  let cookieValue = null;
  if (document.cookie && document.cookie !== '') {
      const cookies = document.cookie.split(';');
      for (let i = 0; i < cookies.length; i++) {
          const cookie = cookies[i].trim();
          if (cookie.substring(0, name.length + 1) === (name + '=')) {
              cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
              break;
          }
      }
  }
  return cookieValue;
}

function downloadPDF(pdfUrl, title) {
  fetch(pdfUrl)
      .then(response => response.blob())
      .then(blob => {
          const url = window.URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = title;
          document.body.appendChild(a);
          a.click();
          window.URL.revokeObjectURL(url);
          document.body.removeChild(a);
      })
      .catch(error => {
          console.error('Error downloading PDF:', error);
          alert('Error downloading the PDF');
      });
}

function initializePDFEvents() {
  document.querySelectorAll('.pdf-likes i').forEach(element => {
      element.addEventListener('click', function(e) {
          e.stopPropagation();
          const pdfId = this.closest('.pdf-preview').dataset.pdfId;
          toggleLike(pdfId, this);
      });
  });

  document.querySelectorAll('.download-btn').forEach(button => {
      button.addEventListener('click', function(e) {
          e.stopPropagation();
          const pdfPreview = this.closest('.pdf-preview');
          const pdfUrl = pdfPreview.dataset.pdfUrl; // Make sure to add this data attribute in your HTML
          const title = pdfPreview.querySelector('.pdf-name').textContent;
          downloadPDF(pdfUrl, title);
      });
  });
}

// Call this function when the page loads
loadInspirationContent();

// Call this function when inspiration button is clicked
document.getElementById('inspirationButton').addEventListener('click', function(e) {
  e.preventDefault();
  loadInspirationContent();
});
{% comment %} end pdf  {% endcomment %}


{% comment %} pallete generator start  {% endcomment %}

let colorCursors = [];
let cursorCount = 3;
let generatedPalettes = [];
let paletteCounter = 0;
let floatingWindow = null;
let previewCanvas = null;

// Initialize palette generator
function initializePaletteGenerator() {
    // Create floating window
    createFloatingWindow();
    
    // Clear any existing cursors
    clearExistingCursors();
    
    // Create initial cursors
    setTimeout(() => {
        createColorCursors();
    }, 100);
    
    // Add event listeners (remove existing listeners first)
    const increaseBtn = document.getElementById('increaseCursors');
    const decreaseBtn = document.getElementById('decreaseCursors');
    const resetBtn = document.getElementById('resetCursors');
    const saveBtn = document.getElementById('savePalette');
    
    // Remove existing listeners
    if (increaseBtn) increaseBtn.replaceWith(increaseBtn.cloneNode(true));
    if (decreaseBtn) decreaseBtn.replaceWith(decreaseBtn.cloneNode(true));
    if (resetBtn) resetBtn.replaceWith(resetBtn.cloneNode(true));
    if (saveBtn) saveBtn.replaceWith(saveBtn.cloneNode(true));
    
    // Add new listeners
    document.getElementById('increaseCursors').addEventListener('click', () => {
        if (cursorCount < 10) {
            addColorCursor();
        }
    });
    
    document.getElementById('decreaseCursors').addEventListener('click', () => {
        if (cursorCount > 1) {
            removeColorCursor();
        }
    });
    
    document.getElementById('resetCursors').addEventListener('click', resetCursorPositions);
    document.getElementById('savePalette').addEventListener('click', generatePalette);
}

// Get canvas dimensions and calculate preview size
function getCanvasDimensions() {
    const canvasLayers = document.querySelectorAll('.layer canvas');
    let sourceCanvas = null;
    
    // Find the first visible canvas
    for (let canvas of canvasLayers) {
        const rect = canvas.getBoundingClientRect();
        if (rect.width > 0 && rect.height > 0) {
            sourceCanvas = canvas;
            break;
        }
    }
    
    if (sourceCanvas) {
        const canvasWidth = sourceCanvas.width;
        const canvasHeight = sourceCanvas.height;
        
        // Calculate preview dimensions with max 720px constraint
        const maxSize = 720;
        let previewWidth, previewHeight;
        
        if (canvasWidth >= canvasHeight) {
            // Width is larger or equal
            if (canvasWidth > maxSize) {
                previewWidth = maxSize;
                previewHeight = Math.round((canvasHeight / canvasWidth) * maxSize);
            } else {
                previewWidth = canvasWidth;
                previewHeight = canvasHeight;
            }
        } else {
            // Height is larger
            if (canvasHeight > maxSize) {
                previewHeight = maxSize;
                previewWidth = Math.round((canvasWidth / canvasHeight) * maxSize);
            } else {
                previewWidth = canvasWidth;
                previewHeight = canvasHeight;
            }
        }
        
        return {
            sourceCanvas,
            previewWidth,
            previewHeight,
            originalWidth: canvasWidth,
            originalHeight: canvasHeight
        };
    }
    
    // Default dimensions if no canvas found
    return {
        sourceCanvas: null,
        previewWidth: 400,
        previewHeight: 400,
        originalWidth: 400,
        originalHeight: 400
    };
}

// Create floating window
function createFloatingWindow() {
    if (floatingWindow) {
        floatingWindow.remove();
    }
    
    const canvasInfo = getCanvasDimensions();
    const windowWidth = canvasInfo.previewWidth + 40; // Add padding
    const windowHeight = canvasInfo.previewHeight + 100; // Add space for header and padding
    
    floatingWindow = document.createElement('div');
    floatingWindow.id = 'paletteFloatingWindow';
    floatingWindow.innerHTML = `
        <div class="floating-window-header">
            <span>Color Picker (${canvasInfo.originalWidth}x${canvasInfo.originalHeight})</span>
            <button class="close-btn" onclick="closeFloatingWindow()">×</button>
        </div>
        <div class="floating-window-content">
            <div class="preview-container" style="width: ${canvasInfo.previewWidth}px; height: ${canvasInfo.previewHeight}px;">
                <canvas id="previewCanvas" width="${canvasInfo.previewWidth}" height="${canvasInfo.previewHeight}"></canvas>
                <div id="cursorsContainer"></div>
            </div>
        </div>
    `;
    
    // Add styles with dynamic dimensions
    const style = document.createElement('style');
    style.textContent = `
        #paletteFloatingWindow {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: ${windowWidth}px;
            height: ${windowHeight}px;
            max-width: 90vw;
            max-height: 90vh;
            background: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            z-index: 10000;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        .floating-window-header {
            background: #f8f9fa;
            padding: 10px 15px;
            border-bottom: 1px solid #ddd;
            border-radius: 6px 6px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            font-size: 14px;
        }
        
        .close-btn {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 25px;
            height: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
        }
        
        .close-btn:hover {
            background: #e9ecef;
        }
        
        .floating-window-content {
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            height: calc(100% - 50px);
            overflow: auto;
        }
        
        .preview-container {
            position: relative;
            border: 1px solid #ccc;
            border-radius: 4px;
            overflow: hidden;
            background: #f8f9fa;
        }
        
        #previewCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        #cursorsContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .color-cursor {
            position: absolute;
            width: 24px;
            height: 24px;
            border: 2px solid #fff;
            border-radius: 50%;
            cursor: move;
            pointer-events: auto;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            z-index: 10;
            transition: transform 0.1s ease;
        }
        
        .color-cursor.dragging {
            transform: scale(1.2);
            box-shadow: 0 4px 16px rgba(0,0,0,0.5);
        }
        
        /* Responsive adjustments for very large previews */
        @media (max-width: 800px) {
            #paletteFloatingWindow {
                width: 95vw !important;
                height: 95vh !important;
            }
            
            .preview-container {
                max-width: calc(95vw - 60px) !important;
                max-height: calc(95vh - 120px) !important;
            }
            
            #previewCanvas {
                max-width: 100% !important;
                max-height: 100% !important;
                object-fit: contain;
            }
        }
    `;
    
    // Remove existing style if any
    const existingStyle = document.getElementById('paletteFloatingWindowStyle');
    if (existingStyle) {
        existingStyle.remove();
    }
    
    style.id = 'paletteFloatingWindowStyle';
    document.head.appendChild(style);
    document.body.appendChild(floatingWindow);
    
    // Create preview canvas
    setTimeout(() => {
        createPreviewCanvas();
    }, 50);
}

// Create preview canvas with current design
function createPreviewCanvas() {
    previewCanvas = document.getElementById('previewCanvas');
    if (!previewCanvas) return;
    
    const ctx = previewCanvas.getContext('2d');
    const canvasInfo = getCanvasDimensions();
    
    if (canvasInfo.sourceCanvas) {
        // Clear the canvas first
        ctx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
        
        // Draw the source canvas onto the preview canvas
        ctx.drawImage(
            canvasInfo.sourceCanvas, 
            0, 0, canvasInfo.originalWidth, canvasInfo.originalHeight,
            0, 0, previewCanvas.width, previewCanvas.height
        );
    } else {
        // Create a default gradient if no canvas is found
        const gradient = ctx.createLinearGradient(0, 0, previewCanvas.width, previewCanvas.height);
        gradient.addColorStop(0, '#ff6b6b');
        gradient.addColorStop(0.25, '#4ecdc4');
        gradient.addColorStop(0.5, '#45b7d1');
        gradient.addColorStop(0.75, '#96ceb4');
        gradient.addColorStop(1, '#ffeaa7');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
    }
}

// Close floating window
function closeFloatingWindow() {
    if (floatingWindow) {
        floatingWindow.remove();
        floatingWindow = null;
        previewCanvas = null;
    }
    
    // Remove the style as well
    const style = document.getElementById('paletteFloatingWindowStyle');
    if (style) {
        style.remove();
    }
    
    clearExistingCursors();
}

// Clear existing cursors
function clearExistingCursors() {
    colorCursors.forEach(cursor => {
        if (cursor && cursor.parentNode) {
            cursor.parentNode.removeChild(cursor);
        }
    });
    colorCursors = [];
}

// Create initial color cursors
function createColorCursors() {
    if (!floatingWindow) return;
    
    clearExistingCursors();
    cursorCount = 3;
    
    for (let i = 0; i < cursorCount; i++) {
        createSingleCursor(i);
    }
    
    updateCursorCountDisplay();
}

// Create a single cursor
function createSingleCursor(index) {
    if (!floatingWindow) return;
    
    const cursorsContainer = document.getElementById('cursorsContainer');
    if (!cursorsContainer) return;
    
    const cursor = document.createElement('div');
    cursor.className = 'color-cursor';
    cursor.id = `colorCursor_${index}`;
    
    // Position cursors in different areas of the preview
    const positions = [
        { x: 0.3, y: 0.3 },   // Top-left area
        { x: 0.7, y: 0.3 },   // Top-right area
        { x: 0.5, y: 0.7 },   // Bottom-center area
        { x: 0.2, y: 0.6 },   // Additional positions
        { x: 0.8, y: 0.6 },
        { x: 0.4, y: 0.5 },
        { x: 0.6, y: 0.8 },
        { x: 0.25, y: 0.8 },
        { x: 0.75, y: 0.4 },
        { x: 0.5, y: 0.5 }
    ];
    
    const position = positions[index % positions.length];
    
    // Get actual container dimensions
    const containerRect = cursorsContainer.getBoundingClientRect();
    const containerWidth = containerRect.width;
    const containerHeight = containerRect.height;
    
    const x = (containerWidth * position.x) - 12;
    const y = (containerHeight * position.y) - 12;
    
    cursor.style.left = x + 'px';
    cursor.style.top = y + 'px';
    
    // Add drag functionality
    addDragFunctionality(cursor);
    
    cursorsContainer.appendChild(cursor);
    colorCursors.push(cursor);
    
    // Initial color sampling
    setTimeout(() => updateCursorColor(cursor), 50);
}

// Perfect drag functionality for floating window
function addDragFunctionality(cursor) {
    let isDragging = false;
    let startX, startY, startLeft, startTop;
    
    cursor.addEventListener('mousedown', (e) => {
        isDragging = true;
        cursor.classList.add('dragging');
        
        // Record starting positions
        startX = e.clientX;
        startY = e.clientY;
        startLeft = parseInt(cursor.style.left) || 0;
        startTop = parseInt(cursor.style.top) || 0;
        
        // Prevent text selection and default behaviors
        e.preventDefault();
        e.stopPropagation();
        document.body.style.userSelect = 'none';
        
        // Add temporary event listeners
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
    });
    
    function handleMouseMove(e) {
        if (!isDragging) return;
        
        // Calculate movement delta
        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;
        
        // Calculate new position
        let newLeft = startLeft + deltaX;
        let newTop = startTop + deltaY;
        
        // Get current container dimensions
        const cursorsContainer = document.getElementById('cursorsContainer');
        const containerRect = cursorsContainer.getBoundingClientRect();
        
        // Apply bounds (within preview container)
        const maxX = containerRect.width - 24;
        const maxY = containerRect.height - 24;
        
        newLeft = Math.max(0, Math.min(newLeft, maxX));
        newTop = Math.max(0, Math.min(newTop, maxY));
        
        // Update cursor position
        cursor.style.left = newLeft + 'px';
        cursor.style.top = newTop + 'px';
        
        // Update color
        updateCursorColor(cursor);
    }
    
    function handleMouseUp() {
        isDragging = false;
        cursor.classList.remove('dragging');
        document.body.style.userSelect = '';
        
        // Remove temporary event listeners
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
    }
}

// Update cursor color based on position in preview canvas
function updateCursorColor(cursor) {
    if (!previewCanvas) return;
    
    const rect = cursor.getBoundingClientRect();
    const previewRect = previewCanvas.getBoundingClientRect();
    
    // Calculate relative position within preview canvas
    const relativeX = rect.left + 12 - previewRect.left;
    const relativeY = rect.top + 12 - previewRect.top;
    
    // Convert to canvas coordinates
    const canvasX = Math.floor((relativeX / previewRect.width) * previewCanvas.width);
    const canvasY = Math.floor((relativeY / previewRect.height) * previewCanvas.height);
    
    // Make sure coordinates are within bounds
    if (canvasX >= 0 && canvasX < previewCanvas.width && canvasY >= 0 && canvasY < previewCanvas.height) {
        try {
            const ctx = previewCanvas.getContext('2d');
            const imageData = ctx.getImageData(canvasX, canvasY, 1, 1);
            const [r, g, b, a] = imageData.data;
            
            if (a > 10) {
                const color = rgbToHex(r, g, b);
                cursor.style.backgroundColor = color;
                cursor.style.borderColor = getContrastBorder(color);
                return;
            }
        } catch (error) {
            console.log('Error sampling color:', error);
        }
    }
    
    // Default color if no valid color found
    cursor.style.backgroundColor = '#808080';
    cursor.style.borderColor = '#ffffff';
}

// Get contrasting border color
function getContrastBorder(color) {
    const hex = color.replace('#', '');
    const r = parseInt(hex.substr(0, 2), 16);
    const g = parseInt(hex.substr(2, 2), 16);
    const b = parseInt(hex.substr(4, 2), 16);
    
    // Calculate brightness
    const brightness = (r * 299 + g * 587 + b * 114) / 1000;
    
    return brightness > 128 ? '#000000' : '#ffffff';
}

// Convert RGB to HEX
function rgbToHex(r, g, b) {
    return "#" + [r, g, b].map(x => {
        const hex = Math.round(x).toString(16);
        return hex.length === 1 ? "0" + hex : hex;
    }).join("");
}

// Add a new cursor
function addColorCursor() {
    if (cursorCount >= 10) return;
    
    createSingleCursor(cursorCount);
    cursorCount++;
    updateCursorCountDisplay();
}

// Remove a cursor
function removeColorCursor() {
    if (cursorCount <= 1) return;
    
    if (colorCursors.length > 0) {
        const lastCursor = colorCursors.pop();
        if (lastCursor && lastCursor.parentNode) {
            lastCursor.parentNode.removeChild(lastCursor);
        }
        cursorCount--;
        updateCursorCountDisplay();
    }
}

// Reset cursor positions
function resetCursorPositions() {
    createColorCursors();
}

// Update cursor count display
function updateCursorCountDisplay() {
    const countElement = document.getElementById('cursorCount');
    if (countElement) {
        countElement.textContent = cursorCount;
    }
}

// Generate palette from current cursor colors
function generatePalette() {
    if (colorCursors.length === 0) {
        alert('No color cursors found. Please reset the cursors.');
        return;
    }
    
    const colors = [];
    
    colorCursors.forEach(cursor => {
        // Force update color before generating palette
        updateCursorColor(cursor);
        const color = cursor.style.backgroundColor;
        
        if (color && color !== 'rgb(128, 128, 128)') {
            // Convert RGB to HEX if needed
            if (color.startsWith('rgb')) {
                const rgb = color.match(/\d+/g);
                if (rgb && rgb.length >= 3) {
                    colors.push(rgbToHex(parseInt(rgb[0]), parseInt(rgb[1]), parseInt(rgb[2])));
                }
            } else {
                colors.push(color);
            }
        } else {
            // Use a default color if sampling failed
            colors.push('#808080');
        }
    });
    
    if (colors.length === 0) {
        alert('No colors could be sampled. Please move cursors over colored areas.');
        return;
    }
    
    paletteCounter++;
    const palette = {
        id: paletteCounter,
        colors: colors,
        timestamp: new Date()
    };
    
    generatedPalettes.push(palette);
    displayGeneratedPalette(palette);
}

// Display generated palette horizontally
function displayGeneratedPalette(palette) {
    const container = document.getElementById('generatedPalettesDisplay');
    
    const paletteDiv = document.createElement('div');
    paletteDiv.className = 'generated-palette-item';
    paletteDiv.innerHTML = `
        <div class="horizontal-palette">
            ${palette.colors.map(color => `
                <div class="horizontal-color-strip" style="background-color: ${color};">
                    <div class="color-hex-display">${color.toUpperCase()}</div>
                </div>
            `).join('')}
        </div>
        <div class="palette-actions">
           
            <button class="btn btn-sm btn-outline-danger" onclick="deleteGeneratedPalette(${palette.id})" title="Delete palette">
                <i class="bi bi-trash"></i>
            </button>
          
            <button class="btn btn-sm btn-info" onclick="copyPaletteColors(${palette.id})" title="Copy colors">
                <i class="bi bi-clipboard"></i>
            </button>
        </div>
    `;
    
    container.appendChild(paletteDiv);
    
    // Scroll to the new palette
    paletteDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
}

// Apply generated palette
function applyGeneratedPalette(paletteId) {
    const palette = generatedPalettes.find(p => p.id === paletteId);
    if (palette) {
        console.log('Applying palette:', palette.colors);
        // You can integrate this with your existing applyPaletteToLayers function
        // applyPaletteToLayers(palette.colors);
    }
}

// Shuffle generated palette
function shuffleGeneratedPalette(paletteId) {
    const palette = generatedPalettes.find(p => p.id === paletteId);
    if (palette) {
        // Shuffle the colors array
        for (let i = palette.colors.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [palette.colors[i], palette.colors[j]] = [palette.colors[j], palette.colors[i]];
        }
        
        // Re-render all palettes
        refreshPaletteDisplay();
    }
}

// Delete generated palette
function deleteGeneratedPalette(paletteId) {
    const index = generatedPalettes.findIndex(p => p.id === paletteId);
    if (index > -1) {
        generatedPalettes.splice(index, 1);
        refreshPaletteDisplay();
    }
}

// Copy palette colors to clipboard
function copyPaletteColors(paletteId) {
    const palette = generatedPalettes.find(p => p.id === paletteId);
    if (palette) {
        const colorString = palette.colors.join(', ');
        navigator.clipboard.writeText(colorString).then(() => {
            console.log('Colors copied to clipboard:', colorString);
            // You can add a visual feedback here
        }).catch(err => {
            console.log('Failed to copy colors:', err);
        });
    }
}

// Refresh palette display
function refreshPaletteDisplay() {
    const container = document.getElementById('generatedPalettesDisplay');
    container.innerHTML = '';
    generatedPalettes.forEach(palette => displayGeneratedPalette(palette));
}
{% comment %} pallete generator end  {% endcomment %}

{% comment %} for base color  {% endcomment %}


// Function to convert RGB to HSV
function rgbToHsvBase(r, g, b) {
  r = r / 255;
  g = g / 255;
  b = b / 255;
  
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const diff = max - min;
  
  let h = 0;
  let s = max === 0 ? 0 : diff / max;
  let v = max;
  
  if (max === min) {
      h = 0;
  } else if (max === r) {
      h = (60 * ((g - b) / diff) + 360) % 360;
  } else if (max === g) {
      h = (60 * ((b - r) / diff) + 120) % 360;
  } else {
      h = (60 * ((r - g) / diff) + 240) % 360;
  }
  
  return [h, s, v];
}

function getColorName(rgb) {
  const [r, g, b] = rgb;
  
  function getHueName(h) {
      if (h < 15 || h >= 345) return "Red";
      if (h >= 15 && h < 45) return "Orange";
      if (h >= 45 && h < 75) return "Yellow";
      if (h >= 75 && h < 165) return "Green";
      if (h >= 165 && h < 195) return "Cyan";
      if (h >= 195 && h < 255) return "Blue";
      if (h >= 255 && h < 285) return "Purple";
      if (h >= 285 && h < 345) return "Pink";
  }

  function getShadePrefix(s, v) {
      if (v < 0.2) return "Dark";
      if (v > 0.8) return "Light";
      if (s < 0.2) return "Gray";
      if (s > 0.8) return "Vivid";
      return "";
  }

  // Convert RGB to HSV
  const rNorm = r / 255;
  const gNorm = g / 255;
  const bNorm = b / 255;
  const max = Math.max(rNorm, gNorm, bNorm);
  const min = Math.min(rNorm, gNorm, bNorm);
  const diff = max - min;

  // Calculate Hue
  let h = 0;
  if (max !== min) {
      if (max === rNorm) {
          h = (60 * ((gNorm - bNorm) / diff) + 360) % 360;
      } else if (max === gNorm) {
          h = (60 * ((bNorm - rNorm) / diff) + 120) % 360;
      } else {
          h = (60 * ((rNorm - gNorm) / diff) + 240) % 360;
      }
  }

  // Calculate Saturation
  const s = max === 0 ? 0 : diff / max;

  // Value
  const v = max;

  // Special cases for grayscale
  if (s < 0.1) {
      if (v < 0.2) return "Black";
      if (v < 0.4) return "Dark Gray";
      if (v < 0.6) return "Gray";
      if (v < 0.8) return "Light Gray";
      return "White";
  }

  const hueName = getHueName(h);
  const shadePrefix = getShadePrefix(s, v);

  return shadePrefix ? `${shadePrefix} ${hueName}` : hueName;
}

const style = document.createElement('style');
style.textContent = `
.base-colors-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 10px;
  padding: 15px;
}

.base-color-block {
  {% comment %} aspect-ratio: 3/1; {% endcomment %}
  border-radius: 8px;
  cursor: pointer;
  transition: transform 0.2s;
  border: 1px solid #ddd;
  position: relative;
  display: flex;
  align-items: center;
  padding: 10px;
  height: 8rem
}

.base-color-block:hover {
  transform: scale(1.02);
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.color-name {
  color: white;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
  font-size: 14px;
  font-weight: bold;
}

.base-palettes-section {
  margin-top: 20px;
  display: none;
}
`;
document.head.appendChild(style);

// Simplified background color selection function
function showBackgroundColorSelector(baseColor, originalColors) {
  // Create a simplified modal container
  const modalOverlay = document.createElement('div');
  modalOverlay.className = 'bg-selector-overlay';
  modalOverlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 9999;
  `;
  
  // Create modal content - improved responsiveness
  const modalContent = document.createElement('div');
  modalContent.className = 'bg-selector-content';
  modalContent.style.cssText = `
    background-color: white;
    border-radius: 8px;
    padding: 20px;
    max-width: 90%;
    width: 500px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.3);
    max-height: 90vh;
    overflow-y: auto;
  `;
  
  // Add header
  const header = document.createElement('div');
  header.style.cssText = `
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
  `;
  
  const title = document.createElement('h3');
  title.textContent = 'Select Background Color';
  title.style.cssText = `
    margin: 0;
    font-size: calc(1rem + 0.5vw);
  `;
  
  const closeButton = document.createElement('button');
  closeButton.innerHTML = '&times;';
  closeButton.style.cssText = `
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
    padding: 0 8px;
  `;
  
  header.appendChild(title);
  header.appendChild(closeButton);
  modalContent.appendChild(header);
  
  // Add description
  const description = document.createElement('p');
  description.textContent = 'Choose which color from your image should be treated as the background color:';
  description.style.cssText = `
    margin-bottom: 15px;
    font-size: 0.95rem;
  `;
  modalContent.appendChild(description);
  
  // Colors container - improved for mobile
  const colorsContainer = document.createElement('div');
  colorsContainer.style.cssText = `
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
    gap: 10px;
    justify-content: center;
    margin: 15px 0;
  `;
  
  // Add color swatches
  let selectedIndex = 0; // Default to first color
  
  originalColors.forEach((color, index) => {
    const colorSwatch = document.createElement('div');
    colorSwatch.style.cssText = `
      width: 100%;
      aspect-ratio: 1;
      background-color: rgb(${color.join(',')});
      border: ${index === 0 ? '3px solid #007bff' : '2px solid #ddd'};
      border-radius: 4px;
      cursor: pointer;
      transition: transform 0.2s, border 0.2s;
      position: relative;
    `;
    
    // Add index label
    const indexLabel = document.createElement('div');
    indexLabel.textContent = index + 1;
    indexLabel.style.cssText = `
      position: absolute;
      bottom: -8px;
      right: -8px;
      background-color: #333;
      color: white;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
    `;
    colorSwatch.appendChild(indexLabel);
    
    // Add class for identifying swatches
    colorSwatch.className = 'bg-color-swatch';
    colorSwatch.dataset.index = index;
    
    // If this is the first color, mark as selected
    if (index === 0) {
      colorSwatch.classList.add('selected-bg');
    }
    
    // Add click handler
    colorSwatch.addEventListener('click', () => {
      // Update selected index
      selectedIndex = index;
      
      // Update visual styling
      document.querySelectorAll('.bg-color-swatch').forEach(swatch => {
        swatch.style.border = '2px solid #ddd';
        swatch.classList.remove('selected-bg');
        swatch.style.transform = 'scale(1)';
      });
      
      colorSwatch.style.border = '3px solid #007bff';
      colorSwatch.classList.add('selected-bg');
      colorSwatch.style.transform = 'scale(1.05)';
    });
    
    colorsContainer.appendChild(colorSwatch);
  });
  
  modalContent.appendChild(colorsContainer);
  
  // Buttons container - improved for mobile
  const buttonsContainer = document.createElement('div');
  buttonsContainer.style.cssText = `
    display: flex;
    justify-content: space-between;
    margin-top: 20px;
    gap: 10px;
  `;
  
  // Cancel button
  const cancelButton = document.createElement('button');
  cancelButton.textContent = 'Cancel';
  cancelButton.style.cssText = `
    padding: 8px 16px;
    border: 1px solid #ddd;
    background-color: white;
    border-radius: 4px;
    cursor: pointer;
    flex: 1;
    min-height: 44px;
  `;
  
  // Confirm button
  const confirmButton = document.createElement('button');
  confirmButton.textContent = 'Apply';
  confirmButton.style.cssText = `
    padding: 8px 16px;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    flex: 1;
    min-height: 44px;
  `;
  
  buttonsContainer.appendChild(cancelButton);
  buttonsContainer.appendChild(confirmButton);
  modalContent.appendChild(buttonsContainer);
  
  // Add modal to page
  modalOverlay.appendChild(modalContent);
  document.body.appendChild(modalOverlay);
  
  // Return a promise that resolves when the user makes a selection
  return new Promise((resolve, reject) => {
    // Handle close button
    closeButton.addEventListener('click', () => {
      document.body.removeChild(modalOverlay);
      resolve(0); // Default to first color if closed
    });
    
    // Handle cancel button
    cancelButton.addEventListener('click', () => {
      document.body.removeChild(modalOverlay);
      resolve(0); // Default to first color if canceled
    });
    
    // Handle confirm button
    confirmButton.addEventListener('click', () => {
      document.body.removeChild(modalOverlay);
      resolve(selectedIndex);
    });
    
    // Handle clicking outside the modal
    modalOverlay.addEventListener('click', (e) => {
      if (e.target === modalOverlay) {
        document.body.removeChild(modalOverlay);
        resolve(0); // Default to first color if clicked outside
      }
    });
  });
}

 // Modified selectBaseColor function
// Add this style block to your CSS to make the grid of palettes look better
const paletteGridStyles = document.createElement('style');
paletteGridStyles.textContent = `
  .base-palettes-section .layer-toggles {
    display: grid !important;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)) !important;
    gap: 15px !important;
    justify-content: start !important;
    width: 100%;
  }
  
  .layer-toggle-item {
    width: 100%;
    margin-bottom: 15px;
  }
  
  .color-palette {
    width: 100%;
    min-height: 220px;
  }
  
  /* Make the palette container take full width within its grid cell */
  .palette-clickable-container {
    width: 100%;
    margin: 0 auto;
  }
  
  /* Make the preview container expand to fit width */
  .palette-preview-container {
    width: 100%;
    height: 200px;
  }
  
  /* Ensure palette number always visible */
  .palette-number {
    z-index: 5;
    background-color: rgba(0,0,0,0.7);
    font-weight: bold;
  }
  
  /* Add some extra breathing room */
  .base-palettes-section {
    margin-bottom: 40px;
  }
`;
document.head.appendChild(paletteGridStyles);


async function generatePreview(previewCanvas, paletteColors, paletteIndex) {
      try {
        // Mark the container as not ready (ensure loading indicator shows)
        const container = previewCanvas.closest('.palette-clickable-container');
        if (container) {
          container.classList.remove('preview-ready');
        }
        
        // Check cache first - expanded cache check
        if (window.palettePreviewCache && 
            window.palettePreviewCache['base'] && 
            window.palettePreviewCache['base'][paletteIndex]) {
            
            // Use cached preview
            const cachedPreview = window.palettePreviewCache['base'][paletteIndex];
            const ctx = previewCanvas.getContext('2d', { willReadFrequently: true });
            
            // Clear with white background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
            
            return new Promise((resolve) => {
              const img = new Image();
              img.onload = () => {
                // Calculate proportional dimensions to maintain aspect ratio
                const scale = Math.min(
                    previewCanvas.width / img.width,
                    previewCanvas.height / img.height
                );
                
                const scaledWidth = img.width * scale;
                const scaledHeight = img.height * scale;
                
                // Center the image
                const x = (previewCanvas.width - scaledWidth) / 2;
                const y = (previewCanvas.height - scaledHeight) / 2;
                
                // Draw the image with proper aspect ratio
                ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
                
                // Mark preview as ready to hide the loading indicator
                if (container) {
                  container.classList.add('preview-ready');
                }
                resolve();
              };
              img.onerror = () => {
                // Draw fallback and mark as ready
                drawFallbackPreview(previewCanvas);
                if (container) {
                  container.classList.add('preview-ready');
                }
                resolve();
              };
              img.src = cachedPreview;
            });
        }
            
            // No cache, create new preview
            // Get the original image
            const originalCanvas = document.getElementById('layer_canvas_1');
            
            if (!originalCanvas) {
              console.error('No original canvas found for preview');
              drawFallbackPreview(previewCanvas);
              if (container) {
                container.classList.add('preview-ready');
              }
              return;
            }
            
            // Clear the preview canvas with white background
            const ctx = previewCanvas.getContext('2d', { willReadFrequently: true });
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
            
            // Calculate dimensions that maintain aspect ratio
            const originalAspect = originalCanvas.width / originalCanvas.height;
            let previewWidth, previewHeight, offsetX = 0, offsetY = 0;
            
            if (originalAspect > 1) {
              // Image is wider than tall
              previewWidth = previewCanvas.width;
              previewHeight = previewWidth / originalAspect;
              offsetY = (previewCanvas.height - previewHeight) / 2;
            } else {
              // Image is taller than wide
              previewHeight = previewCanvas.height;
              previewWidth = previewHeight * originalAspect;
              offsetX = (previewCanvas.width - previewWidth) / 2;
            }
            
            // Create a temporary canvas for the original image at preview size
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = previewWidth;
            tempCanvas.height = previewHeight;
            const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
            
            // Draw original image to temp canvas maintaining aspect ratio
            tempCtx.drawImage(originalCanvas, 0, 0, previewWidth, previewHeight);
            
            // Now get the temp canvas data for processing
            const imageData = tempCtx.getImageData(0, 0, previewWidth, previewHeight);
            
            // Find original colors from the image
            const originalColors = await getDistinctColors(imageData, 30, 50);
            
            if (!originalColors || originalColors.length === 0) {
              console.error('No original colors found for preview');
              // Still draw the original image with correct aspect ratio
              ctx.drawImage(tempCanvas, offsetX, offsetY);
              
              // Mark preview as ready
              if (container) {
                container.classList.add('preview-ready');
              }
              return;
            }
            
            // Create color mappings
            const colorMappings = [];
            
            // Special handling for background color
            if (backgroundColorIndex !== null && 
                backgroundColorIndex >= 0 && 
                backgroundColorIndex < originalColors.length) {
                
                // Map colors with special consideration for the background color
                for (let i = 0; i < originalColors.length; i++) {
                    if (i === backgroundColorIndex) {
                        // For the background color index, map to the selected base color (first in palette)
                        colorMappings.push({
                            originalColor: originalColors[i],
                            targetColor: paletteColors[0]
                        });
                    } else {
                        // For other colors, map to rest of palette
                        const targetIndex = (i < backgroundColorIndex) ? i + 1 : i;
                        const paletteIndex = targetIndex % paletteColors.length;
                        
                        colorMappings.push({
                            originalColor: originalColors[i],
                            targetColor: paletteColors[paletteIndex]
                        });
                    }
                }
            } else {
                // Regular mapping if no background color is specified
                for (let i = 0; i < Math.min(originalColors.length, paletteColors.length); i++) {
                    colorMappings.push({
                        originalColor: originalColors[i],
                        targetColor: paletteColors[i % paletteColors.length]
                    });
                }
            }
            
            // Use a simplified processor for the preview
            const colorProcessor = new ColorProcessor();
            const imageUrl = tempCanvas.toDataURL();
            
            // Process the preview
            const processedImageUrl = await colorProcessor.applyMultipleColorMappings(
                imageUrl,
                colorMappings
            );
            
            // Load the processed image back to the preview canvas
            return new Promise((resolve) => {
              const resultImg = new Image();
              resultImg.onload = () => {
                // Draw the processed image with the correct positioning
                ctx.drawImage(resultImg, offsetX, offsetY, previewWidth, previewHeight);
                
                // Cache the generated preview
                if (!window.palettePreviewCache) {
                    window.palettePreviewCache = {};
                }
                if (!window.palettePreviewCache['base']) {
                    window.palettePreviewCache['base'] = {};
                }
                window.palettePreviewCache['base'][paletteIndex] = previewCanvas.toDataURL();
                
                // Mark preview as ready to hide loading indicator
                if (container) {
                  container.classList.add('preview-ready');
                }
                resolve();
              };
              resultImg.onerror = () => {
                console.error("Error loading processed preview");
                drawFallbackPreview(previewCanvas);
                if (container) {
                  container.classList.add('preview-ready');
                }
                resolve();
              };
              resultImg.src = processedImageUrl;
            });
            
          } catch (error) {
            console.error("Error generating preview:", error);
            drawFallbackPreview(previewCanvas);
            const container = previewCanvas.closest('.palette-clickable-container');
            if (container) {
              container.classList.add('preview-ready');
            }
          }
        }



function generateBaseColorPalettes(baseColor, backgroundColorIndex = 0) {
  // Conversion utilities remain the same
  function rgbToHex(r, g, b) {
    return '#' + [r, g, b].map(x => {
      const hex = x.toString(16);
      return hex.length === 1 ? '0' + hex : hex;
    }).join('');
  }

  function rgbToHsl(r, g, b) {
    r /= 255;
    g /= 255;
    b /= 255;

    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;

    if (max === min) {
      h = s = 0;
    } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

      switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
      }
      h /= 6;
    }

    return [h * 360, s * 100, l * 100];
  }

  function hslToRgb(h, s, l) {
    h /= 360;
    s /= 100;
    l /= 100;

    let r, g, b;

    if (s === 0) {
      r = g = b = l;
    } else {
      const hue2rgb = (p, q, t) => {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1/6) return p + (q - p) * 6 * t;
        if (t < 1/2) return q;
        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
      };

      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;

      r = hue2rgb(p, q, h + 1/3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1/3);
    }

    return [
      Math.round(r * 255),
      Math.round(g * 255),
      Math.round(b * 255)
    ];
  }

  function randomInRange(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  // Color distance function for perceptual accuracy
  function colorDistance(color1, color2) {
    // Simple RGB distance for efficiency
    return Math.sqrt(
      Math.pow(color1[0] - color2[0], 2) +
      Math.pow(color1[1] - color2[1], 2) +
      Math.pow(color1[2] - color2[2], 2)
    );
  }

  // Get the original colors from various sources
  let distinctColors = [];
  let originalBackgroundColor = null;

  try {
    // Get colors from various sources (unchanged)
    if (window.originalColors && Array.isArray(window.originalColors) && window.originalColors.length > 0) {
      console.log("Using originalColors with background index:", backgroundColorIndex);
      distinctColors = [...window.originalColors];
      
      if (backgroundColorIndex >= 0 && backgroundColorIndex < distinctColors.length) {
        originalBackgroundColor = [...distinctColors[backgroundColorIndex]];
      }
    } 
    else if (localStorage.getItem('distinctColorsArrayColorPallet')) {
      try {
        const storedColorsString = localStorage.getItem('distinctColorsArrayColorPallet');
        const storedColors = JSON.parse(storedColorsString);

        if (Array.isArray(storedColors) && storedColors.length > 0) {
          distinctColors = storedColors.filter(color =>
            Array.isArray(color) &&
            color.length === 3 &&
            color.every(val => typeof val === 'number' && !isNaN(val))
          );
        }
      } catch (parseError) {
        console.error("Error parsing colors from localStorage:", parseError);
      }
    }
    else if (window.distinctColorsArrayColorPallet &&
             Array.isArray(window.distinctColorsArrayColorPallet) &&
             window.distinctColorsArrayColorPallet.length > 0) {

      distinctColors = window.distinctColorsArrayColorPallet.filter(color =>
        Array.isArray(color) &&
        color.length === 3 &&
        color.every(val => typeof val === 'number' && !isNaN(val))
      );
    }

    if (distinctColors.length === 0) {
      distinctColors = [
        [230, 140, 30],  // Orange
        [50, 80, 200],   // Blue
        [60, 180, 70],   // Green
        [240, 220, 40],  // Yellow
        [150, 60, 180],  // Purple
        [255, 0, 255]    // Magenta
      ];
    }
  } catch (e) {
    console.error("Error retrieving distinct colors:", e);
    distinctColors = [
      [230, 140, 30], [50, 80, 200], [60, 180, 70],
      [240, 220, 40], [150, 60, 180], [255, 0, 255]
    ];
  }

  // Get the base color's HSL values
  const baseHsl = rgbToHsl(...baseColor);
  
  try {
    // Get harmony scheme from the parameters or use default
    const harmonyScheme = baseColor.harmonyScheme || 'normal';
    const shadeType = baseColor.shadeType || 'regular';
    
    // STEP 1: Create a version of the selected base color with adjusted shade
    const adjustedBaseColor = [...baseColor]; // Start with the original base color
    
    // Apply shade adjustment to the base color
    if (shadeType === 'faint') {
      // For faint: keep hue, reduce saturation, increase lightness
      const faintHsl = [...baseHsl];
      faintHsl[1] = Math.max(10, baseHsl[1] * 0.8); // Reduce saturation slightly
      faintHsl[2] = Math.min(95, Math.max(70, baseHsl[2] * 1.3)); // Increase lightness
      
      // Only convert if changes were made
      if (faintHsl[1] !== baseHsl[1] || faintHsl[2] !== baseHsl[2]) {
        const rgbColor = hslToRgb(...faintHsl);
        adjustedBaseColor[0] = rgbColor[0];
        adjustedBaseColor[1] = rgbColor[1];
        adjustedBaseColor[2] = rgbColor[2];
      }
    } 
    else if (shadeType === 'dark') {
      // For dark: keep hue, possibly increase saturation, decrease lightness
      const darkHsl = [...baseHsl];
      darkHsl[1] = Math.min(100, baseHsl[1] * 1.1); // Slightly increase saturation
      darkHsl[2] = Math.max(10, Math.min(35, baseHsl[2] * 0.6)); // Decrease lightness
      
      // Only convert if changes were made
      if (darkHsl[1] !== baseHsl[1] || darkHsl[2] !== baseHsl[2]) {
        const rgbColor = hslToRgb(...darkHsl);
        adjustedBaseColor[0] = rgbColor[0];
        adjustedBaseColor[1] = rgbColor[1];
        adjustedBaseColor[2] = rgbColor[2];
      }
    }
    // For 'regular', we keep the color as is
    
    // STEP 2: Create palettes based on the adjusted base color
    const basePalettes = [];
    const paletteCount = 12; // Generate 12 palettes for each combination

    // Get standard harmony angles for precise color theory implementation
    function getHarmonyAngles(harmonyType) {
      switch(harmonyType) {
        case 'monochromatic': return [0]; // Same hue
        case 'analogous': return [-30, -15, 0, 15, 30]; // Adjacent hues
        case 'complementary': return [0, 180]; // Opposite hues
        case 'splitComplementary': return [0, 150, 210]; // Base + colors on both sides of complement
        case 'triadic': return [0, 120, 240]; // Three colors equally spaced
        case 'tetradic': return [0, 90, 180, 270]; // Four colors equally spaced (square)
        case 'square': return [0, 90, 180, 270]; // Same as tetradic for square
        default: return [0, 30, 60, 90, 180, 210]; // Normal - variety of angles
      }
    }

    // IMPROVED: Function to create variations of harmony angles for more diversity
    function getHarmonyVariations(harmonyType, variationIndex) {
      const baseAngles = getHarmonyAngles(harmonyType);
      const variation = (variationIndex % 4) * 3; // 0, 3, 6, 9 degrees
      const varDirection = variationIndex % 2 === 0 ? 1 : -1; // Alternate direction
      
      // Apply variations to each angle
      return baseAngles.map((angle, i) => {
        // Different variations for each angle in the harmony
        const angleVariation = variation * (i + 1) * varDirection;
        return (angle + angleVariation + 360) % 360;
      });
    }

    // Analyze original colors to identify which ones are darker or lighter than the background
    function analyzeOriginalLightness(originalColors, bgIndex) {
      const results = {};
      
      // Get background color HSL
      const bgColorHSL = rgbToHsl(...originalColors[bgIndex]);
      
      // For each color, determine if it's darker, similar, or lighter than background
      originalColors.forEach((color, index) => {
        if (index === bgIndex) {
          results[index] = 'background';
          return;
        }
        
        const colorHSL = rgbToHsl(...color);
        const lightnessDiff = colorHSL[2] - bgColorHSL[2];
        
        // Categorize based on lightness difference
        if (lightnessDiff < -15) {
          results[index] = 'darker';
        } else if (lightnessDiff > 15) {
          results[index] = 'lighter';
        } else {
          results[index] = 'similar';
        }
      });
      
      return results;
    }

    // Map original colors directly to harmony positions for better correlation
    function mapOriginalColorsToHarmony(originalColors, bgIndex, harmonyType, baseHSL, variationIndex = 0) {
      // Get the harmony angles with variations for more diversity
      const angles = getHarmonyVariations(harmonyType, variationIndex);
      
      // Get the original bg color and its HSL
      const originalBgColor = originalColors[bgIndex];
      const originalBgHSL = rgbToHsl(...originalBgColor);
      
      // Convert all colors to HSL
      const colorsHSL = originalColors.map(color => rgbToHsl(...color));
      
      // Create a map of original color index to harmony angle
      const colorToHarmonyMap = {};
      
      // Special case for monochromatic
      if (harmonyType === 'monochromatic') {
        // All colors map to the same hue
        originalColors.forEach((_, index) => {
          colorToHarmonyMap[index] = 0; // All use the same hue (0 angle offset)
        });
        return colorToHarmonyMap;
      }
      
      // Always map bg color to base position
      colorToHarmonyMap[bgIndex] = 0;
      
      // For non-bg colors, find their best harmony position
      for (let i = 0; i < originalColors.length; i++) {
        if (i === bgIndex) continue; // Skip bg - already mapped
        
        const colorHSL = colorsHSL[i];
        
        // Calculate the hue difference to original bg
        let hueDiff = ((colorHSL[0] - originalBgHSL[0] + 540) % 360) - 180;
        
        // Find the closest harmony angle
        let closestAngle = angles[0];
        let minDiff = 360;
        
        for (const angle of angles) {
          const diff = Math.abs(((hueDiff - angle + 540) % 360) - 180);
          if (diff < minDiff) {
            minDiff = diff;
            closestAngle = angle;
          }
        }
        
        // Map this color to the closest harmony angle
        colorToHarmonyMap[i] = closestAngle;
      }
      
      return colorToHarmonyMap;
    }

    // Generate palettes with correct harmony and better correlation
    // and respect the original lightness relationships
    for (let paletteIndex = 0; paletteIndex < paletteCount; paletteIndex++) {
      // Create a working copy of distinctColors
      let workingColors = [...distinctColors];
      
      // Get the adjusted base color HSL
      const baseColorHSL = rgbToHsl(...adjustedBaseColor);
      
      // If we have a background color, replace it with our adjusted base color
      if (backgroundColorIndex >= 0 && backgroundColorIndex < workingColors.length) {
        workingColors[backgroundColorIndex] = [...adjustedBaseColor];
      }
      
      // Get original background color HSL
      const originalBgHSL = rgbToHsl(...distinctColors[backgroundColorIndex]);
      
      // Analyze original colors to identify darker/lighter relationships
      const lightnessRelationships = analyzeOriginalLightness(distinctColors, backgroundColorIndex);
      
      // Map original colors to harmony positions with variations based on palette index
      // This ensures each palette has different harmony angles for more variety
      const colorHarmonyMap = mapOriginalColorsToHarmony(
        distinctColors, 
        backgroundColorIndex, 
        harmonyScheme, 
        baseColorHSL,
        paletteIndex // Pass palette index to create variations
      );
      
      // Calculate the palette index variation offset
      // Using modulo for variety between palettes
      const paletteVariation = (paletteIndex % 6) - 2.5; // -2.5 to +2.5
      
      // IMPROVED: Calculate palette-specific saturation and lightness variations
      // This creates more visually distinct palettes in the same harmony
      const saturationShift = (paletteIndex % 5) * 4 - 8; // -8 to +8
      const lightnessShift = (paletteIndex % 5) * 4 - 8; // -8 to +8
      
      // IMPROVED: For non-monochromatic harmonies, rotate the entire harmony slightly
      // This creates more variation between palettes
      let harmonyRotation = 0;
      if (harmonyScheme !== 'monochromatic') {
        harmonyRotation = ((paletteIndex % 3) - 1) * 8; // -8, 0, or +8 degrees
      }
      
      // Process each original color
      for (let i = 0; i < workingColors.length; i++) {
        // Skip the background - it's already set to adjusted base color
        if (i === backgroundColorIndex) continue;
        
        // Get original color and its HSL
        const originalColor = distinctColors[i];
        const originalHSL = rgbToHsl(...originalColor);
        
        // Get this color's harmony angle
        const harmonyAngle = colorHarmonyMap[i] || 0;
        
        // Get this color's lightness relationship to the background
        const lightnessRelationship = lightnessRelationships[i] || 'similar';
        
        // Calculate the relationship to original background
        const originalSatRatio = originalHSL[1] / Math.max(1, originalBgHSL[1]);
        const originalLightRatio = originalHSL[2] / Math.max(1, originalBgHSL[2]);
        
        // Calculate color shifts that preserve these relationships
        let newHue, newSat, newLight;
        
        // IMPROVED: Apply harmony rotation for more variation
        // Apply the harmony angle with added rotation for palette variety
        if (harmonyScheme === 'normal') {
          // For normal scheme, preserve the exact original relationship
          // Calculate the original hue difference
          const hueDiff = ((originalHSL[0] - originalBgHSL[0] + 540) % 360) - 180;
          
          // Apply this difference to the new base color, plus rotation for variety
          newHue = (baseColorHSL[0] + hueDiff + harmonyRotation + 360) % 360;
          
          // Apply small variation for different palettes
          newHue = (newHue + paletteVariation * 3 + 360) % 360;
        } else {
          // For harmony schemes, use the mapped harmony angle plus rotation
          newHue = (baseColorHSL[0] + harmonyAngle + harmonyRotation + 360) % 360;
          
          // Apply smaller variation for different palettes
          // Small enough to maintain the harmony but provide variety
          newHue = (newHue + paletteVariation + 360) % 360;
        }
        
        // IMPROVED: Apply saturation variation based on palette index
        newSat = Math.min(100, Math.max(5, baseColorHSL[1] * originalSatRatio + saturationShift));
        
        // IMPROVED: Handle lightness based on both shade type and original lightness relationship
        // First, calculate the base lightness by preserving the original relationship
        newLight = Math.min(95, Math.max(5, baseColorHSL[2] * originalLightRatio + lightnessShift));
        
        // Now adjust based on shade type AND original lightness relationship
        if (shadeType === 'faint') {
          // For faint base colors:
          if (lightnessRelationship === 'darker') {
            // If the original color was darker than bg, keep it relatively darker
            // but not too dark - these should be medium-dark in a faint palette
            
            // Use different darkness levels based on palette index for variety
            const maxLightness = 60 - (paletteIndex % 3) * 7; // 60, 53, or 46
            newLight = Math.min(newLight, maxLightness);
            
            // If we're closer to the start of the palette, make some colors even darker
            // This provides variety in the palettes
            if (paletteIndex < 4) {
              newLight = Math.min(newLight, 40); // Even darker for variety
            }
          } else if (lightnessRelationship === 'lighter') {
            // If the original color was lighter than bg, keep it lighter
            // but make it even lighter for faint palettes
            const minLightness = 75 + (paletteIndex % 3) * 5; // 75, 80, or 85
            newLight = Math.max(newLight, minLightness);
          } else {
            // For colors that were similar to bg, keep them similar but faint
            newLight = Math.max(newLight, 65); // At least 65% lightness
          }
        } else if (shadeType === 'dark') {
          // For dark base colors:
          if (lightnessRelationship === 'darker') {
            // If the original color was darker than bg, make it very dark
            // Vary darkness based on palette index
            const maxLightness = 25 - (paletteIndex % 3) * 5; // 25, 20, or 15
            newLight = Math.min(newLight, maxLightness);
          } else if (lightnessRelationship === 'lighter') {
            // If the original color was lighter than bg, make it medium-dark
            // but relatively lighter than the bg
            // Different levels based on palette index for variety
            const maxLightness = 40 + (paletteIndex % 3) * 5; // 40, 45, or 50
            newLight = Math.min(Math.max(newLight, baseColorHSL[2] + 10), maxLightness);
          } else {
            // For colors similar to bg, keep them close to bg lightness
            newLight = Math.min(newLight, 35); // At most 35% lightness
          }
        }
        
        // Add small variations to sat and light for different palettes
        // Using the palette index for variety
        const satVar = 0.9 + (paletteIndex % 5) * 0.05; // 0.9-1.1
        const lightVar = 0.95 + (paletteIndex % 5) * 0.03; // 0.95-1.1
        
        newSat = Math.min(100, Math.max(5, newSat * satVar));
        newLight = Math.min(95, Math.max(5, newLight * lightVar));
        
        // Additional shade adjustments for saturation based on lightness relationship
        if (shadeType === 'faint') {
          if (lightnessRelationship === 'darker') {
            // Allow darker colors to keep more saturation in faint palettes
            // Vary saturation max based on palette index
            const maxSat = 70 + (paletteIndex % 4) * 5; // 70, 75, 80, or 85
            newSat = Math.min(newSat, maxSat);
          } else {
            // Other colors get reduced saturation in faint palettes
            // Different levels for different palettes
            const maxSat = 50 + (paletteIndex % 4) * 5; // 50, 55, 60, or 65
            newSat = Math.min(newSat, maxSat); 
          }
        } else if (shadeType === 'dark') {
          // Increase saturation a bit for dark palettes
          // Different amounts for different palettes
          const satFactor = 1.1 + (paletteIndex % 4) * 0.05; // 1.1, 1.15, 1.2, or 1.25
          newSat = Math.min(100, newSat * satFactor);
        }
        
        // Convert back to RGB and update the color
        workingColors[i] = hslToRgb(newHue, newSat, newLight);
      }
      
      // Ensure we have enough colors (at least 6)
      while (workingColors.length < 6) {
        // For additional colors, create ones that complement existing ones
        // and follow the harmony rules
        
        // Get the harmony angles with variations based on palette index
        const angles = getHarmonyVariations(harmonyScheme, paletteIndex);
        
        // Choose a source from existing colors, preferably not background
        let sourceIndex = workingColors.length % distinctColors.length;
        if (sourceIndex === backgroundColorIndex && workingColors.length > 1) {
          sourceIndex = (sourceIndex + 1) % workingColors.length;
        }
        
        // Get source color HSL
        const sourceHSL = rgbToHsl(...workingColors[sourceIndex]);
        
        // For new colors, select a harmony angle that isn't already well-represented
        // This helps ensure we have variety within the harmony scheme
        let selectedAngle;
        if (harmonyScheme === 'monochromatic') {
          // For monochromatic, use the same hue but vary sat/light
          selectedAngle = 0;
        } else {
          // Count how many colors we have at each harmony angle
          const angleCounts = {};
          angles.forEach(angle => { angleCounts[angle] = 0; });
          
          // Count existing colors
          for (let i = 0; i < workingColors.length; i++) {
            const angle = colorHarmonyMap[i] || 0;
            if (angleCounts[angle] !== undefined) {
              angleCounts[angle]++;
            }
          }
          
          // Find the least represented angle
          let minCount = Infinity;
          selectedAngle = angles[0];
          
          for (const angle in angleCounts) {
            if (angleCounts[angle] < minCount) {
              minCount = angleCounts[angle];
              selectedAngle = parseInt(angle);
            }
          }
        }
        
        // Apply harmony rotation for more variation
        selectedAngle = (selectedAngle + harmonyRotation + 360) % 360;
        
        // Create a new color using the selected harmony angle
        let newHue = (baseColorHSL[0] + selectedAngle + 360) % 360;
        
        // Vary saturation and lightness to create visual variety
        let newSat, newLight;
        
        // For additional colors, create complementary lightness relationships
        // This ensures visual contrast in the palette
        const bgLightness = baseColorHSL[2];
        
        // Decide if this new color should be darker or lighter for better contrast
        // Use palette index to vary this decision for more palette variety
        const makeDarker = ((paletteIndex + workingColors.length) % 2 === 0) || (bgLightness > 50);
        
        if (harmonyScheme === 'monochromatic') {
          // For monochromatic, create more variation in sat/light
          // Different variations based on palette index
          const satRange = 30 + (paletteIndex % 3) * 10; // 30, 40, or 50
          newSat = Math.min(100, Math.max(10, baseColorHSL[1] + randomInRange(-satRange, satRange)));
          
          // For faint palettes, new monochromatic colors should have varied lightness
          if (shadeType === 'faint') {
            if (makeDarker) {
              // Create some medium-dark colors for contrast
              // Different ranges based on palette index
              const minLight = 30 + (paletteIndex % 3) * 5; // 30, 35, or 40
              const maxLight = 50 + (paletteIndex % 3) * 5; // 50, 55, or 60
              newLight = Math.min(maxLight, Math.max(minLight, bgLightness - randomInRange(15, 30)));
            } else {
              // Create very light colors
              // Different ranges based on palette index
              const minLight = 75 + (paletteIndex % 3) * 5; // 75, 80, or 85
              newLight = Math.min(95, Math.max(minLight, bgLightness + randomInRange(5, 20)));
            }
          } 
          // For dark palettes, keep everything dark but with variation
          else if (shadeType === 'dark') {
            if (makeDarker) {
              // Very dark - different ranges
              const maxLight = 20 - (paletteIndex % 3) * 5; // 20, 15, or 10
              newLight = Math.max(5, Math.min(maxLight, randomInRange(5, 20)));
            } else {
              // Medium-dark - different ranges
              const minLight = 25 + (paletteIndex % 3) * 5; // 25, 30, or 35
              const maxLight = 40 + (paletteIndex % 3) * 5; // 40, 45, or 50
              newLight = Math.min(maxLight, Math.max(minLight, bgLightness + randomInRange(5, 15)));
            }
          }
          // For regular palettes, create balanced variation
          else {
            if (makeDarker) {
              // Different ranges based on palette index
              const minLight = 10 + (paletteIndex % 3) * 5; // 10, 15, or 20
              newLight = Math.max(minLight, bgLightness - randomInRange(15, 35));
            } else {
              // Different ranges based on palette index
              const maxLight = 80 + (paletteIndex % 3) * 5; // 80, 85, or 90
              newLight = Math.min(maxLight, bgLightness + randomInRange(15, 35));
            }
          }
        } else {
          // For other harmonies, maintain the harmony but create lightness contrast
          // Different saturation ranges based on palette index
          const satRange = 20 + (paletteIndex % 3) * 5; // 20, 25, or 30
          newSat = Math.min(100, Math.max(10, baseColorHSL[1] + randomInRange(-satRange, satRange)));
          
          // Create lightness contrast based on shade type
          if (shadeType === 'faint') {
            if (makeDarker) {
              // Medium-dark for contrast in faint palette
              // Different ranges based on palette index
              const minLight = 30 + (paletteIndex % 3) * 5; // 30, 35, or 40
              const maxLight = 50 + (paletteIndex % 3) * 5; // 50, 55, or 60
              newLight = Math.min(maxLight, Math.max(minLight, randomInRange(35, 55)));
            } else {
              // Very light - different ranges
              const minLight = 70 + (paletteIndex % 3) * 5; // 70, 75, or 80
              newLight = Math.min(95, Math.max(minLight, randomInRange(70, 90)));
            }
          } else if (shadeType === 'dark') {
            if (makeDarker) {
              // Very dark - different ranges
              const maxLight = 20 - (paletteIndex % 3) * 5; // 20, 15, or 10
              newLight = Math.max(5, Math.min(maxLight, randomInRange(5, 25)));
            } else {
              // Medium-dark - different ranges
              const minLight = 25 + (paletteIndex % 3) * 5; // 25, 30, or 35
              const maxLight = 40 + (paletteIndex % 3) * 5; // 40, 45, or 50
              newLight = Math.min(maxLight, Math.max(minLight, randomInRange(25, 45)));
            }
          } else {
            if (makeDarker) {
              // Different ranges based on palette index
              const minLight = 15 + (paletteIndex % 3) * 5; // 15, 20, or 25
              const maxLight = 35 + (paletteIndex % 3) * 5; // 35, 40, or 45
              newLight = Math.min(maxLight, Math.max(minLight, randomInRange(15, 40)));
            } else {
              // Different ranges based on palette index
              const minLight = 60 + (paletteIndex % 3) * 5; // 60, 65, or 70
              const maxLight = 80 + (paletteIndex % 3) * 5; // 80, 85, or 90
              newLight = Math.min(maxLight, Math.max(minLight, randomInRange(60, 85)));
            }
          }
        }
        
        // Add the new color
        workingColors.push(hslToRgb(newHue, newSat, newLight));
        
        // Update the harmony map for this new color
        colorHarmonyMap[workingColors.length - 1] = selectedAngle;
        
        // Also update the lightness relationship map to guide future adjustments
        lightnessRelationships[workingColors.length - 1] = makeDarker ? 'darker' : 'lighter';
      }
      
      // Ensure colors are sufficiently different from each other
      for (let attempt = 0; attempt < 10; attempt++) {
        let tooSimilar = false;
        
        // Check each pair of colors
        for (let i = 0; i < workingColors.length; i++) {
          for (let j = i + 1; j < workingColors.length; j++) {
            // Skip if either is the background color
            if (i === backgroundColorIndex || j === backgroundColorIndex) continue;
            
            // Calculate color distance
            const distance = colorDistance(workingColors[i], workingColors[j]);
            
            // If colors are too similar
            if (distance < 30) {
              tooSimilar = true;
              
              // Get the harmony angles for both colors
              const angleI = colorHarmonyMap[i] || 0;
              const angleJ = colorHarmonyMap[j] || 0;
              
              // Get lightness relationships for both colors
              const lightnessI = lightnessRelationships[i] || 'similar';
              const lightnessJ = lightnessRelationships[j] || 'similar';
              
              // If both have the same harmony angle, adjust one's sat/light
              if (angleI === angleJ) {
                // Adjust the second color's sat/light
                const colorHSL = rgbToHsl(...workingColors[j]);
                
                // Make significant changes to saturation and lightness
                // while preserving the lightness relationship
                if (lightnessJ === 'darker') {
                  // Keep it dark but change saturation significantly
                  colorHSL[1] = Math.min(100, Math.max(20, colorHSL[1] + (colorHSL[1] < 50 ? 30 : -30)));
                  
                  // Keep it relatively dark - with variations based on palette index
                  if (shadeType === 'faint') {
                    const minLight = 20 + (paletteIndex % 4) * 5; // 20, 25, 30, or 35
                    const maxLight = 45 + (paletteIndex % 4) * 5; // 45, 50, 55, or 60
                    colorHSL[2] = Math.min(maxLight, Math.max(minLight, colorHSL[2] + randomInRange(-10, 10)));
                  } else if (shadeType === 'dark') {
                    const maxLight = 25 - (paletteIndex % 3) * 5; // 25, 20, or 15
                    colorHSL[2] = Math.min(maxLight, Math.max(5, colorHSL[2] + randomInRange(-10, 10)));
                  } else {
                    const maxLight = 35 + (paletteIndex % 3) * 5; // 35, 40, or 45
                    colorHSL[2] = Math.min(maxLight, Math.max(15, colorHSL[2] + randomInRange(-10, 10)));
                  }
                } else if (lightnessJ === 'lighter') {
                  // Keep it light but change saturation
                  colorHSL[1] = Math.min(80, Math.max(10, colorHSL[1] + (colorHSL[1] < 40 ? 20 : -20)));
                  
                  // Keep it relatively light - with variations
                  if (shadeType === 'faint') {
                    const minLight = 70 + (paletteIndex % 4) * 5; // 70, 75, 80, or 85
                    colorHSL[2] = Math.min(95, Math.max(minLight, colorHSL[2] + randomInRange(-10, 10)));
                  } else if (shadeType === 'dark') {
                    const minLight = 30 + (paletteIndex % 3) * 5; // 30, 35, or 40
                    const maxLight = 45 + (paletteIndex % 3) * 5; // 45, 50, or 55
                    colorHSL[2] = Math.min(maxLight, Math.max(minLight, colorHSL[2] + randomInRange(-10, 10)));
                  } else {
                    const minLight = 60 + (paletteIndex % 3) * 5; // 60, 65, or 70
                    colorHSL[2] = Math.min(85, Math.max(minLight, colorHSL[2] + randomInRange(-10, 10)));
                  }
                } else {
                  // For similar lightness, make larger changes
                  colorHSL[1] = Math.min(100, Math.max(5, colorHSL[1] + (colorHSL[1] < 50 ? 30 : -30)));
                  colorHSL[2] = Math.min(90, Math.max(10, colorHSL[2] + (colorHSL[2] < 50 ? 30 : -30)));
                  
                  // Then apply shade adjustments with variations
                  if (shadeType === 'faint') {
                    const minLight = 55 + (paletteIndex % 3) * 5; // 55, 60, or 65
                    colorHSL[2] = Math.max(minLight, colorHSL[2]);
                  } else if (shadeType === 'dark') {
                    const maxLight = 40 + (paletteIndex % 3) * 5; // 40, 45, or 50
                    colorHSL[2] = Math.min(maxLight, colorHSL[2]);
                  }
                }
                
                // Update the color
                workingColors[j] = hslToRgb(...colorHSL);
              } else {
                // If different harmony angles, make a small hue adjustment
                // to better differentiate while maintaining harmony
                const colorHSL = rgbToHsl(...workingColors[j]);
                
                // Adjust hue slightly within its harmony position
                // Different variations based on palette index
                const hueVar = (paletteIndex % 5) * 2 + 5; // 5, 7, 9, 11, or 13
                colorHSL[0] = (colorHSL[0] + randomInRange(-hueVar, hueVar) + 360) % 360;
                
                // Make smaller changes to preserve harmony
                const satVar = 15 + (paletteIndex % 3) * 5; // 15, 20, or 25
                colorHSL[1] = Math.min(100, Math.max(5, colorHSL[1] + randomInRange(-satVar, satVar)));
                
                // Adjust lightness based on shade type and original relationship
                // with variations based on palette index
                if (lightnessJ === 'darker') {
                  if (shadeType === 'faint') {
                    const minLight = 30 + (paletteIndex % 3) * 5; // 30, 35, or 40
                    const maxLight = 55 + (paletteIndex % 3) * 5; // 55, 60, or 65
                    colorHSL[2] = Math.min(maxLight, Math.max(minLight, colorHSL[2] + randomInRange(-10, 10)));
                  } else if (shadeType === 'dark') {
                    const maxLight = 25 + (paletteIndex % 3) * 5; // 25, 30, or 35
                    colorHSL[2] = Math.min(maxLight, Math.max(5, colorHSL[2] + randomInRange(-10, 10)));
                  } else {
                    const maxLight = 35 + (paletteIndex % 3) * 5; // 35, 40, or 45
                    colorHSL[2] = Math.min(maxLight, Math.max(15, colorHSL[2] + randomInRange(-10, 10)));
                  }
                } else if (lightnessJ === 'lighter') {
                  if (shadeType === 'faint') {
                    const minLight = 65 + (paletteIndex % 3) * 5; // 65, 70, or 75
                    colorHSL[2] = Math.min(95, Math.max(minLight, colorHSL[2] + randomInRange(-10, 10)));
                  } else if (shadeType === 'dark') {
                    const minLight = 25 + (paletteIndex % 3) * 5; // 25, 30, or 35
                    const maxLight = 45 + (paletteIndex % 3) * 5; // 45, 50, or 55
                    colorHSL[2] = Math.min(maxLight, Math.max(minLight, colorHSL[2] + randomInRange(-10, 10)));
                  } else {
                    const minLight = 50 + (paletteIndex % 3) * 5; // 50, 55, or 60
                    colorHSL[2] = Math.min(85, Math.max(minLight, colorHSL[2] + randomInRange(-10, 10)));
                  }
                } else {
                  // Apply shade adjustments for similar lightness with variations
                  if (shadeType === 'faint') {
                    const minLight = 60 + (paletteIndex % 3) * 5; // 60, 65, or 70
                    colorHSL[2] = Math.max(minLight, colorHSL[2]);
                  } else if (shadeType === 'dark') {
                    const maxLight = 35 + (paletteIndex % 3) * 5; // 35, 40, or 45
                    colorHSL[2] = Math.min(maxLight, colorHSL[2]);
                  }
                }
                
                // Update the color
                workingColors[j] = hslToRgb(...colorHSL);
              }
            }
          }
        }
        
        if (!tooSimilar) break;
      }
      
      // Ensure our palette has visual variety by enforcing contrast between colors
      // This helps make each palette visually effective
      const ensureContrastInPalette = () => {
        // Convert all to HSL for easier manipulation
        const paletteHSL = workingColors.map(color => rgbToHsl(...color));
        
        // Get bg color lightness
        const bgLightness = paletteHSL[backgroundColorIndex][2];
        
        // Track how many light and dark colors we have
        let lightCount = 0, darkCount = 0;
        
        // Count light and dark colors relative to background
        for (let i = 0; i < paletteHSL.length; i++) {
          if (i === backgroundColorIndex) continue;
          
          if (paletteHSL[i][2] > bgLightness + 15) lightCount++;
          if (paletteHSL[i][2] < bgLightness - 15) darkCount++;
        }
        
        // If palette lacks contrast (too many similar lightness values)
        // adjust a few colors to create more contrast
        if (shadeType !== 'dark' && darkCount < 2) {
          // Add some darker colors for contrast
          for (let i = 0; i < paletteHSL.length && darkCount < 2; i++) {
            if (i === backgroundColorIndex) continue;
            if (paletteHSL[i][2] >= bgLightness - 10) {
              // Make this color darker
              // Different darkness levels based on palette index
              const minLight = 15 + (paletteIndex % 3) * 5; // 15, 20, or 25
              const darkAmount = 20 + (paletteIndex % 3) * 5; // 20, 25, or 30
              paletteHSL[i][2] = Math.max(minLight, bgLightness - randomInRange(darkAmount, darkAmount + 10));
              workingColors[i] = hslToRgb(...paletteHSL[i]);
              darkCount++;
            }
          }
        }
        
        if (shadeType !== 'faint' && lightCount < 2) {
          // Add some lighter colors for contrast
          for (let i = 0; i < paletteHSL.length && lightCount < 2; i++) {
            if (i === backgroundColorIndex) continue;
            if (paletteHSL[i][2] <= bgLightness + 10) {
              // Make this color lighter
              // Different lightness levels based on palette index
              const maxLight = 85 + (paletteIndex % 3) * 5; // 85, 90, or 95
              const lightAmount = 20 + (paletteIndex % 3) * 5; // 20, 25, or 30
              paletteHSL[i][2] = Math.min(maxLight, bgLightness + randomInRange(lightAmount, lightAmount + 10));
              workingColors[i] = hslToRgb(...paletteHSL[i]);
              lightCount++;
            }
          }
        }
      };
      
      // Apply contrast enforcement if this is not the first few palettes
      // (keep the first few palettes closer to the strict harmony rules)
      if (paletteIndex >= 3) {
        ensureContrastInPalette();
      }
      
      // Add the palette info
      Object.defineProperty(workingColors, 'info', {
        value: { 
          category: shadeType,
          harmonyScheme: harmonyScheme
        },
        enumerable: false
      });
      
      basePalettes.push(workingColors);
    }
    
    return basePalettes;
    
  } catch (e) {
    console.error("Error generating base color variants:", e);
    
    // Provide fallback palettes that maintain color family correlation
    const basePalettes = [];
    const fallbackShadeType = baseColor.shadeType || 'regular';
    const fallbackHarmonyScheme = baseColor.harmonyScheme || 'normal';
    
    // Create at least 6 palettes with better color correlation
    for (let i = 0; i < 12; i++) {
      let fallbackPalette = [];
      
      // Get base color in HSL for easier manipulation
      const baseHsl = rgbToHsl(...baseColor);
      
      // Create a palette with the base color in the background position
      for (let j = 0; j < Math.max(6, distinctColors.length); j++) {
        if (j === backgroundColorIndex) {
          // Adjust the base color based on shade category, but STAY IN THE SAME COLOR FAMILY
          let adjustedHsl = [...baseHsl];
          
          if (fallbackShadeType === "faint") {
            // For faint: maintain hue, reduce saturation, increase lightness
            adjustedHsl[1] = Math.max(10, baseHsl[1] * (0.7 + (i * 0.05)));
            adjustedHsl[2] = Math.min(95, 70 + (i % 20));
          } 
          else if (fallbackShadeType === "dark") {
            // For dark: maintain hue, possibly increase saturation, decrease lightness
            adjustedHsl[1] = Math.min(100, baseHsl[1] * (1.0 + (i * 0.05)));
            adjustedHsl[2] = Math.max(5, 35 - (i % 25));
          }
          else {
            // For regular: maintain hue, make small saturation/lightness adjustments
            const variation = (i % 10) - 5; // -5 to +5
            adjustedHsl[1] = Math.min(100, Math.max(10, baseHsl[1] + variation));
            adjustedHsl[2] = Math.min(80, Math.max(30, baseHsl[2] + variation));
          }
          
          fallbackPalette.push(hslToRgb(...adjustedHsl));
        } else if (j < distinctColors.length) {
          // For other colors, preserve their relationship to the base color
          const originalColor = distinctColors[j];
          const originalHsl = rgbToHsl(...originalColor);
          
          // Analyze if original color was darker or lighter than background
          const originalBgHsl = rgbToHsl(...distinctColors[backgroundColorIndex]);
          const wasOriginallyDarker = originalHsl[2] < originalBgHsl[2] - 15;
          const wasOriginallyLighter = originalHsl[2] > originalBgHsl[2] + 15;
          
          // Calculate the color's relationship to the base color
          const hueDiff = ((originalHsl[0] - baseHsl[0] + 540) % 360) - 180; // -180 to +180
          const satRatio = originalHsl[1] / Math.max(1, baseHsl[1]);
          const lightRatio = originalHsl[2] / Math.max(1, baseHsl[2]);
          
          // New color based on harmony scheme
          let newHue = baseHsl[0];
          
          // IMPROVED: Apply small rotation to harmony angles based on palette index
          // This creates more variation between palettes
          const harmonyRotation = ((i % 3) - 1) * 10; // -10, 0, or +10 degrees
          
          if (fallbackHarmonyScheme === 'monochromatic') {
            // Keep the same hue
            newHue = baseHsl[0];
          } else if (fallbackHarmonyScheme === 'analogous') {
            // Use analogous hues
            const analogousOffset = [-30, -15, 0, 15, 30];
            newHue = (baseHsl[0] + analogousOffset[j % analogousOffset.length] + harmonyRotation + 360) % 360;
          } else if (fallbackHarmonyScheme === 'complementary') {
            // Base and complement
            newHue = (baseHsl[0] + (j % 2 === 0 ? 0 : 180) + harmonyRotation + 360) % 360;
          } else if (fallbackHarmonyScheme === 'splitComplementary') {
            // Base, and two colors 150° and 210° from base
            if (j % 3 === 0) newHue = (baseHsl[0] + harmonyRotation + 360) % 360;
            else if (j % 3 === 1) newHue = (baseHsl[0] + 150 + harmonyRotation + 360) % 360;
            else newHue = (baseHsl[0] + 210 + harmonyRotation + 360) % 360;
          } else if (fallbackHarmonyScheme === 'triadic') {
            // Three colors 120° apart
            newHue = (baseHsl[0] + (j % 3) * 120 + harmonyRotation + 360) % 360;
          } else if (fallbackHarmonyScheme === 'tetradic' || fallbackHarmonyScheme === 'square') {
            // Four colors 90° apart
            newHue = (baseHsl[0] + (j % 4) * 90 + harmonyRotation + 360) % 360;
          } else {
            // Normal - maintain relative hue relationships
            newHue = (baseHsl[0] + hueDiff + 360) % 360;
          }
          
          // IMPROVED: Apply variations in saturation and lightness based on palette index
          const satShift = (i % 5) * 5 - 10; // -10 to +10
          const lightShift = (i % 5) * 5 - 10; // -10 to +10
          
          // Apply shade type adjustments and maintain lightness relationships
          let newSat = Math.min(100, Math.max(5, baseHsl[1] * satRatio + satShift));
          let newLight = Math.min(95, Math.max(5, baseHsl[2] * lightRatio + lightShift));
          
          // IMPROVED: Maintain dark/light relationships across shade types
          if (fallbackShadeType === "faint") {
            if (wasOriginallyDarker) {
              // Keep dark colors relatively dark even in faint palettes
              // Different darkness levels based on palette index
              const maxLight = 60 - (i % 3) * 5; // 60, 55, or 50
              newLight = Math.min(maxLight, newLight); // Cap at variable lightness
            } else if (wasOriginallyLighter) {
              // Make light colors even lighter in faint palettes
              // Different lightness levels
              const minLight = 75 + (i % 3) * 5; // 75, 80, or 85
              newLight = Math.max(minLight, newLight); // At least variable lightness
            } else {
              // For colors similar to bg, make them faint
              newLight = Math.max(65, newLight); // At least 65%
            }
          } else if (fallbackShadeType === "dark") {
            if (wasOriginallyDarker) {
              // Keep dark colors very dark in dark palettes
              // Different darkness levels
              const maxLight = 25 - (i % 3) * 5; // 25, 20, or 15
              newLight = Math.min(maxLight, newLight); // Very dark
            } else if (wasOriginallyLighter) {
              // Make light colors medium-dark in dark palettes
              // Different lightness levels
              const minLight = 30 + (i % 3) * 5; // 30, 35, or 40
              const maxLight = 45 + (i % 3) * 5; // 45, 50, or 55
              newLight = Math.min(maxLight, Math.max(minLight, newLight)); // Medium-dark
            } else {
              // For colors similar to bg, keep them dark
              const maxLight = 35 + (i % 3) * 5; // 35, 40, or 45
              newLight = Math.min(maxLight, newLight); // At most variable %
            }
          }
          
          // Add variations between palettes
          newHue = (newHue + (i * 5) + 360) % 360;
          newSat = Math.min(100, Math.max(0, newSat * (0.9 + (i * 0.02))));
          newLight = Math.min(95, Math.max(5, newLight * (0.95 + (i * 0.01)))); // Smaller lightness variations
          
          fallbackPalette.push(hslToRgb(newHue, newSat, newLight));
        } else {
          // For extra colors (if needed), create variations that follow the harmony pattern
          const baseIndex = j % distinctColors.length;
          const existingColor = fallbackPalette[baseIndex];
          const existingHsl = rgbToHsl(...existingColor);
          
          // Create a variation
          const newHsl = [...existingHsl];
          
          // IMPROVED: More varied hue shifts based on palette index
          const hueShift = 20 + (i % 4) * 10; // 20, 30, 40, or 50 degrees
          newHsl[0] = (newHsl[0] + hueShift * i + 360) % 360; // Add more hue variation
          
          // IMPROVED: Different saturation/lightness variations based on palette index
          const satRange = 15 + (i % 3) * 5; // 15, 20, or 25
          const lightRange = 15 + (i % 3) * 5; // 15, 20, or 25
          
          newHsl[1] = Math.min(100, Math.max(5, existingHsl[1] + randomInRange(-satRange, satRange)));
          newHsl[2] = Math.min(95, Math.max(5, existingHsl[2] + randomInRange(-lightRange, lightRange)));
          
          // Apply shade type adjustments
          if (fallbackShadeType === "faint") {
            newHsl[2] = Math.max(65, newHsl[2]);
          } else if (fallbackShadeType === "dark") {
            newHsl[2] = Math.min(40, newHsl[2]);
          }
          
          fallbackPalette.push(hslToRgb(...newHsl));
        }
      }
      
      // Add the palette info
      Object.defineProperty(fallbackPalette, 'info', {
        value: { 
          category: fallbackShadeType,
          harmonyScheme: fallbackHarmonyScheme
        },
        enumerable: false
      });
      
      basePalettes.push(fallbackPalette);
    }
    
    return basePalettes;
  }
}

async function selectBaseColor(color) {
  try {
    // Invalidate the cache when a new base color is selected
    if (window.palettePreviewCache && window.palettePreviewCache['base']) {
      // Clear all cached previews for base palettes
      window.palettePreviewCache['base'] = {};
    }
    
    // Remove any existing filter container
    const filterContainer = document.querySelector('.base-color-filters');
    if (filterContainer) {
      filterContainer.remove();
    }
    
    // Get color name
    const colorName = getColorName(color);
    
    // RGB to HEX conversion function
    function rgbToHex(r, g, b) {
      return '#' + [r, g, b].map(x => {
        const hex = x.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      }).join('');
    }
    
    // Check for ML label in the layers
    let mlLabel = null;
    const layerElement = document.querySelector('.layer[data-ml-label]');
    if (layerElement) {
      mlLabel = parseInt(layerElement.dataset.mlLabel, 10);
      console.log("Found ML label:", mlLabel);
    }
    
    // Process based on ML label
    if (mlLabel !== null) {
      if (mlLabel === 1) {
        // ML label 1: Image doesn't support base color selection
        alert("This image doesn't support base color selection based on our analysis. The image structure may be too complex for effective color mapping.");
        // Reset the view and return early
        resetBaseColorView();
        return;
      } 
      else if (mlLabel === 2) {
        // ML label 2: Image has complicated colors, warn user
        const shouldContinue = confirm("This image has a complicated color structure. Base color selection may produce unexpected results. Would you like to proceed anyway?");
        
        if (!shouldContinue) {
          resetBaseColorView();
          return; // User chose not to continue
        }
        // Otherwise continue with normal flow...
      }
      // For label 0, proceed normally without any warnings
    }
    
    // FIRST: Ensure window.originalColors is set from distinctColorsArrayColorPallet
    if (!window.originalColors || !Array.isArray(window.originalColors) || window.originalColors.length === 0) {
      // Try to get colors from window variable
      if (window.distinctColorsArrayColorPallet && 
          Array.isArray(window.distinctColorsArrayColorPallet) && 
          window.distinctColorsArrayColorPallet.length > 0) {
        
        window.originalColors = [...window.distinctColorsArrayColorPallet];
        console.log("Set window.originalColors from window.distinctColorsArrayColorPallet:", window.originalColors);
      }
      // Or try localStorage if window variable isn't available
      else if (localStorage.getItem('distinctColorsArrayColorPallet')) {
        try {
          const colorsString = localStorage.getItem('distinctColorsArrayColorPallet');
          const parsedColors = JSON.parse(colorsString);
          
          if (Array.isArray(parsedColors) && parsedColors.length > 0) {
            window.originalColors = parsedColors;
            console.log("Set window.originalColors from localStorage:", window.originalColors);
          }
        } catch (e) {
          console.error("Error parsing distinctColorsArrayColorPallet from localStorage:", e);
        }
      }
      
      // Make sure the colors are valid RGB arrays
      if (window.originalColors) {
        window.originalColors = window.originalColors.filter(color => 
          Array.isArray(color) && 
          color.length === 3 && 
          color.every(component => typeof component === 'number' && !isNaN(component))
        );
      }
    }

    // Determine which color should be the background color
    let backgroundColorIndex = null; 
    
    // If we have original colors from an image, ask if user wants to select background
    if (window.originalColors && Array.isArray(window.originalColors) && window.originalColors.length > 0) {
      // Create a simple confirmation dialog
      const wantsToSelectBG = await new Promise(resolve => {
        // Create confirmation modal
        const confirmModal = document.createElement('div');
        confirmModal.className = 'bg-select-confirm-overlay';
        confirmModal.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0,0,0,0.7);
          display: flex;
          justify-content: center;
          align-items: center;
          z-index: 9999;
        `;
        
        const confirmContent = document.createElement('div');
        confirmContent.className = 'bg-select-confirm-content';
        confirmContent.style.cssText = `
          background-color: white;
          border-radius: 8px;
          padding: 20px;
          max-width: 90%;
          width: 400px;
          box-shadow: 0 4px 6px rgba(0,0,0,0.3);
          text-align: center;
        `;
        
        const confirmTitle = document.createElement('h4');
        confirmTitle.textContent = 'Background Color Selection';
        confirmTitle.style.marginBottom = '15px';
        
        const confirmText = document.createElement('p');
        confirmText.textContent = 'Would you like to choose which color from your image should be treated as the background color?';
        
        const buttonContainer = document.createElement('div');
        buttonContainer.style.cssText = `
          display: flex;
          justify-content: center;
          gap: 15px;
          margin-top: 20px;
        `;
        
        const yesButton = document.createElement('button');
        yesButton.textContent = 'Yes, select background';
        yesButton.style.cssText = `
          padding: 8px 16px;
          background-color: #007bff;
          color: white;
          border: none;
          border-radius: 4px;
          cursor: pointer;
        `;
        
        const noButton = document.createElement('button');
        noButton.textContent = 'No, use default';
        noButton.style.cssText = `
          padding: 8px 16px;
          border: 1px solid #ddd;
          background-color: white;
          border-radius: 4px;
          cursor: pointer;
        `;
        
        yesButton.addEventListener('click', () => {
          document.body.removeChild(confirmModal);
          resolve(true);
        });
        
        noButton.addEventListener('click', () => {
          document.body.removeChild(confirmModal);
          resolve(false);
        });
        
        buttonContainer.appendChild(noButton);
        buttonContainer.appendChild(yesButton);
        
        confirmContent.appendChild(confirmTitle);
        confirmContent.appendChild(confirmText);
        confirmContent.appendChild(buttonContainer);
        confirmModal.appendChild(confirmContent);
        
        document.body.appendChild(confirmModal);
      });

      console.log("Original colors available:", window.originalColors);
      console.log("Is array?", Array.isArray(window.originalColors));
      console.log("Length:", window.originalColors ? window.originalColors.length : 0);
      
      // If user wants to select background color, show the selector
      if (wantsToSelectBG) {
        console.log("Showing background color selector...");
        backgroundColorIndex = await showBackgroundColorSelector(color, window.originalColors);
        console.log(`User selected background color index: ${backgroundColorIndex}`);
      } else {
        // User didn't want to select, so find the best matching color as background
        // We'll look for the brightest color or closest to white as default background
        let maxBrightness = -1;
        window.originalColors.forEach((c, idx) => {
          // Simple brightness formula: (R+G+B)/3
          const brightness = (c[0] + c[1] + c[2]) / 3;
          if (brightness > maxBrightness) {
            maxBrightness = brightness;
            backgroundColorIndex = idx;
          }
        });
        console.log(`Using brightest color as background (index: ${backgroundColorIndex})`);
      }
    } else {
      console.log("No original colors available, using null for background index");
    }
    
    // Now that we have the background color index, proceed with UI updates
    
    // Hide the base colors grid
    const baseColorsGrid = document.querySelector('.base-colors-grid');
    baseColorsGrid.style.display = 'none';

    // Show the palettes section
    const basePalettesSection = document.querySelector('.base-palettes-section');
    if (basePalettesSection) {
      basePalettesSection.style.display = 'block';
    } else {
      console.error("Could not find .base-palettes-section element");
      return;
    }

    // Change the header text to indicate selected color
    const headerElement = document.querySelector('#baseColorContent h4');
    if (headerElement) {
      const hexColor = rgbToHex(color[0], color[1], color[2]);
      headerElement.textContent = `Palettes with ${colorName} (${hexColor})`;
    }

    // Add a back button next to the header if it doesn't exist
    if (!document.querySelector('.back-to-base-colors')) {
      const backButton = document.createElement('button');
      backButton.className = 'btn btn-sm btn-outline-secondary back-to-base-colors ms-2';
      backButton.innerHTML = '<i class="bi bi-arrow-left"></i> Back to Colors';
      backButton.onclick = resetBaseColorView;

      if (headerElement && headerElement.parentElement) {
        headerElement.parentElement.insertBefore(backButton, headerElement.nextSibling);
      }
    }

    // Store the selected base color
    window.selectedBaseColor = color;
    window.selectedBackgroundColorIndex = backgroundColorIndex;
    
    // Initialize palette storage
    window.basePaletteColors = {};
    window.basePaletteColors.shadeCategories = {};
    window.basePaletteColors.harmonySchemes = {};
    
    // Define harmony schemes
    const harmonySchemes = [
      'normal', 'monochromatic', 'analogous', 'complementary', 
      'splitComplementary', 'triadic', 'tetradic', 'square'
    ];
    
    // Define shade types
    const shadeTypes = ['faint', 'regular', 'dark'];
    
    // Generate palettes for each combination of harmony scheme and shade type
    let paletteIndex = 0;
    
    for (const harmonyScheme of harmonySchemes) {
      for (const shadeType of shadeTypes) {
        // Add harmony and shade info to the color object
        const colorWithInfo = [...color];
        colorWithInfo.harmonyScheme = harmonyScheme;
        colorWithInfo.shadeType = shadeType;
        
        // Generate 12 palettes for this combination
        const palettes = generateBaseColorPalettes(colorWithInfo, backgroundColorIndex);
        
        // Store generated palettes
        for (let i = 0; i < palettes.length; i++) {
          // Store the palette colors
          window.basePaletteColors[paletteIndex] = [...palettes[i]];
          
          // Store the category information
          window.basePaletteColors.shadeCategories[paletteIndex] = shadeType;
          window.basePaletteColors.harmonySchemes[paletteIndex] = harmonyScheme;
          
          paletteIndex++;
        }
      }
    }

    // Store in localStorage for persistence
    try {
      localStorage.setItem('basePaletteColors', JSON.stringify(window.basePaletteColors));
    } catch (e) {
      console.warn("Could not store basePaletteColors in localStorage:", e);
    }

    // Initialize preview cache if needed
    if (!window.palettePreviewCache) {
      window.palettePreviewCache = {};
    }
    if (!window.palettePreviewCache['base']) {
      window.palettePreviewCache['base'] = {};
    }

    // Create preview canvases if they don't exist
    if (!window.previewCanvases) {
      window.previewCanvases = {};
      
      // Generate a smaller version of the original image for preview
      const originalCanvas = document.getElementById('layer_canvas_1');
      if (originalCanvas) {
        const previewCanvas = document.createElement('canvas');
        previewCanvas.width = 200;
        previewCanvas.height = 200;
        const previewCtx = previewCanvas.getContext('2d', { willReadFrequently: true });
        
        // Draw the original image scaled down
        previewCtx.drawImage(originalCanvas, 0, 0, 200, 200);
        
        // Store the preview canvas data URL for future use
        window.previewCanvases['original'] = previewCanvas.toDataURL();
      }
    }
    
    // Create the filters with dropdowns
    createBaseColorDropdownFilters(color);
    
    // Function to prepare display colors
    function prepareDisplayColors(colors) {
      try {
        // Make sure all colors are valid
        const validColors = colors.filter(color =>
          Array.isArray(color) &&
          color.length === 3 &&
          color.every(val => typeof val === 'number' && !isNaN(val))
        );

        // If no valid colors, return a basic palette
        if (validColors.length === 0) {
          console.warn("No valid colors for display, using basic palette");
          return [
            [...color], // Use selected color as first
            [0, 255, 0], [0, 0, 255],
            [255, 255, 0], [255, 0, 255], [0, 255, 255]
          ];
        }

        // Always preserve the first color (selected color)
        let displayColors = [validColors[0]];

        const FIXED_DISPLAY_COUNT = 6; // Fixed number for display consistency

        // If we have more than FIXED_DISPLAY_COUNT colors, use a subset for display
        if (validColors.length > FIXED_DISPLAY_COUNT) {
          // Select remaining display colors evenly distributed to maintain sequence
          const step = (validColors.length - 1) / (FIXED_DISPLAY_COUNT - 1);
          for (let i = 1; i < FIXED_DISPLAY_COUNT; i++) {
            const idx = Math.min(Math.floor(1 + (i - 1) * step), validColors.length - 1);
            displayColors.push(validColors[idx]);
          }
        } else if (validColors.length < FIXED_DISPLAY_COUNT) {
          // Add remaining colors
          for (let i = 1; i < validColors.length; i++) {
            displayColors.push(validColors[i]);
          }

          // If still not enough, duplicate some colors to reach FIXED_DISPLAY_COUNT
          while (displayColors.length < FIXED_DISPLAY_COUNT) {
            const idx = displayColors.length % validColors.length;
            displayColors.push([...validColors[idx]]);
          }
        } else {
          // We have exactly FIXED_DISPLAY_COUNT colors
          displayColors = [...validColors];
        }

        return displayColors;
      } catch (e) {
        console.error("Error preparing display colors:", e);
        // Return a fallback set of colors
        return [
          [...color], // Use selected color as first
          [0, 255, 0], [0, 0, 255],
          [255, 255, 0], [255, 0, 255], [0, 255, 255]
        ];
      }
    }

    // Function to display a modal with all colors in the palette
    function showFullPaletteModal(palette, collection, paletteIndex) {
      // Create and append modal elements if they don't exist
      let modal = document.getElementById('full-palette-modal');

      if (!modal) {
        modal = document.createElement('div');
        modal.id = 'full-palette-modal';
        modal.classList.add('full-palette-modal');

        const modalContent = document.createElement('div');
        modalContent.classList.add('full-palette-modal-content');

        const closeBtn = document.createElement('span');
        closeBtn.classList.add('close-palette-modal');
        closeBtn.innerHTML = '&times;';

        const modalTitle = document.createElement('h3');
        modalTitle.classList.add('palette-modal-title');

        const colorsContainer = document.createElement('div');
        colorsContainer.classList.add('all-colors-container');

        modalContent.appendChild(closeBtn);
        modalContent.appendChild(modalTitle);
        modalContent.appendChild(colorsContainer);
        modal.appendChild(modalContent);

        document.body.appendChild(modal);

        // Add event listener to close button
        closeBtn.addEventListener('click', function() {
          modal.style.display = 'none';
        });

        // Close modal when clicking outside content
        window.addEventListener('click', function(event) {
          if (event.target === modal) {
            modal.style.display = 'none';
          }
        });
      }

      // Update modal content with current palette
      const modalTitle = modal.querySelector('.palette-modal-title');
      const colorsContainer = modal.querySelector('.all-colors-container');

      // Get palette category and harmony if available
      let category = "Regular";
      let harmony = "Normal";
      
      if (window.basePaletteColors) {
        if (window.basePaletteColors.shadeCategories && 
            window.basePaletteColors.shadeCategories[paletteIndex]) {
          category = window.basePaletteColors.shadeCategories[paletteIndex].charAt(0).toUpperCase() 
                  + window.basePaletteColors.shadeCategories[paletteIndex].slice(1);
        }
        
        if (window.basePaletteColors.harmonySchemes && 
            window.basePaletteColors.harmonySchemes[paletteIndex]) {
          // Format harmony scheme for display (e.g., "splitComplementary" -> "Split Complementary")
          const harmonyRaw = window.basePaletteColors.harmonySchemes[paletteIndex];
          harmony = harmonyRaw.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
          if (harmony === "Normal") harmony = "Standard";
        }
      }

      modalTitle.textContent = `Full Palette (${collection.toUpperCase()} #${paletteIndex+1} - ${category}, ${harmony})`;
      colorsContainer.innerHTML = '';

      // Add all colors to the modal
      palette.forEach((color, index) => {
        const colorBox = document.createElement('div');
        colorBox.classList.add('full-palette-color');
        colorBox.style.backgroundColor = `rgb(${color.join(',')})`;

        // Convert RGB to HEX for display
        const hexColor = rgbToHex(color[0], color[1], color[2]);

        // Add color information - using HEX code only
        const colorInfo = document.createElement('div');
        colorInfo.classList.add('color-info');
        colorInfo.textContent = `Color ${index+1}: ${hexColor}`;

        // Add tooltip with HEX code only
        colorBox.title = hexColor;

        colorBox.appendChild(colorInfo);
        colorsContainer.appendChild(colorBox);
      });

      // Show the modal
      modal.style.display = 'block';
    }
    
    // Function to generate a preview of the palette applied to the image
    async function generatePreview(previewCanvas, paletteColors, paletteIndex) {
      try {
        // Mark the container as not ready (ensure loading indicator shows)
        const container = previewCanvas.closest('.palette-clickable-container');
        if (container) {
          container.classList.remove('preview-ready');
        }
        
        // Check cache first - expanded cache check
        if (window.palettePreviewCache && 
            window.palettePreviewCache['base'] && 
            window.palettePreviewCache['base'][paletteIndex]) {
            
            // Use cached preview
            const cachedPreview = window.palettePreviewCache['base'][paletteIndex];
            const ctx = previewCanvas.getContext('2d', { willReadFrequently: true });
            
            // Clear with white background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
            
            return new Promise((resolve) => {
              const img = new Image();
              img.onload = () => {
                // Calculate proportional dimensions to maintain aspect ratio
                const scale = Math.min(
                    previewCanvas.width / img.width,
                    previewCanvas.height / img.height
                );
                
                const scaledWidth = img.width * scale;
                const scaledHeight = img.height * scale;
                
                // Center the image
                const x = (previewCanvas.width - scaledWidth) / 2;
                const y = (previewCanvas.height - scaledHeight) / 2;
                
                // Draw the image with proper aspect ratio
                ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
                
                // Mark preview as ready to hide the loading indicator
                if (container) {
                  container.classList.add('preview-ready');
                }
                resolve();
              };
              img.onerror = () => {
                // Draw fallback and mark as ready
                drawFallbackPreview(previewCanvas);
                if (container) {
                  container.classList.add('preview-ready');
                }
                resolve();
              };
              img.src = cachedPreview;
            });
        }
            
            // No cache, create new preview
            // Get the original image
            const originalCanvas = document.getElementById('layer_canvas_1');
            
            if (!originalCanvas) {
              console.error('No original canvas found for preview');
              drawFallbackPreview(previewCanvas);
              if (container) {
                container.classList.add('preview-ready');
              }
              return;
            }
            
            // Clear the preview canvas with white background
            const ctx = previewCanvas.getContext('2d', { willReadFrequently: true });
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
            
            // Calculate dimensions that maintain aspect ratio
            const originalAspect = originalCanvas.width / originalCanvas.height;
            let previewWidth, previewHeight, offsetX = 0, offsetY = 0;
            
            if (originalAspect > 1) {
              // Image is wider than tall
              previewWidth = previewCanvas.width;
              previewHeight = previewWidth / originalAspect;
              offsetY = (previewCanvas.height - previewHeight) / 2;
            } else {
              // Image is taller than wide
              previewHeight = previewCanvas.height;
              previewWidth = previewHeight * originalAspect;
              offsetX = (previewCanvas.width - previewWidth) / 2;
            }
            
            // Create a temporary canvas for the original image at preview size
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = previewWidth;
            tempCanvas.height = previewHeight;
            const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
            
            // Draw original image to temp canvas maintaining aspect ratio
            tempCtx.drawImage(originalCanvas, 0, 0, previewWidth, previewHeight);
            
            // Now get the temp canvas data for processing
            const imageData = tempCtx.getImageData(0, 0, previewWidth, previewHeight);
            
            // Find original colors from the image
            const originalColors = await getDistinctColors(imageData, 30, 50);
            
            if (!originalColors || originalColors.length === 0) {
              console.error('No original colors found for preview');
              // Still draw the original image with correct aspect ratio
              ctx.drawImage(tempCanvas, offsetX, offsetY);
              
              // Mark preview as ready
              if (container) {
                container.classList.add('preview-ready');
              }
              return;
            }
            
            // Create color mappings
            const colorMappings = [];
            
            // Special handling for background color
            if (backgroundColorIndex !== null && 
                backgroundColorIndex >= 0 && 
                backgroundColorIndex < originalColors.length) {
                
                // Map colors with special consideration for the background color
                for (let i = 0; i < originalColors.length; i++) {
                    if (i === backgroundColorIndex) {
                        // For the background color index, map to the selected base color (first in palette)
                        colorMappings.push({
                            originalColor: originalColors[i],
                            targetColor: paletteColors[0]
                        });
                    } else {
                        // For other colors, map to rest of palette
                        const targetIndex = (i < backgroundColorIndex) ? i + 1 : i;
                        const paletteIndex = targetIndex % paletteColors.length;
                        
                        colorMappings.push({
                            originalColor: originalColors[i],
                            targetColor: paletteColors[paletteIndex]
                        });
                    }
                }
            } else {
                // Regular mapping if no background color is specified
                for (let i = 0; i < Math.min(originalColors.length, paletteColors.length); i++) {
                    colorMappings.push({
                        originalColor: originalColors[i],
                        targetColor: paletteColors[i % paletteColors.length]
                    });
                }
            }
            
            // Use a simplified processor for the preview
            const colorProcessor = new ColorProcessor();
            const imageUrl = tempCanvas.toDataURL();
            
            // Process the preview
            const processedImageUrl = await colorProcessor.applyMultipleColorMappings(
                imageUrl,
                colorMappings
            );
            
            // Load the processed image back to the preview canvas
            return new Promise((resolve) => {
              const resultImg = new Image();
              resultImg.onload = () => {
                // Draw the processed image with the correct positioning
                ctx.drawImage(resultImg, offsetX, offsetY, previewWidth, previewHeight);
                
                // Cache the generated preview
                if (!window.palettePreviewCache) {
                    window.palettePreviewCache = {};
                }
                if (!window.palettePreviewCache['base']) {
                    window.palettePreviewCache['base'] = {};
                }
                window.palettePreviewCache['base'][paletteIndex] = previewCanvas.toDataURL();
                
                // Mark preview as ready to hide loading indicator
                if (container) {
                  container.classList.add('preview-ready');
                }
                resolve();
              };
              resultImg.onerror = () => {
                console.error("Error loading processed preview");
                drawFallbackPreview(previewCanvas);
                if (container) {
                  container.classList.add('preview-ready');
                }
                resolve();
              };
              resultImg.src = processedImageUrl;
            });
            
          } catch (error) {
            console.error("Error generating preview:", error);
            drawFallbackPreview(previewCanvas);
            const container = previewCanvas.closest('.palette-clickable-container');
            if (container) {
              container.classList.add('preview-ready');
            }
          }
        }

    // Helper function to draw fallback preview
    function drawFallbackPreview(canvas) {
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#f5f5f5';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#999';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = '14px sans-serif';
      ctx.fillText('Preview unavailable', canvas.width/2, canvas.height/2);
    }

    // Create or update palette containers - we need to ensure we have enough containers
    const palettesContainer = document.querySelector('.base-palettes-container');
    if (palettesContainer) {
      // Clear existing containers
      palettesContainer.innerHTML = '';

      // Calculate total palettes (all combinations of harmonies × shades × 12 palettes each)
      const TOTAL_PALETTES = harmonySchemes.length * shadeTypes.length * 12;
      
      // Create containers for all our palettes
      for (let i = 0; i < TOTAL_PALETTES; i++) {
        const paletteRow = document.createElement('div');
        paletteRow.className = 'row mb-4 palette-row';
        
        // Add data attributes for shade category and harmony scheme if available
        if (window.basePaletteColors) {
          if (window.basePaletteColors.shadeCategories && 
              window.basePaletteColors.shadeCategories[i]) {
            paletteRow.dataset.shadeCategory = window.basePaletteColors.shadeCategories[i];
          }
          
          if (window.basePaletteColors.harmonySchemes && 
              window.basePaletteColors.harmonySchemes[i]) {
            paletteRow.dataset.harmonyScheme = window.basePaletteColors.harmonySchemes[i];
          }
        }
        
        const paletteCol = document.createElement('div');
        paletteCol.className = 'col-12';
        paletteRow.appendChild(paletteCol);
        
        const paletteCard = document.createElement('div');
        paletteCard.className = 'card shadow-sm h-100';
        paletteCol.appendChild(paletteCard);
        
        const cardBody = document.createElement('div');
        cardBody.className = 'card-body';
        paletteCard.appendChild(cardBody);
        
        const paletteContainer = document.createElement('div');
        paletteContainer.id = `base_colorPalette_${i}`;
        paletteContainer.className = 'color-palette-container';
        cardBody.appendChild(paletteContainer);
        
        const paletteNumber = document.createElement('div');
        paletteNumber.className = 'palette-number';
        paletteNumber.textContent = `${i + 1}`;
        cardBody.appendChild(paletteNumber);
        
        const buttonsContainer = document.createElement('div');
        buttonsContainer.className = 'btn-group w-100 mt-2';
        buttonsContainer.setAttribute('role', 'group');
        cardBody.appendChild(buttonsContainer);
        
        const shuffleButton = document.createElement('button');
        shuffleButton.id = `base_shufflePalette_${i}`;
        shuffleButton.className = 'btn btn-outline-secondary btn-sm';
        shuffleButton.innerHTML = '<i class="bi bi-shuffle"></i> Shuffle';
        shuffleButton.type = 'button';
        buttonsContainer.appendChild(shuffleButton);
        
        const applyButton = document.createElement('button');
        applyButton.id = `base_applyButton_${i}`;
        applyButton.className = 'btn btn-primary btn-sm';
        applyButton.innerHTML = '<i class="bi bi-check2-circle"></i> Apply';
        applyButton.type = 'button';
        buttonsContainer.appendChild(applyButton);
        
        palettesContainer.appendChild(paletteRow);
      }
    }

    // Display the generated palettes with previews
    for (let i = 0; i < Object.keys(window.basePaletteColors).length; i++) {
      if (i === 'shadeCategories' || i === 'harmonySchemes') continue;
      
      const paletteContainer = document.getElementById(`base_colorPalette_${i}`);
      if (!paletteContainer) continue;

      paletteContainer.innerHTML = '';

      // Get the generated palette
      const paletteColors = window.basePaletteColors[i];
      if (!paletteColors) continue;

      // Create container for the palette that will be clickable as a whole
      const clickableContainer = document.createElement('div');
      clickableContainer.classList.add('palette-clickable-container');
      paletteContainer.appendChild(clickableContainer);

      // Add data attribute to store the palette index
      clickableContainer.dataset.paletteIndex = i;
      clickableContainer.dataset.collection = 'base';
      
      // Get and store shade category and harmony scheme
      let shadeCategory = 'regular';
      let harmonyScheme = 'normal';
      
      if (window.basePaletteColors.shadeCategories && window.basePaletteColors.shadeCategories[i]) {
        shadeCategory = window.basePaletteColors.shadeCategories[i];
        clickableContainer.dataset.shadeCategory = shadeCategory;
      }
      
      if (window.basePaletteColors.harmonySchemes && window.basePaletteColors.harmonySchemes[i]) {
        harmonyScheme = window.basePaletteColors.harmonySchemes[i];
        clickableContainer.dataset.harmonyScheme = harmonyScheme;
      }
      
      // Add shade tag - visual indicator of palette type
      const shadeTags = document.createElement('div');
      shadeTags.className = 'scheme-tags';
      
      // Add shade tag
      const shadeTag = document.createElement('span');
      shadeTag.className = 'shade-tag';
      shadeTag.textContent = shadeCategory.charAt(0).toUpperCase() + shadeCategory.slice(1);
      shadeTags.appendChild(shadeTag);
      
      // Add harmony tag
      const harmonyTag = document.createElement('span');
      harmonyTag.className = 'harmony-tag';
      
      // Format harmony scheme for display
      let harmonyDisplay = harmonyScheme;
      if (harmonyScheme === 'splitComplementary') {
        harmonyDisplay = 'Split Comp.';
      } else if (harmonyScheme === 'monochromatic') {
        harmonyDisplay = 'Monochrome';
      } else if (harmonyScheme === 'complementary') {
        harmonyDisplay = 'Complement';
      } else if (harmonyScheme === 'analogous') {
        harmonyDisplay = 'Analogous';
      } else if (harmonyScheme === 'triadic') {
        harmonyDisplay = 'Triadic';
      } else if (harmonyScheme === 'tetradic') {
        harmonyDisplay = 'Tetradic';
      } else if (harmonyScheme === 'square') {
        harmonyDisplay = 'Square';
      } else if (harmonyScheme === 'normal') {
        harmonyDisplay = 'Standard';
      }
      
      harmonyTag.textContent = harmonyDisplay;
      shadeTags.appendChild(harmonyTag);
      
      clickableContainer.appendChild(shadeTags);
      
      // NEW: Add preview image container
      const previewContainer = document.createElement('div');
      previewContainer.classList.add('palette-preview-container');
      clickableContainer.appendChild(previewContainer);
      
      // Create small preview canvas
      const previewCanvas = document.createElement('canvas');
      previewCanvas.width = 200;
      previewCanvas.height = 200;
      previewCanvas.classList.add('palette-preview-canvas');
      previewContainer.appendChild(previewCanvas);
      
      // Generate the preview using the full palette
      generatePreview(previewCanvas, paletteColors, i);

      // Add click handler to use the FULL palette when clicked
      clickableContainer.addEventListener('click', function() {
        try {
          const paletteIndex = parseInt(this.dataset.paletteIndex, 10);

          console.log(`Palette clicked: base[${paletteIndex}]`);

          // Call processPallet with 'base' collection and paletteIndex
          if (typeof window.processPallet === 'function') {
            const fullPalette = window.basePaletteColors[paletteIndex];
            if (fullPalette && fullPalette.length > 0) {
              window.processPallet(null, 1, null, 0, null, fullPalette, 'base', paletteIndex);
            } else {
              console.error(`No full palette found in basePaletteColors[${paletteIndex}]`);
            }
          }
        } catch (e) {
          console.error("Error in palette click handler:", e);
        }
      });
      
      // NEW: Display the representative colors underneath the preview
      const swatchContainer = document.createElement('div');
      swatchContainer.classList.add('swatch-container');
      clickableContainer.appendChild(swatchContainer);

      // Prepare display colors - consistent count for all palettes
      const displayColors = prepareDisplayColors(paletteColors);

      // Display color swatches
      displayColors.forEach((color, idx) => {
        const swatch = document.createElement('div');
        swatch.classList.add('color-swatch');
        swatch.style.backgroundColor = `rgb(${color.join(',')})`;

        // Convert RGB to HEX for tooltip
        const hexColor = rgbToHex(color[0], color[1], color[2]);

        // Just show the HEX value in the tooltip
        swatch.title = hexColor;

        // Add special class for base swatches if needed
        swatch.classList.add('base-swatch');

        swatchContainer.appendChild(swatch);
      });

      // Add "Show All" button
      const showAllButton = document.createElement('div');
      showAllButton.classList.add('show-all-colors-btn');
      showAllButton.innerHTML = '+';
      showAllButton.title = 'Show all colors in palette';
      clickableContainer.appendChild(showAllButton);

      // Add event listener to show all colors in a modal
      showAllButton.addEventListener('click', function(e) {
        e.stopPropagation(); // Prevent triggering the parent container's click

        const fullPalette = window.basePaletteColors[i];
        if (!fullPalette || fullPalette.length === 0) {
          console.error('No full palette found to display');
          return;
        }

        showFullPaletteModal(fullPalette, 'base', i);
      });
    }

    // Add event listeners for shuffle buttons
    document.querySelectorAll('[id^="base_shufflePalette_"]').forEach(button => {
      const paletteIndex = parseInt(button.id.split('_').pop(), 10);

      // Remove existing click listeners
      const newButton = button.cloneNode(true);
      button.parentNode.replaceChild(newButton, button);

      newButton.addEventListener('click', async function(e) {
        e.stopPropagation(); // Prevent triggering palette selection

        try {
          // Get current shade category and harmony scheme for this palette
          let shadeCategory = 'regular';
          let harmonyScheme = 'normal';
          
          if (window.basePaletteColors && window.basePaletteColors.shadeCategories &&
              window.basePaletteColors.shadeCategories[paletteIndex]) {
            shadeCategory = window.basePaletteColors.shadeCategories[paletteIndex];
          }
          
          if (window.basePaletteColors && window.basePaletteColors.harmonySchemes &&
              window.basePaletteColors.harmonySchemes[paletteIndex]) {
            harmonyScheme = window.basePaletteColors.harmonySchemes[paletteIndex];
          }
          
          // Add harmony and shade info to the color object
          const colorWithInfo = [...color];
          colorWithInfo.harmonyScheme = harmonyScheme;
          colorWithInfo.shadeType = shadeCategory;
          
          // Generate a new shuffled palette that maintains the shade and harmony types
          const newPalette = generateBaseColorPalettes(colorWithInfo, backgroundColorIndex)[0];

          // Store the new palette
          window.basePaletteColors[paletteIndex] = [...newPalette];
          
          // Update shade category and harmony scheme
          if (!window.basePaletteColors.shadeCategories) {
            window.basePaletteColors.shadeCategories = {};
          }
          window.basePaletteColors.shadeCategories[paletteIndex] = shadeCategory;
          
          if (!window.basePaletteColors.harmonySchemes) {
            window.basePaletteColors.harmonySchemes = {};
          }
          window.basePaletteColors.harmonySchemes[paletteIndex] = harmonyScheme;

          // Update localStorage
          try {
            localStorage.setItem('basePaletteColors', JSON.stringify(window.basePaletteColors));
          } catch (e) {
            console.warn("Could not update basePaletteColors in localStorage:", e);
          }

          // Update the display
          const paletteContainer = document.getElementById(`base_colorPalette_${paletteIndex}`);
          if (!paletteContainer) return;

          paletteContainer.innerHTML = '';

          // Create clickable container
          const clickableContainer = document.createElement('div');
          clickableContainer.classList.add('palette-clickable-container');
          paletteContainer.appendChild(clickableContainer);

          // Store data
          clickableContainer.dataset.paletteIndex = paletteIndex;
          clickableContainer.dataset.collection = 'base';
          clickableContainer.dataset.shadeCategory = shadeCategory;
          clickableContainer.dataset.harmonyScheme = harmonyScheme;
          
          // Add scheme tags
          const shadeTags = document.createElement('div');
          shadeTags.className = 'scheme-tags';
          
          // Add shade tag
          const shadeTag = document.createElement('span');
          shadeTag.className = 'shade-tag';
          shadeTag.textContent = shadeCategory.charAt(0).toUpperCase() + shadeCategory.slice(1);
          shadeTags.appendChild(shadeTag);
          
          // Add harmony tag
          const harmonyTag = document.createElement('span');
          harmonyTag.className = 'harmony-tag';
          
          // Format harmony scheme for display
          let harmonyDisplay = harmonyScheme;
          if (harmonyScheme === 'splitComplementary') {
            harmonyDisplay = 'Split Comp.';
          } else if (harmonyScheme === 'monochromatic') {
            harmonyDisplay = 'Monochrome';
          } else if (harmonyScheme === 'complementary') {
            harmonyDisplay = 'Complement';
          } else if (harmonyScheme === 'analogous') {
            harmonyDisplay = 'Analogous';
          } else if (harmonyScheme === 'triadic') {
            harmonyDisplay = 'Triadic';
          } else if (harmonyScheme === 'tetradic') {
            harmonyDisplay = 'Tetradic';
          } else if (harmonyScheme === 'square') {
            harmonyDisplay = 'Square';
          } else if (harmonyScheme === 'normal') {
            harmonyDisplay = 'Standard';
          }
          
          harmonyTag.textContent = harmonyDisplay;
          shadeTags.appendChild(harmonyTag);
          
          clickableContainer.appendChild(shadeTags);
          
          // NEW: Add preview image container
          const previewContainer = document.createElement('div');
          previewContainer.classList.add('palette-preview-container');
          clickableContainer.appendChild(previewContainer);
          
          // Create small preview canvas
          const previewCanvas = document.createElement('canvas');
          previewCanvas.width = 200;
          previewCanvas.height = 200;
          previewCanvas.classList.add('palette-preview-canvas');
          previewContainer.appendChild(previewCanvas);
          
          // Generate the preview using the new palette
          await generatePreview(previewCanvas, newPalette, paletteIndex);
          
          // NEW: Add swatch container
          const swatchContainer = document.createElement('div');
          swatchContainer.classList.add('swatch-container');
          clickableContainer.appendChild(swatchContainer);

          // Add click handler
          clickableContainer.addEventListener('click', function() {
            try {
              const paletteIndex = parseInt(this.dataset.paletteIndex, 10);
              
              console.log(`Palette clicked: base[${paletteIndex}]`);
              
              // Get the FULL palette from storage
              const fullPalette = window.basePaletteColors[paletteIndex];
              
              if (!fullPalette || fullPalette.length === 0) {
                console.error(`No palette found for base[${paletteIndex}]`);
                return;
              }
              
              // Call processPallet with the FULL palette
              if (typeof window.processPallet === 'function') {
                window.processPallet(null, 1, null, 0, null, fullPalette, 'base', paletteIndex);
              }
            } catch (e) {
              console.error("Error in palette click handler:", e);
            }
          });
          
          // Prepare display colors
          const displayColors = prepareDisplayColors(newPalette);
          
          // Add color swatches
          displayColors.forEach((color, idx) => {
            const swatch = document.createElement('div');
            swatch.classList.add('color-swatch');
            swatch.style.backgroundColor = `rgb(${color.join(',')})`;

            // Convert RGB to HEX for tooltip
            const hexColor = rgbToHex(color[0], color[1], color[2]);

            // Just show the HEX value in tooltip
            swatch.title = hexColor;

            swatch.classList.add('base-swatch');
            swatchContainer.appendChild(swatch);
          });

          // Add "Show All" button
          const showAllButton = document.createElement('div');
          showAllButton.classList.add('show-all-colors-btn');
          showAllButton.innerHTML = '+';
          showAllButton.title = 'Show all colors in palette';
          clickableContainer.appendChild(showAllButton);

          showAllButton.addEventListener('click', function(e) {
            e.stopPropagation();
            showFullPaletteModal(window.basePaletteColors[paletteIndex], 'base', paletteIndex);
          });

        } catch (e) {
          console.error("Error in shuffle button handler:", e);
        }
      });
    });

    // Add event listeners for apply buttons
    document.querySelectorAll('[id^="base_applyButton_"]').forEach(button => {
      const paletteIndex = parseInt(button.id.split('_').pop(), 10);

      // Remove existing click listeners
      const newButton = button.cloneNode(true);
      button.parentNode.replaceChild(newButton, button);

      newButton.addEventListener('click', function(e) {
        e.stopPropagation(); // Prevent triggering palette selection

        try {
          // Get the full palette array
          const fullPalette = window.basePaletteColors[paletteIndex];
          
          if (!fullPalette || fullPalette.length === 0) {
            console.error(`No palette found for base[${paletteIndex}]`);
            return;
          }
          
          console.log(`Applying palette ${paletteIndex} with ${fullPalette.length} colors`);
          
          // Pass the actual palette array to processPallet
          if (typeof window.processPallet === 'function') {
            window.processPallet(null, 1, null, 0, null, fullPalette, 'base', paletteIndex);
          }
        } catch (e) {
          console.error("Error in apply button handler:", e);
        }
      });
    });
    
    // Set up lazy loading for palette previews
    setupLazyLoadingForPalettes();
    
    // Add the necessary CSS if it doesn't exist
    if (!document.getElementById('palette-preview-styles')) {
      const styleElement = document.createElement('style');
      styleElement.id = 'palette-preview-styles';
      styleElement.textContent = `
        .palette-clickable-container {
            display: flex;
            flex-direction: column;
            cursor: pointer;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transition: transform 0.2s, box-shadow 0.2s;
            position: relative;
            width: 200px;
            margin-bottom: 15px;
        }
        
        .palette-clickable-container:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        
        .palette-preview-container {
            width: 200px;
            height: 200px;
            overflow: hidden;
            position: relative;
            background-color: white;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .palette-preview-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.7);
            z-index: 1;
        }
        
        .palette-preview-container::after {
            content: 'Loading...';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #666;
            z-index: 2;
        }
        
        .preview-ready .palette-preview-container::before,
        .preview-ready .palette-preview-container::after {
            display: none;
        }
        
        .palette-preview-canvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        
        .swatch-container {
            display: flex;
            justify-content: space-around;
            padding: 5px;
            background-color: #f5f5f5;
            border-top: 1px solid #ddd;
        }
        
        .color-swatch {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 1px solid #ddd;
            margin: 0 2px;
        }
        
        .ss-swatch {
            border-color: #d0d0ff;
        }
        
        .aw-swatch {
            border-color: #ffd0d0;
        }
        
        .base-swatch {
            border-color: #d0ffd0;
        }
        
        .show-all-colors-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 25px;
            height: 25px;
            background-color: rgba(255,255,255,0.8);
            color: #333;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-weight: bold;
            z-index: 3;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        
        .show-all-colors-btn:hover {
            background-color: rgba(255,255,255,0.95);
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        
        .full-palette-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.7);
        }
        
        .full-palette-modal-content {
            background-color: #fff;
            margin: 10% auto;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            width: 80%;
            max-width: 600px;
            position: relative;
        }
        
        .close-palette-modal {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .palette-modal-title {
            text-align: center;
            margin-bottom: 20px;
            color: #333;
        }
        
        .all-colors-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
        }
        
        .full-palette-color {
            width: 80px;
            height: 80px;
            border-radius: 8px;
            position: relative;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .color-info {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: rgba(0,0,0,0.6);
            color: white;
            font-size: 10px;
            padding: 3px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .full-palette-color:hover .color-info {
            opacity: 1;
        }
        
        .palette-number {
            position: absolute;
            top: 5px;
            left: 5px;
            background-color: rgba(0,0,0,0.6);
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            z-index: 3;
        }
        
        .scheme-tags {
            position: absolute;
            top: 5px;
            right: 34px;
            display: flex;
            gap: 4px;
            z-index: 3;
        }
        
        .shade-tag, .harmony-tag {
            background-color: rgba(0,0,0,0.6);
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            white-space: nowrap;
        }
        
        .harmony-tag {
            background-color: rgba(60,60,120,0.8);
        }
        
        .base-color-filters {
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            align-items: center;
        }
        
        .filter-dropdown {
            min-width: 140px;
        }
        
        .filter-dropdown select {
            width: 100%;
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid #ced4da;
            background-color: white;
        }
      `;
      document.head.appendChild(styleElement);
    }
  } catch (error) {
    console.error("Error in selectBaseColor:", error);
  }
}

// Create base color dropdown filters
function createBaseColorDropdownFilters(baseColor) {
  // Remove any existing filter container
  const existingFilters = document.querySelector('.base-color-filters');
  if (existingFilters) {
    existingFilters.remove();
  }
  
  // Create filter container
  const filterContainer = document.createElement('div');
  filterContainer.className = 'base-color-filters';
  
  // Create filter label for harmony
  const harmonyLabel = document.createElement('div');
  harmonyLabel.className = 'filter-label';
  harmonyLabel.textContent = 'Harmony:';
  
  // Create harmony dropdown
  const harmonyDropdown = document.createElement('div');
  harmonyDropdown.className = 'filter-dropdown harmony-dropdown';
  
  const harmonySelect = document.createElement('select');
  harmonySelect.id = 'harmony-filter';
  harmonySelect.className = 'form-select';
  
  // Add harmony options
  const harmonyOptions = [
    { value: 'all', label: 'All Harmonies' },
    { value: 'normal', label: 'Standard' },
    { value: 'monochromatic', label: 'Monochromatic' },
    { value: 'analogous', label: 'Analogous' },
    { value: 'complementary', label: 'Complementary' },
    { value: 'splitComplementary', label: 'Split Complementary' },
    { value: 'triadic', label: 'Triadic' },
    { value: 'tetradic', label: 'Tetradic' },
    { value: 'square', label: 'Square' }
  ];
  
  harmonyOptions.forEach(option => {
    const optionElement = document.createElement('option');
    optionElement.value = option.value;
    optionElement.textContent = option.label;
    harmonySelect.appendChild(optionElement);
  });
  
  harmonyDropdown.appendChild(harmonySelect);
  
  // Create filter label for shade
  const shadeLabel = document.createElement('div');
  shadeLabel.className = 'filter-label';
  shadeLabel.textContent = 'Shade:';
  
  // Create shade dropdown
  const shadeDropdown = document.createElement('div');
  shadeDropdown.className = 'filter-dropdown shade-dropdown';
  
  const shadeSelect = document.createElement('select');
  shadeSelect.id = 'shade-filter';
  shadeSelect.className = 'form-select';
  
  // Add shade options
  const shadeOptions = [
    { value: 'all', label: 'All Shades' },
    { value: 'faint', label: 'Faint' },
    { value: 'regular', label: 'Regular' },
    { value: 'dark', label: 'Dark' }
  ];
  
  shadeOptions.forEach(option => {
    const optionElement = document.createElement('option');
    optionElement.value = option.value;
    optionElement.textContent = option.label;
    shadeSelect.appendChild(optionElement);
  });
  
  shadeDropdown.appendChild(shadeSelect);
  
  // Add event listeners to dropdowns
  harmonySelect.addEventListener('change', function() {
    applyFilters(this.value, shadeSelect.value, baseColor);
  });
  
  shadeSelect.addEventListener('change', function() {
    applyFilters(harmonySelect.value, this.value, baseColor);
  });
  
  // Add all elements to filter container
  filterContainer.appendChild(harmonyLabel);
  filterContainer.appendChild(harmonyDropdown);
  filterContainer.appendChild(shadeLabel);
  filterContainer.appendChild(shadeDropdown);
  
  // Add filter container before the palettes container
  const palettesSection = document.querySelector('.base-palettes-section');
  if (palettesSection) {
    const palettesContainer = palettesSection.querySelector('.base-palettes-container');
    palettesSection.insertBefore(filterContainer, palettesContainer);
  }
}

// Apply filters to the displayed palettes
function applyFilters(harmonyFilter, shadeFilter, baseColor) {
  console.log(`Applying filters - Harmony: ${harmonyFilter}, Shade: ${shadeFilter}`);
  
  // Get all palette rows
  const paletteRows = document.querySelectorAll('.palette-row');
  let visibleCount = 0;
  
  paletteRows.forEach(row => {
    // Get the palette's shade category and harmony scheme
    const shadeCategory = row.dataset.shadeCategory || 'regular';
    const harmonyScheme = row.dataset.harmonyScheme || 'normal';
    
    // Show or hide based on filters
    const matchesShade = shadeFilter === 'all' || shadeFilter === shadeCategory;
    const matchesHarmony = harmonyFilter === 'all' || harmonyFilter === harmonyScheme;
    
    if (matchesShade && matchesHarmony) {
      row.style.display = 'flex';
      visibleCount++;
    } else {
      row.style.display = 'none';
    }
  });
  
  console.log(`Filters applied - ${visibleCount} palettes visible`);
}

// Add a function to let users select which color is the background
function selectBackgroundColor(originalColors) {
  // Create a modal for selecting background color
  let modal = document.getElementById('background-color-modal');
  
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'background-color-modal';
    modal.classList.add('modal', 'fade');
    modal.setAttribute('tabindex', '-1');
    modal.setAttribute('role', 'dialog');
    modal.setAttribute('aria-labelledby', 'backgroundColorModalLabel');
    modal.setAttribute('aria-hidden', 'true');
    
    modal.innerHTML = `
      <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="backgroundColorModalLabel">Select Background Color</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <p>Click on the color you want to use as the background color:</p>
            <div id="background-color-options" class="d-flex flex-wrap gap-2 justify-content-center"></div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
            <button type="button" class="btn btn-primary" id="auto-detect-bg">Auto-detect</button>
          </div>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
  }
  
  // Clear existing color options
  const colorOptionsContainer = document.getElementById('background-color-options');
  colorOptionsContainer.innerHTML = '';
  
  // Create color swatches for each original color
  originalColors.forEach((color, index) => {
    const colorSwatch = document.createElement('div');
    colorSwatch.classList.add('background-color-option');
    colorSwatch.style.width = '50px';
    colorSwatch.style.height = '50px';
    colorSwatch.style.backgroundColor = `rgb(${color.join(',')})`;
    colorSwatch.style.cursor = 'pointer';
    colorSwatch.style.border = '2px solid #ddd';
    colorSwatch.style.borderRadius = '4px';
    
    // Get color name for tooltip
    const colorName = getColorName(color);
    colorSwatch.title = `${colorName} (${index + 1})`;
    
    // Add data attribute to store color index
    colorSwatch.dataset.colorIndex = index;
    
    // Add click handler
    colorSwatch.addEventListener('click', function() {
      // Remove selection styling from all swatches
      document.querySelectorAll('.background-color-option').forEach(swatch => {
        swatch.style.border = '2px solid #ddd';
      });
      
      // Add selection styling to clicked swatch
      this.style.border = '3px solid #007bff';
      
      // Store selected background color index
      window.selectedBackgroundColorIndex = parseInt(this.dataset.colorIndex, 10);
    });
    
    colorOptionsContainer.appendChild(colorSwatch);
  });
  
  // Add auto-detect handler
  document.getElementById('auto-detect-bg').addEventListener('click', function() {
    // Auto-detect background color (largest area or most frequent color)
    // For now, just use the first color as default
    window.selectedBackgroundColorIndex = 0;
    
    // Close the modal
    const bsModal = bootstrap.Modal.getInstance(modal);
    if (bsModal) {
      bsModal.hide();
    }
  });
  
  // Show the modal
  const bsModal = new bootstrap.Modal(modal);
  bsModal.show();
  
  // Return a promise that resolves when a color is selected
  return new Promise((resolve) => {
    modal.addEventListener('hidden.bs.modal', function() {
      resolve(window.selectedBackgroundColorIndex !== undefined ? window.selectedBackgroundColorIndex : 0);
    });
  });
}


function setupLazyLoadingForPalettes() {
  // Remove pagination controls if they exist
  const paginationContainer = document.querySelector('.palette-pagination');
  if (paginationContainer) {
    paginationContainer.remove();
  }
  
  // Show all palette rows
  document.querySelectorAll('.palette-row').forEach(row => {
    row.style.display = 'flex';
  });
  
  // Set up IntersectionObserver to load previews only when they become visible
  const previewObserver = new IntersectionObserver((entries, observer) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const container = entry.target;
        const previewCanvas = container.querySelector('.palette-preview-canvas');
        const paletteIndex = parseInt(container.dataset.paletteIndex, 10);
        
        if (previewCanvas && window.basePaletteColors && window.basePaletteColors[paletteIndex]) {
          const paletteColors = window.basePaletteColors[paletteIndex];
          
          // Generate the preview
          generatePreview(previewCanvas, paletteColors, paletteIndex);
          
          // Stop observing this container after loading
          observer.unobserve(container);
        }
      }
    });
  }, {
    rootMargin: '200px 0px', // Start loading when within 200px of viewport
    threshold: 0.01
  });
  
  // Start observing all palette containers
  document.querySelectorAll('.palette-clickable-container').forEach(container => {
    previewObserver.observe(container);
    
    // Add a placeholder instead of immediately loading
    const previewCanvas = container.querySelector('.palette-preview-canvas');
    if (previewCanvas) {
      const ctx = previewCanvas.getContext('2d');
      ctx.fillStyle = '#f8f8f8';
      ctx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
      
      // Add a visual indicator that this will load
      ctx.fillStyle = '#cccccc';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = '14px sans-serif';
      ctx.fillText('Preview will load when visible', previewCanvas.width/2, previewCanvas.height/2);
    }
  });
  
  // Add a scroll to top button for better navigation
  const scrollButton = document.createElement('button');
  scrollButton.className = 'scroll-to-top-btn';
  scrollButton.innerHTML = '↑';
  scrollButton.title = 'Scroll to top';
  scrollButton.style.cssText = `
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background-color: rgba(0,123,255,0.8);
    color: white;
    font-size: 20px;
    border: none;
    cursor: pointer;
    display: none;
    z-index: 1000;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
  `;
  
  document.body.appendChild(scrollButton);
  
  // Show/hide scroll button based on scroll position
  window.addEventListener('scroll', () => {
    if (document.documentElement.scrollTop > 300) {
      scrollButton.style.display = 'block';
    } else {
      scrollButton.style.display = 'none';
    }
  });
  
  // Add click handler for scroll button
  scrollButton.addEventListener('click', () => {
    window.scrollTo({
      top: 0,
      behavior: 'smooth'
    });
  });
  
  // Add a "loading more palettes" indicator at the bottom
  const loadingIndicator = document.createElement('div');
  loadingIndicator.className = 'palettes-loading-indicator';
  loadingIndicator.style.cssText = `
    text-align: center;
    padding: 20px;
    color: #666;
    font-style: italic;
  `;
  loadingIndicator.textContent = 'Loading more palettes as you scroll...';
  
  const palettesContainer = document.querySelector('.base-palettes-container');
  if (palettesContainer) {
    palettesContainer.parentNode.appendChild(loadingIndicator);
    
    // Set up observer to hide the loading indicator when all palettes are loaded
    const loadingObserver = new IntersectionObserver((entries) => {
      if (entries[0].isIntersecting) {
        // When we see the loading indicator in view, check if all palettes are loaded
        const notLoadedPalettes = document.querySelectorAll('.palette-clickable-container:not(.preview-ready)');
        
        if (notLoadedPalettes.length === 0) {
          // All palettes loaded, hide the indicator
          loadingIndicator.textContent = 'All palettes loaded!';
          setTimeout(() => {
            loadingIndicator.style.display = 'none';
          }, 2000);
          
          loadingObserver.disconnect();
        }
      }
    });
    
    loadingObserver.observe(loadingIndicator);
  }
}




// Modified generateBaseColors function to restore filter preference
function generateBaseColors() {
  const baseColorsGrid = document.querySelector('.base-colors-grid');
  
  // Convert RGB to Hex helper function
  function rgbToHex(r, g, b) {
    return '#' + [r, g, b].map(x => {
      const hex = x.toString(16);
      return hex.length === 1 ? '0' + hex : hex;
    }).join('');
  }
  
  // Clear existing content
  baseColorsGrid.innerHTML = '';
  
  // 24 predefined colors with names
  const baseColors = [
    { name: "Red", red: 255, green: 0, blue: 0 },
    { name: "Orange", red: 255, green: 165, blue: 0 },
    { name: "Yellow", red: 255, green: 255, blue: 0 },
    { name: "Lime", red: 0, green: 255, blue: 0 },
    { name: "Green", red: 0, green: 128, blue: 0 },
    { name: "Teal", red: 0, green: 128, blue: 128 },
    { name: "Cyan", red: 0, green: 255, blue: 255 },
    { name: "Blue", red: 0, green: 0, blue: 255 },
    { name: "Navy", red: 0, green: 0, blue: 128 },
    { name: "Purple", red: 128, green: 0, blue: 128 },
    { name: "Magenta", red: 255, green: 0, blue: 255 },
    { name: "Pink", red: 255, green: 192, blue: 203 },
    { name: "Brown", red: 165, green: 42, blue: 42 },
    { name: "Maroon", red: 128, green: 0, blue: 0 },
    { name: "Olive", red: 128, green: 128, blue: 0 },
    { name: "Gold", red: 255, green: 215, blue: 0 },
    { name: "Silver", red: 192, green: 192, blue: 192 },
    { name: "Gray", red: 128, green: 128, blue: 128 },
    { name: "Black", red: 0, green: 0, blue: 0 },
    { name: "White", red: 255, green: 255, blue: 255 },
    { name: "Coral", red: 255, green: 127, blue: 80 },
    { name: "Indigo", red: 75, green: 0, blue: 130 },
    { name: "Turquoise", red: 64, green: 224, blue: 208 },
    { name: "Lavender", red: 230, green: 230, blue: 250 }
  ];
  
  baseColors.forEach(color => {
    const colorBlock = document.createElement('div');
    colorBlock.className = 'base-color-block';
    
    // Convert color data to RGB array
    const rgb = [color.red, color.green, color.blue];
    colorBlock.style.backgroundColor = `rgb(${rgb.join(',')})`;
    
    // Convert RGB to HEX for display
    const hexColor = rgbToHex(rgb[0], rgb[1], rgb[2]);
    
    // Display the color name
    colorBlock.innerHTML = `<div class="color-name">${color.name}</div>`;
    
    // Add title attribute with hex code for tooltip
    colorBlock.title = `${color.name}: ${hexColor}`;
    
    // Handle color selection
    colorBlock.addEventListener('click', () => selectBaseColor(rgb));
    
    baseColorsGrid.appendChild(colorBlock);
  });

  // Initially hide the palettes section
  const basePalettesSection = document.querySelector('.base-palettes-section');
  if (basePalettesSection) {
    basePalettesSection.style.display = 'none';
  }
}

function resetBaseColorView() {
  // Show the base colors grid
  const baseColorsGrid = document.querySelector('.base-colors-grid');
  baseColorsGrid.style.display = 'grid';
  
  // Remove any existing filter container
  const filterContainer = document.querySelector('.base-color-filters');
  if (filterContainer) {
    filterContainer.remove();
  }
  
  // Hide the palettes section
  const basePalettesSection = document.querySelector('.base-palettes-section');
  if (basePalettesSection) {
    basePalettesSection.style.display = 'none';
  }
  
  // Reset the header text
  const headerElement = document.querySelector('#baseColorContent h4');
  if (headerElement) {
    headerElement.textContent = 'Base Colors';
  }
  
  // Remove the back button
  const backButton = document.querySelector('.back-to-base-colors');
  if (backButton) {
    backButton.remove();
  }
}



{% comment %} mockups  {% endcomment %}
// Add this to your JavaScript section

document.addEventListener('DOMContentLoaded', function() {
    // Set up event handlers for mockup apply buttons
    document.querySelectorAll('.apply-mockup-btn').forEach(button => {
        button.addEventListener('click', function() {
            const mockupId = this.closest('.mockup-item').dataset.mockupId;
            const mockupImg = this.closest('.mockup-item').querySelector('img').src;
            const mockupName = this.closest('.mockup-item').querySelector('.mockup-name').textContent;
            applyMockupOverlay(mockupId, mockupImg, mockupName);
        });
    });

    // Add mockups button handler to the existing navigation structure
    const mockupsButton = document.getElementById('mockupsButton');
    if (mockupsButton) {
        mockupsButton.addEventListener('click', function(e) {
            e.preventDefault();
            
            // Set this button as active
            const navButtons = document.querySelectorAll('.mostLeftUl li a');
            navButtons.forEach(button => {
                button.classList.remove('active');
            });
            this.classList.add('active');
            
            // Make sure secondaryColumn is visible
            const secondaryColumn = document.getElementById('secondaryColumn');
            secondaryColumn.style.display = 'flex';
            
            // Hide all content sections inside secondaryColumn
            const contentSections = document.querySelectorAll('#secondaryColumn .sidebar-content');
            contentSections.forEach(content => {
                if (content) content.style.display = 'none';
            });
            
            // Show the mockups content
            const mockupsContent = document.getElementById('mockupsContent');
            if (mockupsContent) {
                mockupsContent.style.display = 'block';
            }
            
            // If the sidebar is collapsed, uncollapse it
            if (secondaryColumn.classList.contains('collapsed')) {
                const toggleButton = secondaryColumn.querySelector('button');
                toggleSidebar('secondaryColumn', toggleButton);
            }
        });
    }
});

// Helper function to add the new layer to the layers panel in the right sidebar
// Helper function to add the new layer to the layers panel in the right sidebar
function addLayerToPanel(layerId, layerName, thumbnailSrc) {
    // Get the layer toggles container from the right sidebar specifically
    const layerToggles = document.querySelector('#rightSidebar .layer-toggles');
    if (!layerToggles) {
      console.error('Right sidebar layer toggles not found');
      return;
    }
  
    // Create new layer toggle item
    const layerItem = document.createElement('div');
    layerItem.className = 'layer-toggle-item';
    layerItem.id = `layer-toggle-${layerId}`;
  
    // Create thumbnail
    const thumbnail = document.createElement('img');
    thumbnail.className = 'thumbnail';
    thumbnail.src = thumbnailSrc;
    thumbnail.alt = layerName + ' Thumbnail';
  
    // Create layer name
    const nameSpan = document.createElement('span');
    nameSpan.className = 'layer-name';
    nameSpan.textContent = layerName;
  
    // Create visibility toggle
    const toggle = document.createElement('input');
    toggle.type = 'checkbox';
    toggle.id = `toggleLayer${layerId}`;
    toggle.checked = true;
    toggle.addEventListener('change', function() {
      const layerDiv = document.getElementById(`layer_${layerId}`);
      if (layerDiv) {
        layerDiv.style.display = this.checked ? 'block' : 'none';
      }
    });
  
    // Add select functionality
    layerItem.addEventListener('click', function(e) {
      if (e.target !== toggle) { // Don't select when clicking the checkbox
        selectLayer(layerId);
      }
    });
  
    // Assemble the layer item
    layerItem.appendChild(thumbnail);
    layerItem.appendChild(nameSpan);
    layerItem.appendChild(toggle);
  
    // Add to the right sidebar layers panel (at the top)
    if (layerToggles.firstChild) {
      layerToggles.insertBefore(layerItem, layerToggles.firstChild);
    } else {
      layerToggles.appendChild(layerItem);
    }
  }
function applyMockupOverlay(mockupId, mockupUrl, mockupName) {
    console.log(`Applying mockup overlay: ${mockupId} - ${mockupName}`);
  
    // Get the canvas container
    const canvasContainer = document.querySelector('.canvas-container');
    const zoomWrapper = document.getElementById('zoomWrapper') || canvasContainer.parentElement;
  
    // Create loader
    const loader = document.createElement('div');
    loader.id = 'mockup-loader';
    loader.innerHTML = `<div class="spinner-border text-primary" role="status"><span class="visually-hidden">Loading mockup...</span></div>`;
    loader.style.position = 'absolute';
    loader.style.top = '50%';
    loader.style.left = '50%';
    loader.style.transform = 'translate(-50%, -50%)';
    loader.style.zIndex = '1000';
  
    zoomWrapper.appendChild(loader);
  
    // First, combine all visible layers to get the design
    const designCanvas = createCombinedDesignCanvas();
  
    // Then load the mockup template
    const mockupImg = new Image();
    mockupImg.crossOrigin = 'Anonymous';
  
    mockupImg.onload = function() {
      // Remove loader
      document.getElementById('mockup-loader')?.remove();
  
      // Apply design to mockup as floating element
      createFloatingMockup(designCanvas, mockupImg, mockupName, mockupId);
    };
  
    mockupImg.onerror = function() {
      document.getElementById('mockup-loader')?.remove();
      console.error('Error loading mockup image');
      alert('Failed to load the mockup image. Please try again.');
    };
  
    mockupImg.src = mockupUrl;
  }
  
  // Function to create a floating mockup
  function createFloatingMockup(designCanvas, mockupImg, mockupName, mockupId) {
    // Create a temporary canvas for analyzing the mockup
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = mockupImg.width;
    tempCanvas.height = mockupImg.height;
    const tempCtx = tempCanvas.getContext('2d');
    tempCtx.drawImage(mockupImg, 0, 0);
  
    // Analyze the mockup to find transparent/mask areas
    const maskData = findMaskArea(tempCanvas);
  
    // Create output canvas with mockup dimensions
    const outputCanvas = document.createElement('canvas');
    outputCanvas.width = mockupImg.width;
    outputCanvas.height = mockupImg.height;
    const outputCtx = outputCanvas.getContext('2d');
  
    // First draw the design (scaled to fit the mask area)
    if (maskData.hasMask) {
      // Scale design to fit the mask area
      const scaledDesign = scaleDesignToFitArea(designCanvas, maskData.maskArea);
  
      // Draw the design onto the mask area
      outputCtx.drawImage(
        scaledDesign,
        0, 0, scaledDesign.width, scaledDesign.height,
        maskData.maskArea.x, maskData.maskArea.y,
        maskData.maskArea.width, maskData.maskArea.height
      );
    } else {
      // If no mask found, center the design at 40% of mockup size
      const designWidth = mockupImg.width * 0.4;
      const designHeight = mockupImg.height * 0.4;
      const centerX = (mockupImg.width - designWidth) / 2;
      const centerY = (mockupImg.height - designHeight) / 2;
  
      outputCtx.drawImage(designCanvas, centerX, centerY, designWidth, designHeight);
    }
  
    // Apply the mockup with transparency/mask on top
    applyMockupWithTransparency(outputCtx, mockupImg);
  
    // Create floating mockup element
    createFloatingElement(outputCanvas, mockupName, mockupId);
  }
  
  // Function to create floating element
  function createFloatingElement(canvas, mockupName, mockupId) {
    // Check if there's already a floating mockup with the same ID
    const existingMockup = document.getElementById(`floating-mockup-${mockupId}`);
    if (existingMockup) {
      existingMockup.remove();
    }
  
    // Create container for the floating mockup
    const floatingMockup = document.createElement('div');
    floatingMockup.id = `floating-mockup-${mockupId}`;
    floatingMockup.className = 'floating-mockup';
    floatingMockup.style.position = 'absolute';
    floatingMockup.style.top = '50%';
    floatingMockup.style.left = '50%';
    floatingMockup.style.transform = 'translate(-50%, -50%)';
    floatingMockup.style.boxShadow = '0 5px 15px rgba(0,0,0,0.3)';
    floatingMockup.style.borderRadius = '4px';
    floatingMockup.style.zIndex = '1000';
    floatingMockup.style.cursor = 'move';
    floatingMockup.style.maxWidth = '90%';
    floatingMockup.style.maxHeight = '90%';
    floatingMockup.style.userSelect = 'none';
  
    // Create the image from canvas
    const img = document.createElement('img');
    img.src = canvas.toDataURL('image/png');
    img.alt = mockupName;
    img.style.width = '100%';
    img.style.height = '100%';
    img.style.objectFit = 'contain';
    img.style.pointerEvents = 'none';
  
    // Create controls bar
    const controlsBar = document.createElement('div');
    controlsBar.className = 'mockup-controls';
    controlsBar.style.position = 'absolute';
    controlsBar.style.top = '0';
    controlsBar.style.right = '0';
    controlsBar.style.backgroundColor = 'rgba(0,0,0,0.5)';
    controlsBar.style.padding = '5px';
    controlsBar.style.borderBottomLeftRadius = '4px';
    controlsBar.style.display = 'flex';
    controlsBar.style.gap = '5px';
  
    // Add title
    const title = document.createElement('div');
    title.textContent = mockupName;
    title.style.color = 'white';
    title.style.padding = '0 8px';
    title.style.fontSize = '12px';
    title.style.lineHeight = '24px';
    title.style.whiteSpace = 'nowrap';
    title.style.overflow = 'hidden';
    title.style.textOverflow = 'ellipsis';
    title.style.maxWidth = '150px';
  
    // Add add-to-canvas button
    const addButton = document.createElement('button');
    addButton.innerHTML = '<i class="fas fa-plus"></i> Add';
    addButton.title = 'Add to canvas';
    addButton.style.backgroundColor = '#4CAF50';
    addButton.style.color = 'white';
    addButton.style.border = 'none';
    addButton.style.padding = '2px 8px';
    addButton.style.borderRadius = '3px';
    addButton.style.cursor = 'pointer';
    addButton.style.fontSize = '12px';

  
    // Add close button
    const closeButton = document.createElement('button');
    closeButton.innerHTML = '<i class="fas fa-times"></i>';
    closeButton.title = 'Close';
    closeButton.style.backgroundColor = '#F44336';
    closeButton.style.color = 'white';
    closeButton.style.border = 'none';
    closeButton.style.padding = '2px 8px';
    closeButton.style.borderRadius = '3px';
    closeButton.style.cursor = 'pointer';
    closeButton.style.fontSize = '12px';
    closeButton.onclick = function(e) {
      e.stopPropagation();
      floatingMockup.remove();
    };
  
    // Add download button
    const downloadButton = document.createElement('button');
    downloadButton.innerHTML = '<i class="fas fa-download"></i>';
    downloadButton.title = 'Download';
    downloadButton.style.backgroundColor = '#2196F3';
    downloadButton.style.color = 'white';
    downloadButton.style.border = 'none';
    downloadButton.style.padding = '2px 8px';
    downloadButton.style.borderRadius = '3px';
    downloadButton.style.cursor = 'pointer';
    downloadButton.style.fontSize = '12px';
    downloadButton.onclick = function(e) {
      e.stopPropagation();
      
      // Create a download link
      const link = document.createElement('a');
      link.download = `${mockupName.replace(/\s+/g, '-').toLowerCase()}.png`;
      link.href = canvas.toDataURL('image/png');
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    };
  
    // Assemble the controls
    controlsBar.appendChild(title);
    controlsBar.appendChild(downloadButton);
    controlsBar.appendChild(addButton);
    controlsBar.appendChild(closeButton);
  
    // Add elements to the floating mockup
    floatingMockup.appendChild(img);
    floatingMockup.appendChild(controlsBar);
  
    // Add to DOM - use a parent that persists across different views
    const appRoot = document.getElementById('app') || document.body;
    appRoot.appendChild(floatingMockup);
  
    // Make the floating mockup draggable
    makeDraggable(floatingMockup);
  
    // Show success message
    showToast('Mockup preview created! Click "Add" to add it to your canvas.', 'success');
  }
  
  // Function to make an element draggable
  function makeDraggable(element) {
    let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
    
    element.onmousedown = dragMouseDown;
  
    function dragMouseDown(e) {
      e = e || window.event;
      e.preventDefault();
      
      // Don't start drag if clicking on a button
      if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
        return;
      }
      
      // Get the mouse cursor position at startup
      pos3 = e.clientX;
      pos4 = e.clientY;
      document.onmouseup = closeDragElement;
      document.onmousemove = elementDrag;
      
      // Add active class
      element.classList.add('dragging');
    }
  
    function elementDrag(e) {
      e = e || window.event;
      e.preventDefault();
      
      // Calculate the new cursor position
      pos1 = pos3 - e.clientX;
      pos2 = pos4 - e.clientY;
      pos3 = e.clientX;
      pos4 = e.clientY;
      
      // Set the element's new position
      const top = (element.offsetTop - pos2);
      const left = (element.offsetLeft - pos1);
      
      element.style.top = top + "px";
      element.style.left = left + "px";
      element.style.transform = 'none'; // Remove the translate once we start dragging
    }
  
    function closeDragElement() {
      // Stop moving when mouse button is released
      document.onmouseup = null;
      document.onmousemove = null;
      
      // Remove active class
      element.classList.remove('dragging');
    }
  }
  
  // Function to find mask area in a mockup
  function findMaskArea(mockupCanvas) {
    const ctx = mockupCanvas.getContext('2d');
    const imageData = ctx.getImageData(0, 0, mockupCanvas.width, mockupCanvas.height);
    const data = imageData.data;
  
    const transparentPoints = [];
  
    // Check for transparent areas (alpha < 50)
    for (let y = 0; y < mockupCanvas.height; y++) {
      for (let x = 0; x < mockupCanvas.width; x++) {
        const idx = (y * mockupCanvas.width + x) * 4;
        if (data[idx + 3] < 50) {
          transparentPoints.push({ x, y });
        }
      }
    }
  
    // If we found transparent areas
    if (transparentPoints.length > 0) {
      // Calculate bounding box of transparent area
      const maskArea = calculateBoundingBox(transparentPoints, mockupCanvas.width, mockupCanvas.height);
  
      return {
        hasMask: true,
        maskArea: maskArea
      };
    }
  
    // If no transparent area found, look for a specific color that might indicate a mask
    // This is a fallback if the mockup uses a solid color instead of transparency
  
    // For now, let's use white as a fallback mask color (you can customize this)
    const whitePoints = [];
    const whiteThreshold = 245; // Threshold to consider a pixel "white"
  
    for (let y = 0; y < mockupCanvas.height; y++) {
      for (let x = 0; x < mockupCanvas.width; x++) {
        const idx = (y * mockupCanvas.width + x) * 4;
        if (data[idx] > whiteThreshold &&
            data[idx + 1] > whiteThreshold &&
            data[idx + 2] > whiteThreshold &&
            data[idx + 3] > 240) { // Fully opaque white
          whitePoints.push({ x, y });
        }
      }
    }
  
    if (whitePoints.length > 0) {
      // Must be at least 10% of the image to be considered a valid mask
      if (whitePoints.length > (mockupCanvas.width * mockupCanvas.height * 0.1)) {
        const maskArea = calculateBoundingBox(whitePoints, mockupCanvas.width, mockupCanvas.height);
        return {
          hasMask: true,
          maskArea: maskArea
        };
      }
    }
  
    // No mask found
    return {
      hasMask: false,
      maskArea: {
        x: 0,
        y: 0,
        width: mockupCanvas.width,
        height: mockupCanvas.height
      }
    };
  }
  
  // Apply mockup with preserved transparency
  function applyMockupWithTransparency(outputCtx, mockupImg) {
    // Create a temporary canvas
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = mockupImg.width;
    tempCanvas.height = mockupImg.height;
    const tempCtx = tempCanvas.getContext('2d');
  
    // Draw the mockup
    tempCtx.drawImage(mockupImg, 0, 0);
  
    // Get mockup image data
    const mockupImageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
    const mockupData = mockupImageData.data;
  
    // Get current output canvas data
    const outputImageData = outputCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
    const outputData = outputImageData.data;
  
    // Blend the images, preserving mockup transparency
    for (let i = 0; i < mockupData.length; i += 4) {
      const alpha = mockupData[i + 3] / 255;
  
      // If mockup pixel is opaque, use mockup color
      if (alpha > 0.8) {
        outputData[i] = mockupData[i]; // R
        outputData[i + 1] = mockupData[i + 1]; // G
        outputData[i + 2] = mockupData[i + 2]; // B
        outputData[i + 3] = 255; // A (fully opaque)
      }
      // If mockup pixel is semi-transparent, blend with design
      else if (alpha > 0) {
        outputData[i] = outputData[i] * (1 - alpha) + mockupData[i] * alpha;
        outputData[i + 1] = outputData[i + 1] * (1 - alpha) + mockupData[i + 1] * alpha;
        outputData[i + 2] = outputData[i + 2] * (1 - alpha) + mockupData[i + 2] * alpha;
        // Alpha channel remains the same (from the design)
      }
      // If mockup pixel is fully transparent, keep the design pixel as is
    }
  
    // Put the blended data back to output canvas
    outputCtx.putImageData(outputImageData, 0, 0);
  }
  
  // Create combined design canvas from all visible layers
  function createCombinedDesignCanvas() {
    // Get all visible layers
    const layers = document.querySelectorAll('.layer');
  
    if (layers.length === 0) {
      console.error('No layers found');
      return null;
    }
  
    // Create a canvas to hold the combined design
    const designCanvas = document.createElement('canvas');
  
    // Find the first canvas to get dimensions
    const firstCanvas = document.querySelector('canvas[id^="layer_canvas_"]');
    if (!firstCanvas) {
      console.error('No canvas elements found');
      return null;
    }
  
    designCanvas.width = firstCanvas.width;
    designCanvas.height = firstCanvas.height;
    const designCtx = designCanvas.getContext('2d');
  
    // Draw all visible layers onto the design canvas
    layers.forEach(layer => {
      // Check if layer is visible
      const layerId = layer.id.replace('layer_', '');
      const toggle = document.getElementById(`toggleLayer${layerId}`);
  
      // If toggle doesn't exist or is checked
      if (!toggle || toggle.checked) {
        const canvas = layer.querySelector('canvas');
        if (canvas) {
          // Get layer position
          const top = parseInt(layer.style.top) || 0;
          const left = parseInt(layer.style.left) || 0;
  
          // Draw the layer at its position
          designCtx.drawImage(canvas, left, top);
        }
      }
    });
  
    return designCanvas;
  }
  
  // Calculate bounding box for a set of points
  function calculateBoundingBox(points, canvasWidth, canvasHeight) {
    if (points.length === 0) return { x: 0, y: 0, width: canvasWidth, height: canvasHeight };
  
    let minX = canvasWidth, minY = canvasHeight, maxX = 0, maxY = 0;
  
    points.forEach(point => {
      minX = Math.min(minX, point.x);
      minY = Math.min(minY, point.y);
      maxX = Math.max(maxX, point.x);
      maxY = Math.max(maxY, point.y);
    });
  
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  
  // Scale and crop design to fit the target area
  function scaleDesignToFitArea(designCanvas, targetArea) {
    // Create a new canvas for the scaled design
    const scaledCanvas = document.createElement('canvas');
    scaledCanvas.width = targetArea.width;
    scaledCanvas.height = targetArea.height;
    const ctx = scaledCanvas.getContext('2d');
  
    // Calculate scaling to maintain aspect ratio
    const designRatio = designCanvas.width / designCanvas.height;
    const targetRatio = targetArea.width / targetArea.height;
  
    let sourceX = 0, sourceY = 0;
    let sourceWidth = designCanvas.width;
    let sourceHeight = designCanvas.height;
  
    if (designRatio > targetRatio) {
      // Design is wider than target area
      sourceWidth = designCanvas.height * targetRatio;
      sourceX = (designCanvas.width - sourceWidth) / 2;
    } else {
      // Design is taller than target area
      sourceHeight = designCanvas.width / targetRatio;
      sourceY = (designCanvas.height - sourceHeight) / 2;
    }
  
    // Draw the scaled design
    ctx.drawImage(
      designCanvas,
      sourceX, sourceY, sourceWidth, sourceHeight,
      0, 0, targetArea.width, targetArea.height
    );
  
    return scaledCanvas;
  }
  
  // Function to create a new layer from a canvas
  function createNewLayerFromCanvas(canvas, layerName) {
    try {
      // Generate a unique layer ID
      const timestamp = new Date().getTime();
      const newLayerId = `mockup_${timestamp}`;
  
      // Create a new canvas for this layer with the same dimensions
      const newCanvas = document.createElement('canvas');
      newCanvas.width = canvas.width;
      newCanvas.height = canvas.height;
      newCanvas.id = `layer_canvas_${newLayerId}`;
  
      // Copy the content from the provided canvas
      const ctx = newCanvas.getContext('2d');
      ctx.drawImage(canvas, 0, 0);
  
      // Create the layer container
      const layerDiv = document.createElement('div');
      layerDiv.id = `layer_${newLayerId}`;
      layerDiv.className = 'layer design-layer';
      layerDiv.style.position = 'absolute';
      layerDiv.style.top = '0';
      layerDiv.style.left = '0';
      layerDiv.style.zIndex = getHighestZIndex() + 1;
  
      // Add the canvas to the layer
      layerDiv.appendChild(newCanvas);
  
      // Add the layer to the canvas container
      const canvasContainer = document.querySelector('.canvas-container');
      canvasContainer.appendChild(layerDiv);
  
      // Create thumbnail for the layer panel
      const thumbnailCanvas = document.createElement('canvas');
      thumbnailCanvas.width = 50;
      thumbnailCanvas.height = 50;
      const thumbCtx = thumbnailCanvas.getContext('2d');
  
      // Draw a scaled down version of the layer content
      thumbCtx.drawImage(canvas, 0, 0, canvas.width, canvas.height, 0, 0, 50, 50);
  
      // Add layer to the layers panel
      addLayerToPanel(newLayerId, 'Mockup: ' + layerName, thumbnailCanvas.toDataURL());
  
      // Make the layer active
      selectLayer(newLayerId);
  
      // Show success message
      showToast('Mockup added to canvas!', 'success');
  
      return layerDiv;
    } catch (error) {
      console.error('Error creating layer from canvas:', error);
      showToast('Error applying mockup: ' + error.message, 'error');
      return null;
    }
  }
  
  // Helper function to get the highest z-index in use
  function getHighestZIndex() {
    const layers = document.querySelectorAll('.layer');
    let highestZ = 0;
  
    layers.forEach(layer => {
      const zIndex = parseInt(layer.style.zIndex) || 0;
      if (zIndex > highestZ) {
        highestZ = zIndex;
      }
    });
  
    return highestZ;
  }
  
  // Helper function to add the new layer to the layers panel
  function addLayerToPanel(layerId, layerName, thumbnailSrc) {
    const layerToggles = document.querySelector('.layer-toggles');
    if (!layerToggles) return;
  
    // Create new layer toggle item
    const layerItem = document.createElement('div');
    layerItem.className = 'layer-toggle-item';
    layerItem.id = `layer-toggle-${layerId}`;
  
    // Create thumbnail
    const thumbnail = document.createElement('img');
    thumbnail.className = 'thumbnail';
    thumbnail.src = thumbnailSrc;
    thumbnail.alt = layerName + ' Thumbnail';
  
    // Create layer name
    const nameSpan = document.createElement('span');
    nameSpan.className = 'layer-name';
    nameSpan.textContent = layerName;
  
    // Create visibility toggle
    const toggle = document.createElement('input');
    toggle.type = 'checkbox';
    toggle.id = `toggleLayer${layerId}`;
    toggle.checked = true;
    toggle.addEventListener('change', function() {
      const layerDiv = document.getElementById(`layer_${layerId}`);
      if (layerDiv) {
        layerDiv.style.display = this.checked ? 'block' : 'none';
      }
    });
  
    // Add select functionality
    layerItem.addEventListener('click', function(e) {
      if (e.target !== toggle) { // Don't select when clicking the checkbox
        selectLayer(layerId);
      }
    });
  
    // Assemble the layer item
    layerItem.appendChild(thumbnail);
    layerItem.appendChild(nameSpan);
    layerItem.appendChild(toggle);
  
    // Add to the layers panel (at the top)
    if (layerToggles.firstChild) {
      layerToggles.insertBefore(layerItem, layerToggles.firstChild);
    } else {
      layerToggles.appendChild(layerItem);
    }
  }
  
  // Helper function to select a layer
// Helper function to select a layer
function selectLayer(layerId) {
    // Deselect all other layers
    document.querySelectorAll('#rightSidebar .layer-toggle-item').forEach(item => {
      item.classList.remove('active');
    });
  
    // Select this layer
    const layerItem = document.getElementById(`layer-toggle-${layerId}`);
    if (layerItem) {
      layerItem.classList.add('active');
    }
  
    // Set this layer as the active one
    window.activeLayerId = layerId;
  
    // You might want to dispatch an event or call a function here to update your UI
    if (typeof updateToolsForActiveLayer === 'function') {
      updateToolsForActiveLayer();
    }
  }
  
  // Helper function to show toast notifications
  function showToast(message, type = 'info') {
    // Check if a toast container exists, create if not
    let toastContainer = document.getElementById('toast-container');
    if (!toastContainer) {
      toastContainer = document.createElement('div');
      toastContainer.id = 'toast-container';
      toastContainer.style.position = 'fixed';
      toastContainer.style.top = '20px';
      toastContainer.style.right = '20px';
      toastContainer.style.zIndex = '9999';
      document.body.appendChild(toastContainer);
    }
  
    // Create toast
    const toast = document.createElement('div');
    toast.className = `toast toast-${type}`;
    toast.style.minWidth = '250px';
    toast.style.margin = '10px';
    toast.style.padding = '15px';
    toast.style.borderRadius = '4px';
    toast.style.boxShadow = '0 2px 10px rgba(0,0,0,0.2)';
    toast.style.backgroundColor = type === 'success' ? '#4caf50' :
                                 type === 'error' ? '#f44336' :
                                 type === 'warning' ? '#ff9800' : '#2196f3';
    toast.style.color = 'white';
    toast.style.animation = 'fadeIn 0.3s, fadeOut 0.3s 2.7s';
    toast.style.animationFillMode = 'forwards';
    toast.innerHTML = message;
  
    // Add animation styles if not already present
    if (!document.getElementById('toast-animations')) {
      const style = document.createElement('style');
      style.id = 'toast-animations';
      style.innerHTML = `@keyframes fadeIn { from {opacity: 0; transform: translateY(-20px);} to {opacity: 1; transform: translateY(0);} } @keyframes fadeOut { from {opacity: 1; transform: translateY(0);} to {opacity: 0; transform: translateY(-20px);} }`;
      document.head.appendChild(style);
    }
  
    // Add toast to container
    toastContainer.appendChild(toast);
  
    // Remove toast after 3 seconds
    setTimeout(() => {
      toast.remove();
    }, 3000);
  }





// Function to convert HSV to RGB
function hsvToRgbBase(h, s, v) {
  let r, g, b;
  const i = Math.floor(h / 60);
  const f = h / 60 - i;
  const p = v * (1 - s);
  const q = v * (1 - f * s);
  const t = v * (1 - (1 - f) * s);
  
  switch (i % 6) {
      case 0: [r, g, b] = [v, t, p]; break;
      case 1: [r, g, b] = [q, v, p]; break;
      case 2: [r, g, b] = [p, v, t]; break;
      case 3: [r, g, b] = [p, q, v]; break;
      case 4: [r, g, b] = [t, p, v]; break;
      case 5: [r, g, b] = [v, p, q]; break;
  }
  
  return [
      Math.round(r * 255),
      Math.round(g * 255),
      Math.round(b * 255)
  ];
}
// Function to reset the base color view
function resetBaseColorView() {
  // Show the base colors grid
  const baseColorsGrid = document.querySelector('.base-colors-grid');
  baseColorsGrid.style.display = 'grid';
  
  // Hide the palettes section
  const basePalettesSection = document.querySelector('.base-palettes-section');
  basePalettesSection.style.display = 'none';
  
  // Reset the header
  const headerElement = document.querySelector('#baseColorContent h4');
  headerElement.textContent = 'Base Colors';
  
  // Remove the back button
  const backButton = document.querySelector('.back-to-base-colors');
  if (backButton) {
      backButton.remove();
  }
}

// Add some CSS for the back button
const backButtonStyle = document.createElement('style');
backButtonStyle.textContent = `
.back-to-base-colors {
  padding: 0.25rem 0.5rem;
  font-size: 0.875rem;
  margin-bottom: 1rem;
}

#baseColorContent h4 {
  margin-bottom: 0.5rem;
}
`;
document.head.appendChild(backButtonStyle);

// Initialize base colors when the page loads
document.addEventListener('DOMContentLoaded', () => {
  generateBaseColors();
  const baseColorButton = document.getElementById('baseColorButton');
  if (baseColorButton) {
      baseColorButton.addEventListener('click', function(e) {
          e.preventDefault();
          setActiveButton(this);
          secondaryColumn.style.display = 'flex';
          showContent('baseColorContent');
          
          // Reset to show base colors when the button is clicked
          resetBaseColorView();
      });
  }
});
{% comment %} base color end  {% endcomment %}


{% comment %} for generating random color pallete  {% endcomment %}
// Function to generate varied colors with preserved relationships but shifted hues
function generateCorrelatedPalettes(distinctColors, collection = 'trending') {
    // Convert RGB array to HSL
    function rgbToHsl(r, g, b) {
      r /= 255; g /= 255; b /= 255;
      const max = Math.max(r, g, b), min = Math.min(r, g, b);
      let h, s, l = (max + min) / 2;
  
      if (max === min) {
        h = s = 0; // achromatic
      } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
          case g: h = ((b - r) / d + 2) / 6; break;
          case b: h = ((r - g) / d + 4) / 6; break;
        }
      }
      return [h, s, l];
    }
  
    // Convert HSL to RGB
    function hslToRgb(h, s, l) {
      let r, g, b;
  
      if (s === 0) {
        r = g = b = l; // achromatic
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1; if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        };
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }
  
      return [
        Math.round(r * 255),
        Math.round(g * 255),
        Math.round(b * 255)
      ];
    }
  
    // Create a palette with shifted hue while preserving relationships
    function createShiftedPalette(colors, hueShift) {
      return colors.map(color => {
        const [h, s, l] = rgbToHsl(color[0], color[1], color[2]);
        
        // Shift the hue while preserving saturation and lightness
        let newHue = (h + hueShift) % 1.0;
        if (newHue < 0) newHue += 1.0;
        
        // Apply collection-specific adjustments
        let newS = s;
        let newL = l;
        
        if (collection === 'ss') {
          // Spring/Summer: Brighter, more saturated
          newS = Math.min(1, s * 1.1);
          newL = Math.min(0.9, l * 1.15);
        } else if (collection === 'aw') {
          // Autumn/Winter: Deeper, more muted
          newS = Math.max(0, s * 0.9);
          newL = Math.max(0.1, l * 0.85);
        }
        
        return hslToRgb(newHue, newS, newL);
      });
    }
    
    // Generate multiple palette variations based on color theory
    const palettes = [];
    
    // Complementary palette (180° hue shift)
    palettes.push(createShiftedPalette(distinctColors, 0.5));
    
    // Analogous palettes (30° and -30° hue shifts)
    palettes.push(createShiftedPalette(distinctColors, 0.083));
    palettes.push(createShiftedPalette(distinctColors, -0.083));
    
    // Triadic palettes (120° and 240° hue shifts)
    palettes.push(createShiftedPalette(distinctColors, 0.33));
    palettes.push(createShiftedPalette(distinctColors, 0.67));
    
    // Split-complementary palettes
    palettes.push(createShiftedPalette(distinctColors, 0.42));
    palettes.push(createShiftedPalette(distinctColors, 0.58));
    
    // Season-inspired shifts
    if (collection === 'ss') {
      // Spring/Summer: Shift toward yellow-green
      palettes.push(createShiftedPalette(distinctColors, 0.2));
      palettes.push(createShiftedPalette(distinctColors, 0.25));
    } else if (collection === 'aw') {
      // Autumn/Winter: Shift toward orange-red
      palettes.push(createShiftedPalette(distinctColors, -0.08));
      palettes.push(createShiftedPalette(distinctColors, -0.04));
    }
    
    // Add some random creative shifts
    for (let i = 0; i < 2; i++) {
      palettes.push(createShiftedPalette(distinctColors, Math.random()));
    }
    
    return palettes;
  }
  

async function displayFavoritePalette(layerIndex, colors, collection = 'fav', maxVisibleColors = 6, totalLayers = 1) {
    console.log(`\n🎨 === DISPLAYING FAVORITE PALETTE ${layerIndex} ===`);
    console.log("🎨 Input colors (first 5):", colors.slice(0, 5));
    console.log("🎨 Total colors:", colors.length);
    console.log("🎨 Collection:", collection);
    
    const prefix = collection + '_';
    
    // Use the same preview generation as trending palettes
    async function generateAndShowPreview(previewCanvas, paletteColors, paletteIndex, collection) {
        try {
            console.log(`🎨 Generating REAL preview for favorite palette ${paletteIndex}`);
            
            // Get the original image
            const originalCanvas = document.getElementById('layer_canvas_1');
            if (!originalCanvas) {
                console.error('No original canvas found for preview');
                drawFallbackPreview(previewCanvas, collection, paletteIndex);
                return;
            }
            
            // Clear the preview canvas with white background
            const ctx = previewCanvas.getContext('2d', { willReadFrequently: true });
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
            
            // Create a temporary high-resolution canvas for processing
            const originalAspect = originalCanvas.width / originalCanvas.height;
            
            const tempCanvas = document.createElement('canvas');
            if (originalAspect > 1) {
                tempCanvas.width = 200;
                tempCanvas.height = Math.round(200 / originalAspect);
            } else {
                tempCanvas.height = 200;
                tempCanvas.width = Math.round(200 * originalAspect);
            }
            
            const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
            tempCtx.drawImage(originalCanvas, 0, 0, tempCanvas.width, tempCanvas.height);
            
            // Get the temp canvas data for processing
            const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            
            // Find original colors from the image
            const originalColors = await getDistinctColors(imageData, 30, 50, 40);
            
            if (!originalColors || originalColors.length === 0) {
                console.error('No original colors found for preview');
                // Draw the original image with correct aspect ratio
                const displayScale = Math.min(
                    previewCanvas.width / tempCanvas.width,
                    previewCanvas.height / tempCanvas.height
                );
                
                const displayWidth = tempCanvas.width * displayScale;
                const displayHeight = tempCanvas.height * displayScale;
                
                const displayX = (previewCanvas.width - displayWidth) / 2;
                const displayY = (previewCanvas.height - displayHeight) / 2;
                
                ctx.drawImage(tempCanvas, displayX, displayY, displayWidth, displayHeight);
                markPreviewReady(previewCanvas);
                return;
            }
            
            // Create color mappings using the palette colors
            const colorMappings = [];
            for (let i = 0; i < Math.min(originalColors.length, paletteColors.length); i++) {
                colorMappings.push({
                    originalColor: originalColors[i],
                    targetColor: paletteColors[i % paletteColors.length]
                });
            }
            
            // Use ColorProcessor for the preview
            const colorProcessor = new ColorProcessor();
            const imageUrl = tempCanvas.toDataURL();
            
            // Process the preview using color replacement
            const processedImageUrl = await colorProcessor.applyMultipleColorMappings(
                imageUrl,
                colorMappings
            );
            
            // Load the processed image back to the preview canvas
            return new Promise((resolve) => {
                const resultImg = new Image();
                resultImg.onload = () => {
                    const displayScale = Math.min(
                        previewCanvas.width / resultImg.width,
                        previewCanvas.height / resultImg.height
                    );
                    
                    const displayWidth = resultImg.width * displayScale;
                    const displayHeight = resultImg.height * displayScale;
                    
                    const displayX = (previewCanvas.width - displayWidth) / 2;
                    const displayY = (previewCanvas.height - displayHeight) / 2;
                    
                    ctx.drawImage(resultImg, displayX, displayY, displayWidth, displayHeight);
                    markPreviewReady(previewCanvas);
                    resolve();
                };
                resultImg.onerror = (e) => {
                    console.error("Error loading processed preview:", e);
                    drawFallbackPreview(previewCanvas, collection, paletteIndex);
                    resolve();
                };
                resultImg.src = processedImageUrl;
            });
            
        } catch (error) {
            console.error("Error generating preview:", error);
            drawFallbackPreview(previewCanvas, collection, paletteIndex);
        }
    }
    
    function markPreviewReady(canvas) {
        const container = canvas.closest('.palette-clickable-container');
        if (container) {
            container.classList.add('preview-ready');
        }
    }
    
    function drawFallbackPreview(canvas, collection, paletteIndex) {
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#f5f5f5';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#999';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.font = '14px sans-serif';
        ctx.fillText('Preview unavailable', canvas.width/2, canvas.height/2);
        markPreviewReady(canvas);
    }
    
    // Function to convert RGB to HEX
    function rgbToHex(r, g, b) {
        return '#' + [r, g, b].map(x => {
            const hex = x.toString(16);
            return hex.length === 1 ? '0' + hex : hex;
        }).join('');
    }
    
    // Validate colors
    const validColors = colors.filter(color => 
        Array.isArray(color) && 
        color.length === 3 && 
        color.every(v => typeof v === 'number' && !isNaN(v) && v >= 0 && v <= 255)
    );
    
    if (validColors.length === 0) {
        console.error("🔴 No valid colors provided to displayFavoritePalette");
        return;
    }
    
    const paletteContainer = document.getElementById(`${prefix}colorPalette_${layerIndex}`);
    if (!paletteContainer) {
        console.error(`🔴 Palette container not found: ${prefix}colorPalette_${layerIndex}`);
        return;
    }
    
    // Clear container
    paletteContainer.innerHTML = '';
    
    // Store the EXACT colors
    if (!window.favPaletteColors) {
        window.favPaletteColors = {};
    }
    window.favPaletteColors[layerIndex] = [...validColors];
    
    // Create the same structure as trending palettes
    const clickableContainer = document.createElement('div');
    clickableContainer.classList.add('palette-clickable-container');
    clickableContainer.style.border = '0px solid #ffd700'; // Gold border for favorites
    paletteContainer.appendChild(clickableContainer);
    
    // Add data attributes
    clickableContainer.dataset.paletteIndex = layerIndex;
    clickableContainer.dataset.collection = collection;
    
    // Add preview image container
    const previewContainer = document.createElement('div');
    previewContainer.classList.add('palette-preview-container');
    clickableContainer.appendChild(previewContainer);
    
    // Create preview canvas
    const previewCanvas = document.createElement('canvas');
    previewCanvas.width = 200;
    previewCanvas.height = 200;
    previewCanvas.classList.add('palette-preview-canvas');
    previewContainer.appendChild(previewCanvas);
    
    // Display color swatches underneath
    const swatchContainer = document.createElement('div');
    swatchContainer.classList.add('swatch-container');
    swatchContainer.style.backgroundColor = '#fff8dc'; // Light gold background
    clickableContainer.appendChild(swatchContainer);
    
    // Show first 8 colors as swatches
    const colorsToShow = validColors.slice(0, 8);
    
    colorsToShow.forEach((color, idx) => {
        const swatch = document.createElement('div');
        swatch.classList.add('color-swatch');
        swatch.style.backgroundColor = `rgb(${color.join(',')})`;
        swatch.style.border = '0px solid #ffd700'; // Gold border
        
        const hexValue = rgbToHex(color[0], color[1], color[2]);
        swatch.title = `Color ${idx + 1}: ${hexValue}`;
        
        swatchContainer.appendChild(swatch);
    });
    
    // Click handler to apply the palette
    clickableContainer.addEventListener('click', function() {
        const paletteIndex = parseInt(this.dataset.paletteIndex, 10);
        const collectionName = this.dataset.collection;
        
        console.log(`🎨 FAVORITE PALETTE CLICKED: Index ${paletteIndex}`);
        
        const fullPalette = window.favPaletteColors[paletteIndex];
        
        if (typeof window.processPallet === 'function' && fullPalette && fullPalette.length > 0) {
            console.log(`🎨 Applying favorite palette with ${fullPalette.length} colors`);
            window.processPallet(null, totalLayers, null, 0, null, fullPalette, paletteIndex, collectionName);
        }
    });
    
    // Add "Show All" button
    const showAllButton = document.createElement('div');
    showAllButton.classList.add('show-all-colors-btn');
    showAllButton.innerHTML = '+';
    showAllButton.title = 'Show all colors in this favorite palette';
    showAllButton.style.backgroundColor = 'rgba(255, 215, 0, 0.9)';
    clickableContainer.appendChild(showAllButton);
    
    showAllButton.addEventListener('click', function(e) {
        e.stopPropagation();
        showFullPaletteModal(window.favPaletteColors[layerIndex], collection, layerIndex);
    });
    
    // Generate the REAL preview (same as trending palettes)
    console.log(`🎨 Starting REAL preview generation for favorite palette ${layerIndex}`);
    generateAndShowPreview(previewCanvas, validColors, layerIndex, collection);
    
    console.log("🎨 === FAVORITE PALETTE DISPLAY COMPLETE ===");
}



// Modal function for showing all palette colors
function showFullPaletteModal(palette, collection, paletteIndex) {
  // Create and append modal elements if they don't exist
  let modal = document.getElementById('full-palette-modal');
  
  if (!modal) {
      modal = document.createElement('div');
      modal.id = 'full-palette-modal';
      modal.classList.add('full-palette-modal');
      
      const modalContent = document.createElement('div');
      modalContent.classList.add('full-palette-modal-content');
      
      const closeBtn = document.createElement('span');
      closeBtn.classList.add('close-palette-modal');
      closeBtn.innerHTML = '&times;';
      
      const modalTitle = document.createElement('h3');
      modalTitle.classList.add('palette-modal-title');
      
      const colorsContainer = document.createElement('div');
      colorsContainer.classList.add('all-colors-container');
      
      modalContent.appendChild(closeBtn);
      modalContent.appendChild(modalTitle);
      modalContent.appendChild(colorsContainer);
      modal.appendChild(modalContent);
      
      document.body.appendChild(modal);
      
      // Add event listener to close button
      closeBtn.addEventListener('click', function() {
          modal.style.display = 'none';
      });
      
      // Close modal when clicking outside content
      window.addEventListener('click', function(event) {
          if (event.target === modal) {
              modal.style.display = 'none';
          }
      });
  }
  
  // Update modal content with current palette
  const modalTitle = modal.querySelector('.palette-modal-title');
  const colorsContainer = modal.querySelector('.all-colors-container');
  
  modalTitle.textContent = `Full Palette (${collection.toUpperCase()} #${paletteIndex+1})`;
  colorsContainer.innerHTML = '';
  
  // Add all colors to the modal
  palette.forEach((color, index) => {
      const colorBox = document.createElement('div');
      colorBox.classList.add('full-palette-color');
      colorBox.style.backgroundColor = `rgb(${color.join(',')})`;
      
      // Add color information
      const colorInfo = document.createElement('div');
      colorInfo.classList.add('color-info');
      colorInfo.textContent = `#${index+1}: RGB(${color.join(',')})`;
      colorBox.appendChild(colorInfo);
      
      colorsContainer.appendChild(colorBox);
  });
  
  // Show the modal
  modal.style.display = 'block';
}



async function processPreviewQueue() {
  // Check if queue exists
  if (typeof window.previewQueue === 'undefined') {
    window.isProcessingPreviewQueue = false;
    return;
  }
  
  // Check if queue is empty
  if (window.previewQueue.length === 0) {
    window.isProcessingPreviewQueue = false;
    return;
  }
  
  window.isProcessingPreviewQueue = true;
  
  // Take the next preview from the queue
  const nextPreview = window.previewQueue.shift();
  
  try {
    // Generate this preview
    await generatePreview(
      nextPreview.previewCanvas, 
      nextPreview.paletteColors, 
      nextPreview.paletteIndex, 
      nextPreview.collection
    );
  } catch (error) {
    console.error("Error processing preview in queue:", error);
  }
  
  // Small delay to prevent UI freezing
  await new Promise(resolve => setTimeout(resolve, 50));
  
  // Process the next preview in the queue
  processPreviewQueue();
}


async function displayColorPalette(layerIndex, colors, collection = 'trending', maxVisibleColors = 6, totalLayers = 1) {
    const prefix = collection + '_';
    const MAX_DISPLAY_COUNT = 8; // Maximum number of colors to display
    const MIN_DISPLAY_COUNT = 4; // Minimum number of colors to display
    
    // Function to convert HEX to RGB
    function hexToRgb(hex) {
        // Remove the # if it exists
        hex = hex.replace(/^#/, '');
        
        // Parse the hex values
        const r = parseInt(hex.substring(0, 2), 16);
        const g = parseInt(hex.substring(2, 4), 16);
        const b = parseInt(hex.substring(4, 6), 16);
        
        return [r, g, b];
    }

    // Function to extract and cache original colors from the image
  async function extractAndCacheOriginalColors(totalLayers) {
      // Check if we already have cached original colors
      if (window.cachedOriginalColors) {
          return window.cachedOriginalColors;
      }
      
      try {
          let originalCanvas;
          
          if (totalLayers === 1) {
              originalCanvas = document.getElementById('layer_canvas_1');
          } else {
              // For multi-layer, we might want to use a combined canvas or the main canvas
              originalCanvas = document.getElementById('layer_canvas_1'); // or combine all layers
          }
          
          if (!originalCanvas) {
              console.error('No original canvas found for color extraction');
              return [];
          }
          
          // Create a temporary canvas for color extraction
          const tempCanvas = document.createElement('canvas');
          tempCanvas.width = 200;
          tempCanvas.height = 200;
          const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
          
          // Scale and draw the original image
          const originalAspect = originalCanvas.width / originalCanvas.height;
          let drawWidth, drawHeight, offsetX = 0, offsetY = 0;
          
          if (originalAspect > 1) {
              drawWidth = 200;
              drawHeight = 200 / originalAspect;
              offsetY = (200 - drawHeight) / 2;
          } else {
              drawHeight = 200;
              drawWidth = 200 * originalAspect;
              offsetX = (200 - drawWidth) / 2;
          }
          
          tempCtx.drawImage(originalCanvas, offsetX, offsetY, drawWidth, drawHeight);
          
          // Extract distinct colors
          const imageData = tempCtx.getImageData(0, 0, 200, 200);
          const originalColors = await getDistinctColors(imageData, 30, 50, 40);
          
          // Cache the colors globally
          window.cachedOriginalColors = originalColors || [];
          
          console.log(`Extracted and cached ${window.cachedOriginalColors.length} distinct colors from original image`);
          
          return window.cachedOriginalColors;
          
      } catch (error) {
          console.error('Error extracting original colors:', error);
          window.cachedOriginalColors = [];
          return [];
      }
  }
    
    // Function to keep trying to get valid colors until successful
    async function getPersistentColors(inputColors, maxAttempts = 100) {
      let validColors = [];
      let attempts = 0;
      
      // Keep trying until we get valid colors
      while (validColors.length === 0 && attempts < maxAttempts) {
        attempts++;
        
        // First try the input colors
        if (attempts === 1 && Array.isArray(inputColors)) {
          validColors = inputColors.filter(color => 
            Array.isArray(color) && 
            color.length === 3 && 
            color.every(value => typeof value === 'number' && !isNaN(value) && value >= 0 && value <= 255)
          );
        }
        
        // If we have valid colors, use them
        if (validColors.length > 0) {
          break;
        }
        
        // Try to get colors from distinctColorsArrayColorPallet
        try {
          if (typeof window.distinctColorsArrayColorPallet === 'function') {
            // Try to get as function
            const newColors = await window.distinctColorsArrayColorPallet();
            if (Array.isArray(newColors)) {
              validColors = newColors.filter(color => 
                Array.isArray(color) && 
                color.length === 3 && 
                color.every(value => typeof value === 'number' && !isNaN(value) && value >= 0 && value <= 255)
              );
            }
          } else if (window.distinctColorsArrayColorPallet) {
            // Try to get as variable
            const newColors = window.distinctColorsArrayColorPallet;
            if (Array.isArray(newColors)) {
              validColors = newColors.filter(color => 
                Array.isArray(color) && 
                color.length === 3 && 
                color.every(value => typeof value === 'number' && !isNaN(value) && value >= 0 && value <= 255)
              );
            }
          }
        } catch (e) {
          // Ignore errors and keep trying
        }
        
        // If still no valid colors, wait a bit and try again
        if (validColors.length === 0) {
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      }
      
      // If we STILL don't have valid colors after all attempts,
      // generate completely random ones with good distribution
      if (validColors.length === 0) {
        validColors = [];
        for (let i = 0; i < 9; i++) {
          const hue = i * 40; // Spread across color wheel
          validColors.push(hslToRgb(hue, 70 + Math.random() * 25, 45 + Math.random() * 30));
        }
      }
      
      return validColors;
    }
    
    // Function to convert RGB to HEX
    function rgbToHex(r, g, b) {
      return '#' + [r, g, b].map(x => {
        const hex = x.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      }).join('');
    }
    
    // Helper functions for color manipulation
    function rgbToHsl(r, g, b) {
      try {
        r /= 255;
        g /= 255;
        b /= 255;
        
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;
        
        if (max === min) {
          h = s = 0;
        } else {
          const d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          
          switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
          }
          h /= 6;
        }
        
        return [h * 360, s * 100, l * 100];
      } catch (e) {
        // In case of error, return a random HSL value
        return [
          Math.random() * 360,
          70 + Math.random() * 30,
          45 + Math.random() * 25
        ];
      }
    }
    
    function hslToRgb(h, s, l) {
      try {
        h /= 360;
        s /= 100;
        l /= 100;
        
        let r, g, b;
        
        if (s === 0) {
          r = g = b = l;
        } else {
          const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1/6) return p + (q - p) * 6 * t;
            if (t < 1/2) return q;
            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
          };
          
          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          const p = 2 * l - q;
          
          r = hue2rgb(p, q, h + 1/3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1/3);
        }
        
        return [
          Math.round(r * 255),
          Math.round(g * 255),
          Math.round(b * 255)
        ];
      } catch (e) {
        // In case of error, generate a completely random RGB value
        return [
          Math.floor(Math.random() * 256),
          Math.floor(Math.random() * 256),
          Math.floor(Math.random() * 256)
        ];
      }
    }
    
    // NEW: Function to generate hue-shifted palettes for first 5 palettes
    function generateHueShiftedPalettes(originalColors, collection) {
        const hueShiftedPalettes = [];
        
        // Define hue shifts for first 5 palettes
        const hueShifts = [
            60,   // Palette 0: +60 degrees (more yellow/green)
            120,  // Palette 1: +120 degrees (complementary)
            180,  // Palette 2: +180 degrees (opposite)
            240,  // Palette 3: +240 degrees (triadic)
            300   // Palette 4: +300 degrees (triadic)
        ];
        
        for (let i = 0; i < 5; i++) {
            const hueShift = hueShifts[i];
            const shiftedPalette = originalColors.map(color => {
                const [h, s, l] = rgbToHsl(...color);
                let newHue = (h + hueShift) % 360;
                let newSat = s;
                let newLight = l;
                
                // Apply collection-specific adjustments
                if (collection === 'ss') {
                    // SS: Brighter, more vibrant
                    newSat = Math.min(100, s * 1.2);
                    newLight = Math.min(90, Math.max(40, l * 1.1));
                } else if (collection === 'aw') {
                    // AW: More muted, darker
                    newSat = Math.max(20, s * 0.8);
                    newLight = Math.min(80, Math.max(25, l * 0.9));
                }
                
                return hslToRgb(newHue, newSat, newLight);
            });
            
            hueShiftedPalettes.push(shiftedPalette);
        }
        
        return hueShiftedPalettes;
    }
    
    // Function to determine if a color is a background color (light/neutral)
    function isBackgroundColor(color) {
        const [h, s, l] = rgbToHsl(...color);
        
        // Background colors are typically:
        // 1. High lightness (> 80)
        // 2. Low saturation (< 20) 
        // 3. Or very light with any saturation (> 90 lightness)
        return (l > 80 && s < 20) || l > 90;
    }
    
    // Get color family (hue range) for a color
    function getColorFamily(color) {
        const [h, s, l] = rgbToHsl(...color);
        
        // Define color families with hue ranges
        if (h >= 345 || h < 15) return 'red';
        if (h >= 15 && h < 45) return 'orange';
        if (h >= 45 && h < 75) return 'yellow';
        if (h >= 75 && h < 165) return 'green';
        if (h >= 165 && h < 195) return 'cyan';
        if (h >= 195 && h < 255) return 'blue';
        if (h >= 255 && h < 285) return 'purple';
        if (h >= 285 && h < 345) return 'pink';
        
        return 'neutral';
    }
    
    // Group colors by their color families
    function groupColorsByFamily(colors) {
        const families = {};
        
        colors.forEach((color, index) => {
            const family = getColorFamily(color);
            if (!families[family]) {
                families[family] = [];
            }
            families[family].push({
                color: color,
                originalIndex: index,
                hsl: rgbToHsl(...color),
                isBackground: isBackgroundColor(color)
            });
        });
        
        // Sort colors within each family by lightness to maintain shade relationships
        Object.keys(families).forEach(family => {
            families[family].sort((a, b) => a.hsl[2] - b.hsl[2]); // Sort by lightness
        });
        
        return families;
    }
    
    // Generate a new color in target family that matches the lightness and saturation of source color
    function generateMatchingColor(sourceColor, targetHueRange) {
        const [sourceH, sourceS, sourceL] = rgbToHsl(...sourceColor);
        const isSourceBackground = isBackgroundColor(sourceColor);
        
        // Define hue ranges for each color family
        const hueRanges = {
            'red': [345, 15],
            'orange': [15, 45],
            'yellow': [45, 75],
            'green': [75, 165],
            'cyan': [165, 195],
            'blue': [195, 255],
            'purple': [255, 285],
            'pink': [285, 345]
        };
        
        const range = hueRanges[targetHueRange];
        if (!range) {
            // Fallback to random hue if family not found
            return hslToRgb(Math.random() * 360, sourceS, sourceL);
        }
        
        // Generate hue within the target family range
        let newHue;
        if (targetHueRange === 'red' && range[0] > range[1]) {
            // Handle red wraparound
            if (Math.random() > 0.5) {
                newHue = range[0] + Math.random() * (360 - range[0]);
            } else {
                newHue = Math.random() * range[1];
            }
        } else {
            newHue = range[0] + Math.random() * (range[1] - range[0]);
        }
        
        // For background colors, maintain their light characteristics
        if (isSourceBackground) {
            // Keep background colors light and neutral
            const newSat = Math.max(0, Math.min(15, sourceS + (Math.random() - 0.5) * 10));
            const newLight = Math.max(80, Math.min(95, sourceL + (Math.random() - 0.5) * 10));
            return hslToRgb(newHue, newSat, newLight);
        } else {
            // For regular colors, keep similar saturation and lightness but add slight variation
            const newSat = Math.max(5, Math.min(100, sourceS + (Math.random() - 0.5) * 20));
            const newLight = Math.max(5, Math.min(95, sourceL + (Math.random() - 0.5) * 15));
            return hslToRgb(newHue, newSat, newLight);
        }
    }
    
    // Generate diverse palettes by replacing color families
    // Generate diverse palettes by replacing color families
    function generateDiversePalettes(baseColors) {
        const palettes = [];
        
        // Group base colors by families
        const baseFamilies = groupColorsByFamily(baseColors);
        const availableFamilyNames = Object.keys(baseFamilies);
        
        // All possible target families
        const allFamilies = ['red', 'orange', 'yellow', 'green', 'cyan', 'blue', 'purple', 'pink'];
        
        // Generate 20 unique palettes with much more variation
        for (let i = 0; i < 20; i++) {
            const newPalette = [];
            
            // Create family mapping for this palette with more diversity
            const familyMapping = {};
            const usedTargetFamilies = new Set();
            
            // For each original family, assign a new target family
            availableFamilyNames.forEach((originalFamily, index) => {
                let targetFamily;
                let attempts = 0;
                
                // Use different strategies for different palette indices to ensure variety
                if (i < 8) {
                    // First 8 palettes: Sequential family shifts
                    targetFamily = allFamilies[(index + i) % allFamilies.length];
                } else if (i < 16) {
                    // Next 8 palettes: Reverse sequential with offsets
                    targetFamily = allFamilies[(allFamilies.length - 1 - index + (i - 8) * 2) % allFamilies.length];
                } else {
                    // Last 4 palettes: More random but controlled
                    const baseIndex = (index * 3 + i * 5) % allFamilies.length;
                    targetFamily = allFamilies[baseIndex];
                }
                
                // If this target family is already used, find an alternative
                let fallbackAttempts = 0;
                while (usedTargetFamilies.has(targetFamily) && fallbackAttempts < allFamilies.length) {
                    targetFamily = allFamilies[(allFamilies.indexOf(targetFamily) + 1) % allFamilies.length];
                    fallbackAttempts++;
                }
                
                familyMapping[originalFamily] = targetFamily;
                usedTargetFamilies.add(targetFamily);
            });
            
            // Generate new colors based on family mapping with additional variation
            baseColors.forEach((originalColor, colorIndex) => {
                const originalFamily = getColorFamily(originalColor);
                const targetFamily = familyMapping[originalFamily] || 'blue'; // fallback
                
                // Generate new color in target family with variation based on palette index
                let newColor = generateMatchingColor(originalColor, targetFamily);
                
                // Add extra variation for later palettes to ensure they're different
                if (i >= 10) {
                    const [h, s, l] = rgbToHsl(...newColor);
                    
                    // Add controlled randomness that varies by palette index
                    const hueVariation = ((i - 10) * 15 + colorIndex * 5) % 30 - 15; // -15 to +15 degrees
                    const satVariation = ((i - 10) * 8 + colorIndex * 3) % 20 - 10; // -10 to +10%
                    const lightVariation = ((i - 10) * 6 + colorIndex * 2) % 16 - 8; // -8 to +8%
                    
                    const newHue = (h + hueVariation + 360) % 360;
                    const newSat = Math.max(5, Math.min(100, s + satVariation));
                    const newLight = Math.max(10, Math.min(90, l + lightVariation));
                    
                    newColor = hslToRgb(newHue, newSat, newLight);
                }
                
                newPalette.push(newColor);
            });
            
            palettes.push(newPalette);
        }
        
        return palettes;
    }
    
    // Calculate color difference using CIEDE2000 simplified version
    function colorDifference(rgb1, rgb2) {
      // Convert to HSL for a perceptually better difference calculation
      const hsl1 = rgbToHsl(...rgb1);
      const hsl2 = rgbToHsl(...rgb2);
      
      // Calculate differences in hue, saturation, and lightness
      let hueDiff = Math.abs(hsl1[0] - hsl2[0]);
      // Handle the color wheel wraparound
      hueDiff = Math.min(hueDiff, 360 - hueDiff);
      
      const satDiff = Math.abs(hsl1[1] - hsl2[1]);
      const lightDiff = Math.abs(hsl1[2] - hsl2[2]);
      
      // Weight the differences (hue is more important for visual distinctness)
      return hueDiff * 1.5 + satDiff + lightDiff * 1.2;
    }
    
    // Get color name to categorize colors
    function getColorName(rgb) {
      try {
        const [r, g, b] = rgb;
        
        // Convert RGB to HSV for better color categorization
        const rNorm = r / 255;
        const gNorm = g / 255;
        const bNorm = b / 255;
        const max = Math.max(rNorm, gNorm, bNorm);
        const min = Math.min(rNorm, gNorm, bNorm);
        const diff = max - min;
        
        // Calculate Hue
        let h = 0;
        if (max !== min) {
          if (max === rNorm) {
            h = (60 * ((gNorm - bNorm) / diff) + 360) % 360;
          } else if (max === gNorm) {
            h = (60 * ((bNorm - rNorm) / diff) + 120) % 360;
          } else {
            h = (60 * ((rNorm - gNorm) / diff) + 240) % 360;
          }
        }
        
        // Calculate Value (brightness)
        const v = max;
        
        // Determine hue category
        let hueName;
        if (h < 15 || h >= 345) hueName = "Red";
        else if (h >= 15 && h < 45) hueName = "Orange";
        else if (h >= 45 && h < 75) hueName = "Yellow";
        else if (h >= 75 && h < 165) hueName = "Green";
        else if (h >= 165 && h < 195) hueName = "Cyan";
        else if (h >= 195 && h < 255) hueName = "Blue";
        else if (h >= 255 && h < 285) hueName = "Purple";
        else if (h >= 285 && h < 345) hueName = "Pink";
        
        // Simplified shade prefix
        let shadePrefix = "";
        if (v < 0.4) shadePrefix = "Dark";
        else if (v > 0.7) shadePrefix = "Light";
        
        return shadePrefix ? `${shadePrefix} ${hueName}` : hueName;
      } catch (e) {
        return "Color";
      }
    }
    
    // Apply collection-specific color adjustments with proper background handling
    function applyCollectionAdjustments(colors, collection) {
        return colors.map(color => {
            try {
                const [h, s, l] = rgbToHsl(...color);
                const isBackground = isBackgroundColor(color);
                
                if (collection === 'ss') {
                    if (isBackground) {
                        // For background colors in SS, keep them light and bright
                        // but add a slight warm or cool tint
                        const newSat = Math.min(25, s + 10); // Slight increase in saturation
                        const newLight = Math.max(115, Math.min(95, l + 5)); // Keep very light
                        return hslToRgb(h, newSat, newLight);
                    } else {
                        // For regular colors in SS, make them more vibrant and bright
                        const newSat = Math.min(100, s * 1.6); // Increase saturation more
                        const newLight = Math.max(40, Math.min(85, l * 1.8)); // Brighter but not washed out
                        return hslToRgb(h, newSat, newLight);
                    }
                } else if (collection === 'aw') {
                    if (isBackground) {
                        // For background colors in AW, make them slightly warmer/earthier
                        const newSat = Math.min(20, s + 5); // Very slight saturation increase
                        const newLight = Math.max(75, Math.min(90, l - 5)); // Slightly less bright
                        return hslToRgb(h, newSat, newLight);
                    } else {
                        // For regular colors in AW, make them more muted and earthy
                        const newSat = Math.max(20, s * 0.8); // Reduce saturation
                        const newLight = Math.max(25, Math.min(75, l * 0.9)); // Slightly darker
                        return hslToRgb(h, newSat, newLight);
                    }
                } else {
                    // For trending or other collections, return unchanged
                    return color;
                }
            } catch (e) {
                // If adjustment fails, return original color
                return color;
            }
        });
    }
    
    // Modified: Function to prepare display colors with one from each color family
    function prepareDisplayColors(colors) {
      // Make sure we have valid colors
      let validColors = colors.filter(color => 
        Array.isArray(color) && 
        color.length === 3 && 
        color.every(val => typeof val === 'number' && !isNaN(val) && val >= 0 && val <= 255)
      );
      
      // If no valid colors, generate new ones with good distribution
      if (validColors.length === 0) {
        validColors = [];
        for (let i = 0; i < MIN_DISPLAY_COUNT; i++) {
          // Generate colors with evenly distributed hues
          const hue = i * (360 / MIN_DISPLAY_COUNT);
          validColors.push(hslToRgb(hue, 70 + Math.random() * 30, 45 + Math.random() * 25));
        }
        return validColors;
      }
      
      // Define the color families (hue ranges)
      const colorFamilies = [
        { name: "Red", range: [345, 15] },        // Red wraps around 0
        { name: "Orange", range: [15, 45] },      // Orange
        { name: "Yellow", range: [45, 75] },      // Yellow
        { name: "Green", range: [75, 165] },      // Green
        { name: "Cyan", range: [165, 195] },      // Cyan
        { name: "Blue", range: [195, 255] },      // Blue
        { name: "Purple", range: [255, 285] },    // Purple
        { name: "Pink", range: [285, 345] }       // Pink
      ];
      
      // Categorize all colors by family
      const colorsByFamily = {};
      colorFamilies.forEach(family => {
        colorsByFamily[family.name] = [];
      });
      
      // Group colors by family
      validColors.forEach(color => {
        const [h, s, l] = rgbToHsl(...color);
        
        let foundFamily = false;
        for (const family of colorFamilies) {
          // Special case for red which wraps around 0/360
          if (family.name === "Red") {
            if (h >= family.range[0] || h < family.range[1]) {
              colorsByFamily[family.name].push(color);
              foundFamily = true;
              break;
            }
          } else if (h >= family.range[0] && h < family.range[1]) {
            colorsByFamily[family.name].push(color);
            foundFamily = true;
            break;
          }
        }
        
        // If no family found (edge case), add to closest family
        if (!foundFamily) {
          let closestFamily = colorFamilies[0];
          let minDistance = 360;
          
          for (const family of colorFamilies) {
            // Find the midpoint of the family range
            let midpoint;
            if (family.name === "Red") {
              // Red wraps around
              midpoint = (family.range[0] + family.range[1] + 360) / 2 % 360;
            } else {
              midpoint = (family.range[0] + family.range[1]) / 2;
            }
            
            // Calculate distance to midpoint, accounting for wrap-around
            let distance = Math.abs(h - midpoint);
            distance = Math.min(distance, 360 - distance);
            
            if (distance < minDistance) {
              minDistance = distance;
              closestFamily = family;
            }
          }
          
          colorsByFamily[closestFamily.name].push(color);
        }
      });
      
      // Always include the first color (may be background or most important)
      let displayColors = [validColors[0]];
      
      // Select one representative color from each family (with colors available)
      // Sort families by number of colors (descending) to prioritize families with more colors
      const sortedFamilies = Object.entries(colorsByFamily)
        .sort((a, b) => b[1].length - a[1].length)
        .filter(([_, colors]) => colors.length > 0);
      
      // Determine optimal number of colors to display
      let optimalDisplayCount = Math.min(
        MAX_DISPLAY_COUNT,
        Math.max(MIN_DISPLAY_COUNT, sortedFamilies.length + 1) // +1 for the first color
      );
      
      // Check if the first color already belongs to a family
      const [firstColorH, firstColorS, firstColorL] = rgbToHsl(...validColors[0]);
      let firstColorFamily = null;
      
      for (const family of colorFamilies) {
        if (family.name === "Red") {
          if (firstColorH >= family.range[0] || firstColorH < family.range[1]) {
            firstColorFamily = family.name;
            break;
          }
        } else if (firstColorH >= family.range[0] && firstColorH < family.range[1]) {
          firstColorFamily = family.name;
          break;
        }
      }
      
      // Select one representative from each family (excluding first color's family)
      for (const [familyName, familyColors] of sortedFamilies) {
        // Skip this family if it's the same as the first color's family
        if (familyName === firstColorFamily) continue;
        
        // If we've reached our optimal display count, break
        if (displayColors.length >= optimalDisplayCount) break;
        
        // Select the most saturated color from this family for better visibility
        let bestColor = familyColors[0];
        let highestSat = 0;
        
        for (const color of familyColors) {
          const [_, s, __] = rgbToHsl(...color);
          if (s > highestSat) {
            highestSat = s;
            bestColor = color;
          }
        }
        
        // Add the representative color from this family
        displayColors.push(bestColor);
      }
      
      // If we still don't have enough colors, add from the remaining colors
      // sorted by their perceptual distance from already selected colors
      if (displayColors.length < MIN_DISPLAY_COUNT) {
        // Flatten all colors from all families
        const allRemainingColors = validColors.filter(color => 
          !displayColors.some(c => 
            c[0] === color[0] && c[1] === color[1] && c[2] === color[2]
          )
        );
        
        // For each remaining color, calculate minimum distance to any selected color
        const colorDistances = allRemainingColors.map(color => {
          const minDistance = Math.min(...displayColors.map(selectedColor => 
            colorDifference(color, selectedColor)
          ));
          return { color, distance: minDistance };
        });
        
        // Sort by distance (descending) - most distinct colors first
        colorDistances.sort((a, b) => b.distance - a.distance);
        
        // Add colors until we reach the minimum
        for (const { color } of colorDistances) {
          displayColors.push(color);
          if (displayColors.length >= MIN_DISPLAY_COUNT) break;
        }
      }
      
      // If we still need more colors, generate completely new ones in empty hue regions
      if (displayColors.length < MIN_DISPLAY_COUNT) {
        // Find which hue regions are not represented
        const displayedHues = displayColors.map(color => rgbToHsl(...color)[0]);
        
        // Create hue "buckets" of 45 degrees each
        const hueBuckets = Array(8).fill(0);
        
        displayedHues.forEach(hue => {
          const bucketIndex = Math.floor(hue / 45) % 8;
          hueBuckets[bucketIndex]++;
        });
        
        // Generate new colors in empty buckets
        for (let i = 0; i < 8; i++) {
          if (hueBuckets[i] === 0 && displayColors.length < MIN_DISPLAY_COUNT) {
            // Generate a color in this empty hue region
            const baseHue = i * 45 + 22.5; // Middle of the bucket
            const newColor = hslToRgb(
              baseHue,
              70 + Math.random() * 30,
              45 + Math.random() * 25
            );
            displayColors.push(newColor);
          }
        }
      }
      
      return displayColors;
    }

    // Generate and show preview function
    async function generateAndShowPreview(previewCanvas, paletteColors, paletteIndex, collection) {
        try {
            // Check cache first
            if (window.palettePreviewCache && 
                window.palettePreviewCache[collection] && 
                window.palettePreviewCache[collection][paletteIndex]) {
                
                const cachedPreview = window.palettePreviewCache[collection][paletteIndex];
                const ctx = previewCanvas.getContext('2d', { willReadFrequently: true });
                
                // **REMOVED WHITE BACKGROUND FILL**
                ctx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
                
                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => {
                        const scale = Math.min(
                            previewCanvas.width / img.width,
                            previewCanvas.height / img.height
                        );
                        const scaledWidth = img.width * scale;
                        const scaledHeight = img.height * scale;
                        const x = (previewCanvas.width - scaledWidth) / 2;
                        const y = (previewCanvas.height - scaledHeight) / 2;
                        
                        ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
                        markPreviewReady(previewCanvas);
                        resolve();
                    };
                    img.onerror = () => {
                        drawFallbackPreview(previewCanvas, collection, paletteIndex);
                        resolve();
                    };
                    img.src = cachedPreview;
                });
            }
            
            // Get the original canvas
            const originalCanvas = totalLayers === 1 
                ? document.getElementById('layer_canvas_1')
                : document.getElementById(`layer_canvas_${paletteIndex + 1}`);
            
            if (!originalCanvas) {
                console.error('No original canvas found for preview');
                drawFallbackPreview(previewCanvas, collection, paletteIndex);
                return;
            }
            
            // **CREATE 200x200 PREVIEW PROCESSING CANVAS WITH TRANSPARENCY**
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = 200;
            tempCanvas.height = 200;
            const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
            
            // **DO NOT FILL WITH WHITE - KEEP TRANSPARENT**
            
            // Scale and draw the original image to 200x200 maintaining aspect ratio
            const originalAspect = originalCanvas.width / originalCanvas.height;
            let drawWidth, drawHeight, offsetX = 0, offsetY = 0;
            
            if (originalAspect > 1) {
                drawWidth = 200;
                drawHeight = 200 / originalAspect;
                offsetY = (200 - drawHeight) / 2;
            } else {
                drawHeight = 200;
                drawWidth = 200 * originalAspect;
                offsetX = (200 - drawWidth) / 2;
            }
            
            // Draw the original image directly (preserving transparency)
            tempCtx.drawImage(originalCanvas, offsetX, offsetY, drawWidth, drawHeight);
            
            // **EMBEDDED PROCESSPALLETE LOGIC STARTS HERE**
            
            // Get image data for processing
            const imageData = tempCtx.getImageData(0, 0, 200, 200);
            
            // Extract original colors from the scaled image
            const originalColors = await getDistinctColors(imageData, 30, 50, 40);
            
            if (!originalColors || originalColors.length === 0) {
                console.error('No original colors found for preview');
                // Draw the original scaled image anyway (preserving transparency)
                const ctx = previewCanvas.getContext('2d', { willReadFrequently: true });
                ctx.clearRect(0, 0, 200, 200); // Clear instead of white fill
                ctx.drawImage(tempCanvas, 0, 0, 200, 200);
                cachePreview(previewCanvas, collection, paletteIndex);
                markPreviewReady(previewCanvas);
                return;
            }
            
            // Apply collection-specific adjustments to palette colors
            let adjustedPaletteColors = applyCollectionAdjustments([...paletteColors], collection);
            
            // **ALWAYS USE COLOR REPLACEMENT PROCESSING (REMOVED HUE SHIFTING)**
            let processedImageData;
            
            // **COLOR REPLACEMENT PROCESSING FOR ALL PALETTES**
            const colorMappings = [];
            for (let i = 0; i < Math.min(originalColors.length, adjustedPaletteColors.length); i++) {
                colorMappings.push({
                    originalColor: originalColors[i],
                    targetColor: adjustedPaletteColors[i % adjustedPaletteColors.length]
                });
            }
            
            // Apply color mappings
            if (typeof ColorProcessor !== 'undefined') {
                const colorProcessor = new ColorProcessor();
                const tempImageUrl = tempCanvas.toDataURL('image/png'); // PNG preserves transparency
                processedImageData = await colorProcessor.applyMultipleColorMappings(
                    tempImageUrl,
                    colorMappings
                );
            } else {
                // Fallback: Simple color replacement
                const pixels = imageData.data;
                const tolerance = 30;
                
                for (let i = 0; i < pixels.length; i += 4) {
                    const a = pixels[i + 3];
                    
                    // **ONLY PROCESS NON-TRANSPARENT PIXELS**
                    if (a > 0) {
                        const currentColor = [pixels[i], pixels[i + 1], pixels[i + 2]];
                        
                        let closestMapping = null;
                        let minDistance = Infinity;
                        
                        for (const mapping of colorMappings) {
                            const distance = colorDifference(currentColor, mapping.originalColor);
                            if (distance < minDistance && distance < tolerance) {
                                minDistance = distance;
                                closestMapping = mapping;
                            }
                        }
                        
                        if (closestMapping) {
                            pixels[i] = closestMapping.targetColor[0];
                            pixels[i + 1] = closestMapping.targetColor[1];
                            pixels[i + 2] = closestMapping.targetColor[2];
                            // Keep original alpha: pixels[i + 3] = a;
                        }
                    }
                }
                
                tempCtx.putImageData(imageData, 0, 0);
                processedImageData = tempCanvas.toDataURL('image/png'); // PNG preserves transparency
            }
            
            // **DRAW RESULT WITHOUT WHITE BACKGROUND**
            const ctx = previewCanvas.getContext('2d', { willReadFrequently: true });
            ctx.clearRect(0, 0, 200, 200); // Clear instead of white fill
            
            return new Promise((resolve) => {
                const resultImg = new Image();
                resultImg.onload = () => {
                    ctx.drawImage(resultImg, 0, 0, 200, 200);
                    cachePreview(previewCanvas, collection, paletteIndex, processedImageData);
                    markPreviewReady(previewCanvas);
                    resolve();
                };
                resultImg.onerror = (e) => {
                    console.error("Error loading processed preview:", e);
                    drawFallbackPreview(previewCanvas, collection, paletteIndex);
                    resolve();
                };
                resultImg.src = processedImageData;
            });
            
        } catch (error) {
            console.error("Error generating preview:", error);
            drawFallbackPreview(previewCanvas, collection, paletteIndex);
        }
    }

    // Modified cache function with safer implementation
    function cachePreview(canvas, collection, index, highResUrl) {
      // Initialize cache objects if they don't exist
      if (!window.palettePreviewCache) {
        window.palettePreviewCache = {};
      }
      
      if (!window.palettePreviewCache[collection]) {
        window.palettePreviewCache[collection] = {};
      }
      
      // Safer implementation that checks if highResUrl exists
      if (highResUrl) {
        window.palettePreviewCache[collection][index] = highResUrl;
      } else {
        window.palettePreviewCache[collection][index] = canvas.toDataURL();
      }
    }
        
    // Helper function to mark a preview as ready
    function markPreviewReady(canvas) {
      const container = canvas.closest('.palette-clickable-container');
      if (container) {
          container.classList.add('preview-ready');
      }
    }
    
    // Helper function to draw a fallback preview
    function drawFallbackPreview(canvas, collection, paletteIndex) {
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#f5f5f5';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#999';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = '14px sans-serif';
      ctx.fillText('Preview unavailable', canvas.width/2, canvas.height/2);
      
      // Cache the fallback
      cachePreview(canvas, collection, paletteIndex);
      
      // Mark as ready even though it's a fallback
      markPreviewReady(canvas);
    }
    
    // Function to show full palette modal
    function showFullPaletteModal(palette, collection, index) {
        // Create modal if it doesn't exist
        let modal = document.getElementById('fullPaletteModal');
        if (!modal) {
            modal = document.createElement('div');
            modal.id = 'fullPaletteModal';
            modal.classList.add('full-palette-modal');
            
            const modalContent = document.createElement('div');
            modalContent.classList.add('full-palette-modal-content');
            
            const closeBtn = document.createElement('span');
            closeBtn.classList.add('close-palette-modal');
            closeBtn.innerHTML = '&times;';
            closeBtn.onclick = () => modal.style.display = 'none';
            
            const title = document.createElement('h2');
            title.classList.add('palette-modal-title');
            
            const colorsContainer = document.createElement('div');
            colorsContainer.classList.add('all-colors-container');
            
            modalContent.appendChild(closeBtn);
            modalContent.appendChild(title);
            modalContent.appendChild(colorsContainer);
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            // Close modal when clicking outside
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.style.display = 'none';
                }
            };
        }
        
        // Update modal content
        const title = modal.querySelector('.palette-modal-title');
        const colorsContainer = modal.querySelector('.all-colors-container');
        
        title.textContent = `${collection.toUpperCase()} Palette ${index + 1} - All Colors`;
        colorsContainer.innerHTML = '';
        
        // Add all colors to the modal
        palette.forEach((color, idx) => {
            const colorDiv = document.createElement('div');
            colorDiv.classList.add('full-palette-color');
            colorDiv.style.backgroundColor = `rgb(${color.join(',')})`;
            
            const colorInfo = document.createElement('div');
            colorInfo.classList.add('color-info');
            const hexValue = rgbToHex(color[0], color[1], color[2]);
            colorInfo.textContent = `${idx + 1}: ${hexValue}`;
            
            colorDiv.appendChild(colorInfo);
            colorsContainer.appendChild(colorDiv);
        });
        
        // Show modal
        modal.style.display = 'block';
    }
    
    // Add necessary CSS styles for the loading indicators
    if (!document.getElementById('palette-preview-styles')) {
      const styleElement = document.createElement('style');
      styleElement.id = 'palette-preview-styles';
      styleElement.textContent = `
        .palette-clickable-container {
            display: flex;
            flex-direction: column;
            cursor: pointer;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transition: transform 0.2s, box-shadow 0.2s;
            position: relative;
            width: 200px;
            margin-bottom: 15px;
        }
        
        .palette-clickable-container:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        
        .palette-preview-container {
            width: 200px;
            height: 200px;
            overflow: hidden;
            position: relative;
            background-color: white;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .palette-preview-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.7);
            z-index: 1;
        }
        
        .palette-preview-container::after {
            content: 'Loading...';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #666;
            z-index: 2;
        }
        
        .preview-ready .palette-preview-container::before,
        .preview-ready .palette-preview-container::after {
            display: none;
        }

        .palette-preview-canvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        
        .swatch-container {
            display: flex;
            justify-content: space-around;
            padding: 5px;
            background-color: #f5f5f5;
            border-top: 1px solid #ddd;
        }
        
        .color-swatch {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 1px solid #ddd;
            margin: 0 2px;
        }
        
        .ss-swatch {
            border-color: #d0d0ff;
        }
        
        .aw-swatch {
            border-color: #ffd0d0;
        }
        
        .show-all-colors-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 25px;
            height: 25px;
            background-color: rgba(255,255,255,0.8);
            color: #333;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-weight: bold;
            z-index: 3;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        
        .show-all-colors-btn:hover {
            background-color: rgba(255,255,255,0.95);
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        
        .full-palette-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.7);
        }
        
        .full-palette-modal-content {
            background-color: #fff;
            margin: 10% auto;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            width: 80%;
            max-width: 600px;
            position: relative;
        }
        
        .close-palette-modal {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .palette-modal-title {
            text-align: center;
            margin-bottom: 20px;
            color: #333;
        }
        
        .all-colors-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
        }
        
        .full-palette-color {
            width: 80px;
            height: 80px;
            border-radius: 8px;
            position: relative;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .color-info {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: rgba(0,0,0,0.6);
            color: white;
            font-size: 10px;
            padding: 3px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .full-palette-color:hover .color-info {
            opacity: 1;
        }
      `;
      document.head.appendChild(styleElement);
    }
    
    // Ensure we have valid colors to work with
    const validatedColors = await getPersistentColors(colors);
    
    // Main processing logic for single layer
    if (totalLayers === 1) {
        // NEW: Generate special palettes for first 5 (hue-shifted) and regular for the rest
        let allPalettes = [];
        
        // First 5 palettes: Use hue shifting
        const hueShiftedPalettes = generateHueShiftedPalettes(validatedColors, collection);
        allPalettes = [...hueShiftedPalettes];
        
        // Remaining 5 palettes: Use family replacement as before
        const diversePalettes = generateDiversePalettes(validatedColors);
        allPalettes = [...allPalettes, ...diversePalettes.slice(0, 20)];
        
        // Initialize preview cache if needed
        if (!window.palettePreviewCache) {
            window.palettePreviewCache = {};
        }
        if (!window.palettePreviewCache[collection]) {
            window.palettePreviewCache[collection] = {};
        }
        
        // Create preview canvases if they don't exist
        if (!window.previewCanvases) {
            window.previewCanvases = {};
            
            // Generate a smaller version of the original image for preview
            const originalCanvas = document.getElementById('layer_canvas_1');
            if (originalCanvas) {
                const previewCanvas = document.createElement('canvas');
                previewCanvas.width = 200;
                previewCanvas.height = 200;
                const previewCtx = previewCanvas.getContext('2d', { willReadFrequently: true });
                
                // Draw the original image scaled down
                previewCtx.drawImage(originalCanvas, 0, 0, 200, 200);
                
                // Store the preview canvas data URL for future use
                window.previewCanvases['original'] = previewCanvas.toDataURL();
            }
        }
        
        // Create all palette containers first
        const paletteContainers = [];
        
        for (let i = 0; i < 25; i++) {
            const paletteContainer = document.getElementById(`${prefix}colorPalette_${i}`);
            if (!paletteContainer) continue;
            
            paletteContainer.innerHTML = '';
            
            // Get palette colors from our mixed palettes (hue-shifted for first 5, diverse for rest)
            let paletteColors = allPalettes[i] || allPalettes[0];
            
            // Verify that all colors are valid
            paletteColors = paletteColors.filter(color => 
                Array.isArray(color) && 
                color.length === 3 && 
                color.every(v => typeof v === 'number' && !isNaN(v) && v >= 0 && v <= 255)
            );
            
            // If somehow we lost all colors, generate new ones
            if (paletteColors.length === 0) {
                // Generate new colors with good distribution
                paletteColors = [];
                for (let j = 0; j < 9; j++) {
                    const hue = j * (360 / 9);
                    paletteColors.push(hslToRgb(hue, 70 + Math.random() * 30, 45 + Math.random() * 25));
                }
            }
            
            // Initialize the storage if needed
            window[`${collection}PaletteColors`] = window[`${collection}PaletteColors`] || {};
            
            // Store ALL colors in the palette data structure
            window[`${collection}PaletteColors`][i] = [...paletteColors];
            
            // NEW: Mark hue-shifted palettes with special flag
            if (i < 5) {
                // Mark this as a hue-shifted palette
                if (!window[`${collection}PaletteHueShifted`]) {
                    window[`${collection}PaletteHueShifted`] = {};
                }
                window[`${collection}PaletteHueShifted`][i] = true;
            }
            
            // Create container for the palette that includes preview
            const clickableContainer = document.createElement('div');
            clickableContainer.classList.add('palette-clickable-container');
            paletteContainer.appendChild(clickableContainer);
            
            // Add data attribute to store the palette index
            clickableContainer.dataset.paletteIndex = i;
            clickableContainer.dataset.collection = collection;
            
            // Add preview image container
            const previewContainer = document.createElement('div');
            previewContainer.classList.add('palette-preview-container');
            clickableContainer.appendChild(previewContainer);
            
            // Create small preview canvas
            const previewCanvas = document.createElement('canvas');
            previewCanvas.width = 200;
            previewCanvas.height = 200;
            previewCanvas.classList.add('palette-preview-canvas');
            previewContainer.appendChild(previewCanvas);
            
            // Display the representative colors underneath the preview
            const swatchContainer = document.createElement('div');
            swatchContainer.classList.add('swatch-container');
            clickableContainer.appendChild(swatchContainer);
            
            // Prepare display colors - ONE FROM EACH COLOR FAMILY
            const displayColors = prepareDisplayColors(paletteColors);
            
            // Display color swatches under the preview
            displayColors.forEach((color, idx) => {
                const swatch = document.createElement('div');
                swatch.classList.add('color-swatch');
                swatch.style.backgroundColor = `rgb(${color.join(',')})`;
                
                // Updated tooltip with HEX value instead of RGB
                const hexValue = rgbToHex(color[0], color[1], color[2]);
                swatch.title = ` ${hexValue}`;
                
                if (collection === 'ss') {
                    swatch.classList.add('ss-swatch');
                } else if (collection === 'aw') {
                    swatch.classList.add('aw-swatch');
                }
                
                swatchContainer.appendChild(swatch);
            });
            
            // Click handler to use the FULL palette
            clickableContainer.addEventListener('click', function() {
                const paletteIndex = parseInt(this.dataset.paletteIndex, 10);
                const collectionName = this.dataset.collection;
                
                // Get the FULL palette from storage
                const fullPalette = window[`${collectionName}PaletteColors`] && 
                                  window[`${collectionName}PaletteColors`][paletteIndex];
                
                // Call processPallet with the FULL palette from storage
                if (typeof window.processPallet === 'function' && fullPalette && fullPalette.length > 0) {
                    window.processPallet(null, totalLayers, null, 0, null, fullPalette, paletteIndex, collectionName);
                }
            });
            
            // Add "Show All" button
            const showAllButton = document.createElement('div');
            showAllButton.classList.add('show-all-colors-btn');
            showAllButton.innerHTML = '+';
            showAllButton.title = 'Show all colors in palette';
            clickableContainer.appendChild(showAllButton);
            
            // Add event listener to show all colors in a modal
            showAllButton.addEventListener('click', function(e) {
                e.stopPropagation(); // Prevent triggering the parent container's click
                
                const fullPalette = window[`${collection}PaletteColors`][i];
                if (!fullPalette || fullPalette.length === 0) {
                    return;
                }
                
                showFullPaletteModal(fullPalette, collection, i);
            });
            
            // Store the palette info for preview generation
            paletteContainers.push({
                index: i,
                canvas: previewCanvas,
                colors: paletteColors
            });
        }
        
        // Generate previews one by one with small delays between each to avoid overloading the browser
        for (let i = 0; i < paletteContainers.length; i++) {
            const item = paletteContainers[i];
            
            // Use setTimeout to stagger the preview generation
            setTimeout(() => {
                generateAndShowPreview(item.canvas, item.colors, item.index, collection);
            }, i * 50); // Small delay between each preview start (50ms per palette)
        }
    } else {
        // Multi-layer logic
        const paletteContainer = document.getElementById(`${prefix}colorPalette_${layerIndex}`);
        if (!paletteContainer) return;
        
        // For multi-layer, check if this should be hue-shifted or diverse
        let paletteColors;
        if (layerIndex < 5) {
            // Use hue shifting for first 5 layers
            const hueShiftedPalettes = generateHueShiftedPalettes(validatedColors, collection);
            paletteColors = hueShiftedPalettes[layerIndex] || [...validatedColors];
            
            // Mark this as hue-shifted
            if (!window[`${collection}PaletteHueShifted`]) {
                window[`${collection}PaletteHueShifted`] = {};
            }
            window[`${collection}PaletteHueShifted`][layerIndex] = true;
        } else {
            // Use family replacement for layers 5+
            const diversePalettes = generateDiversePalettes(validatedColors);
            paletteColors = diversePalettes[layerIndex % diversePalettes.length] || [...validatedColors];
        }
        
        // Store ALL colors in the palette data structure
        window[`${collection}PaletteColors`] = window[`${collection}PaletteColors`] || {};
        window[`${collection}PaletteColors`][layerIndex] = [...paletteColors];
        
        // Clear container first
        paletteContainer.innerHTML = '';
        
        // Create container for the palette that includes preview
        const clickableContainer = document.createElement('div');
        clickableContainer.classList.add('palette-clickable-container');
        paletteContainer.appendChild(clickableContainer);
        
        // Add data attribute to store the layer index
        clickableContainer.dataset.layerIndex = layerIndex;
        clickableContainer.dataset.collection = collection;
        
        // Add preview image container
        const previewContainer = document.createElement('div');
        previewContainer.classList.add('palette-preview-container');
        clickableContainer.appendChild(previewContainer);
        
        // Create small preview canvas - use the current layer's canvas as source
        const previewCanvas = document.createElement('canvas');
        previewCanvas.width = 200;
        previewCanvas.height = 200;
        previewCanvas.classList.add('palette-preview-canvas');
        previewContainer.appendChild(previewCanvas);
        
        // Initialize preview cache if needed
        if (!window.palettePreviewCache) {
            window.palettePreviewCache = {};
        }
        if (!window.palettePreviewCache[collection]) {
            window.palettePreviewCache[collection] = {};
        }
        
        // Find the layer's canvas
        const layerCanvas = document.getElementById(`layer_canvas_${layerIndex+1}`);
        if (layerCanvas) {
            // Create preview canvases for this layer if they don't exist
            if (!window.previewCanvases) {
                window.previewCanvases = {};
            }
            
            // Generate a smaller version of this layer for preview
            if (!window.previewCanvases[`layer_${layerIndex+1}`]) {
                const previewLayerCanvas = document.createElement('canvas');
                previewLayerCanvas.width = 200;
                previewLayerCanvas.height = 200;
                const previewLayerCtx = previewLayerCanvas.getContext('2d', { willReadFrequently: true });
                
                // Draw the layer image scaled down
                previewLayerCtx.drawImage(layerCanvas, 0, 0, 200, 200);
                
                // Store the preview layer data URL
                window.previewCanvases[`layer_${layerIndex+1}`] = previewLayerCanvas.toDataURL();
            }
        }
        
        // Display the representative colors underneath the preview
        const swatchContainer = document.createElement('div');
        swatchContainer.classList.add('swatch-container');
        clickableContainer.appendChild(swatchContainer);
        
        // Prepare display colors - ONE FROM EACH COLOR FAMILY
        const displayColors = prepareDisplayColors(paletteColors);
        
        // Display color swatches under the preview
        displayColors.forEach((color, idx) => {
            const swatch = document.createElement('div');
            swatch.classList.add('color-swatch');
            swatch.style.backgroundColor = `rgb(${color.join(',')})`;
            
            // Updated tooltip with HEX value instead of RGB
            const hexValue = rgbToHex(color[0], color[1], color[2]);
            swatch.title = `Color ${idx+1}: ${getColorName(color)} - ${hexValue}`;
            
            if (collection === 'ss') {
                swatch.classList.add('ss-swatch');
            } else if (collection === 'aw') {
                swatch.classList.add('aw-swatch');
            }
            
            swatchContainer.appendChild(swatch);
        });
        
        // Add click handler to use the FULL palette when clicked
        clickableContainer.addEventListener('click', function() {
            const layerIdx = parseInt(this.dataset.layerIndex, 10);
            const collectionName = this.dataset.collection;
            
            // Get the FULL palette from storage
            const fullPalette = window[`${collectionName}PaletteColors`] && 
                               window[`${collectionName}PaletteColors`][layerIdx];
            
            // Call processPallet with the FULL palette
            if (typeof window.processPallet === 'function' && fullPalette && fullPalette.length > 0) {
                window.processPallet(null, totalLayers, null, layerIdx, null, fullPalette, layerIdx);
            }
        });
        
        // Add "Show All" button for the multi-layer case
        const showAllButton = document.createElement('div');
        showAllButton.classList.add('show-all-colors-btn');
        showAllButton.innerHTML = '+';
        showAllButton.title = 'Show all colors in palette';
        clickableContainer.appendChild(showAllButton);
        
        // Add event listener to show all colors in a modal
        showAllButton.addEventListener('click', function(e) {
            e.stopPropagation(); // Prevent triggering the parent container's click
            
            const fullPalette = window[`${collection}PaletteColors`][layerIndex];
            if (!fullPalette || fullPalette.length === 0) {
                return;
            }
            
            showFullPaletteModal(fullPalette, collection, layerIndex);
        });
        
        // Start generating the preview immediately
        generateAndShowPreview(previewCanvas, paletteColors, layerIndex, collection);
    }
    setTimeout(() => {
    syncFavoriteStarsWithAllCategories();
}, 500);
}


// Modal function for showing all palette colors
function showFullPaletteModal(palette, collection, paletteIndex) {
  // Create and append modal elements if they don't exist
  let modal = document.getElementById('full-palette-modal');
  
  if (!modal) {
      modal = document.createElement('div');
      modal.id = 'full-palette-modal';
      modal.classList.add('full-palette-modal');
      
      const modalContent = document.createElement('div');
      modalContent.classList.add('full-palette-modal-content');
      
      const closeBtn = document.createElement('span');
      closeBtn.classList.add('close-palette-modal');
      closeBtn.innerHTML = '&times;';
      
      const modalTitle = document.createElement('h3');
      modalTitle.classList.add('palette-modal-title');
      
      const colorsContainer = document.createElement('div');
      colorsContainer.classList.add('all-colors-container');
      
      modalContent.appendChild(closeBtn);
      modalContent.appendChild(modalTitle);
      modalContent.appendChild(colorsContainer);
      modal.appendChild(modalContent);
      
      document.body.appendChild(modal);
      
      // Add event listener to close button
      closeBtn.addEventListener('click', function() {
          modal.style.display = 'none';
      });
      
      // Close modal when clicking outside content
      window.addEventListener('click', function(event) {
          if (event.target === modal) {
              modal.style.display = 'none';
          }
      });
  }
  
  // Update modal content with current palette
  const modalTitle = modal.querySelector('.palette-modal-title');
  const colorsContainer = modal.querySelector('.all-colors-container');
  
  modalTitle.textContent = `Full Palette (${collection.toUpperCase()} #${paletteIndex+1})`;
  colorsContainer.innerHTML = '';
  
  // Add all colors to the modal
  palette.forEach((color, index) => {
      const colorBox = document.createElement('div');
      colorBox.classList.add('full-palette-color');
      colorBox.style.backgroundColor = `rgb(${color.join(',')})`;
      
      // Add color information
      const colorInfo = document.createElement('div');
      colorInfo.classList.add('color-info');
      colorInfo.textContent = `#${index+1}: RGB(${color.join(',')})`;
      colorBox.appendChild(colorInfo);
      
      colorsContainer.appendChild(colorBox);
  });
  
  // Show the modal
  modal.style.display = 'block';
}



async function processPreviewQueue() {
  // Check if queue exists
  if (typeof window.previewQueue === 'undefined') {
    window.isProcessingPreviewQueue = false;
    return;
  }
  
  // Check if queue is empty
  if (window.previewQueue.length === 0) {
    window.isProcessingPreviewQueue = false;
    return;
  }
  
  window.isProcessingPreviewQueue = true;
  
  // Take the next preview from the queue
  const nextPreview = window.previewQueue.shift();
  
  try {
    // Generate this preview
    await generatePreview(
      nextPreview.previewCanvas, 
      nextPreview.paletteColors, 
      nextPreview.paletteIndex, 
      nextPreview.collection
    );
  } catch (error) {
    console.error("Error processing preview in queue:", error);
  }
  
  // Small delay to prevent UI freezing
  await new Promise(resolve => setTimeout(resolve, 50));
  
  // Process the next preview in the queue
  processPreviewQueue();
}








    
      function loadZoomValue(){
        //document.getElementById('zoomWrapper').style.transform = `scale(${0.072})`;
        document.getElementById('zoomWrapper').style.transform = `scale(${0.3})`;
      }
      document.addEventListener('DOMContentLoaded', loadZoomValue);
      document.getElementById('zoomSlider').addEventListener('input', function() {
        const zoomLevel = this.value / 100;
        //const zoomLevel = 0.3;

        document.getElementById('zoomWrapper').style.transform = `scale(${zoomLevel})`;
      });

      function toggleLayer(layerIndex) {
        const layerDiv = document.getElementById(`layer_${layerIndex}`);
        const checkbox = document.getElementById(`toggleLayer${layerIndex}`);
        layerDiv.style.display = checkbox.checked ? 'block' : 'none';
      }

      // Analyze the image data to calculate layer-specific parameters
      function analyzeImageLayer(ctx) {
        const imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
        const data = imageData.data;

        let totalLightness = 0;
        let totalHue = 0;
        let pixelCount = 0;

        const hues = [];

        for (let i = 0; i < data.length; i += 4) {
            // Ignore fully transparent pixels
            if (data[i + 3] === 0) continue;

            const rgb = [data[i], data[i + 1], data[i + 2]];
            const hsl = rgbToHsl(rgb[0], rgb[1], rgb[2]);

            totalLightness += hsl[2];
            totalHue += hsl[0];
            hues.push(hsl[0]);
            pixelCount++;
        }

        // Handle cases where no valid pixels were processed
        if (pixelCount === 0) {
            return {
                avgLightness: 0,
                avgHue: 0,
                hueRange: 0,
                lightnessTolerance: 0,
                hueTolerance: 0,
            };
        }

        const avgLightness = totalLightness / pixelCount;
        const avgHue = totalHue / pixelCount;

        let hueRange = calculateHueRange(hues);

        const lightnessTolerance = Math.min(0.5, avgLightness * 0.5); // Adjusted scaling
        const hueTolerance = Math.min(40, hueRange * 0.5);            // Adjusted scaling

        return {
            avgLightness,
            avgHue,
            hueRange,
            lightnessTolerance,
            hueTolerance,
        };
      }

      function analyzeImageLayerforsingle(ctx) {
         const imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
         const data = imageData.data;

         let totalLightness = 0;
         let totalHue = 0;
         let pixelCount = 0;

         const hues = [];

         for (let i = 0; i < data.length; i += 4) {
             // Ignore fully transparent pixels
             if (data[i + 3] === 0) continue;

             const rgb = [data[i], data[i + 1], data[i + 2]];
             const hsl = rgbToHslforsingle(rgb[0], rgb[1], rgb[2]);

             totalLightness += hsl[2];
             totalHue += hsl[0];
             hues.push(hsl[0]);
             pixelCount++;
         }

         // Handle cases where no valid pixels were processed
         if (pixelCount === 0) {
             //console.warn("No valid pixels found in layer.");
             return {
                 avgLightness: 0,
                 avgHue: 0,
                 hueRange: 0,
                 lightnessTolerance: 0,
                 hueTolerance: 0,
             };
         }

         const avgLightness = totalLightness / pixelCount;
         const avgHue = totalHue / pixelCount;

         // Calculate hue range only if there are hues available
         //const hueRange = hues.length > 0 ? Math.max(...hues) - Math.min(...hues) : 0;
         let hueRange = calculateHueRangeforsingle(hues);



         const lightnessTolerance = Math.min(0.7, avgLightness / 2); // Scaled by avgLightness
         const hueTolerance = Math.min(47, hueRange / 2);            // Scaled by hue range


         return {
             avgLightness,
             avgHue,
             hueRange,
             lightnessTolerance,
             hueTolerance,
         };
       }
      function rgbToHsl(r, g, b) {
        r /= 255; g /= 255; b /= 255;
        const max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;

        if (max === min) {
            h = s = 0; // achromatic
        } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r:
                    h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
                    break;
                case g:
                    h = ((b - r) / d + 2) / 6;
                    break;
                case b:
                    h = ((r - g) / d + 4) / 6;
                    break;
            }
        }
        return [h, s, l];
      }

      function hslToRgb(h, s, l) {
        let r, g, b;

        if (s === 0) {
            r = g = b = l; // achromatic
        } else {
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1; if (t > 1) t -= 1;
                if (t < 1 / 6) return p + (q - p) * 6 * t;
                if (t < 1 / 2) return q;
                if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                return p;
            };
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
        }

        return [r, g, b];
      }


      // Function to convert RGB to HSL





      function rgbToHslforsingle(r, g, b) {
    r /= 255;
    g /= 255;
    b /= 255;

    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;

    if (max === min) {
        h = s = 0; // Achromatic
    } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

        switch (max) {
            case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
            case g:
                h = (b - r) / d + 2;
                break;
            case b:
                h = (r - g) / d + 4;
                break;
        }

        h /= 6;
    }

    return [h, s, l];
}

function hslToRgbforsingle(h, s, l) {
    let r, g, b;

    if (s === 0) {
        r = g = b = l; // Achromatic
    } else {
        const hue2rgb = function (p, q, t) {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
        };

        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
    }

    return [r * 255, g * 255, b * 255];
}

   function calculateHueRange(hues) {
        if (hues.length === 0) return 0;

        // Convert hues to degrees (0 to 360)
        const huesInDegrees = hues.map(h => h * 360);

        // Sort hues
        huesInDegrees.sort((a, b) => a - b);

        // Calculate differences between adjacent hues
        let maxDiff = 0;
        for (let i = 0; i < huesInDegrees.length - 1; i++) {
            const diff = huesInDegrees[i + 1] - huesInDegrees[i];
            if (diff > maxDiff) maxDiff = diff;
        }

        // Include wrap-around difference
        const wrapAroundDiff = 360 - huesInDegrees[huesInDegrees.length - 1] + huesInDegrees[0];
        if (wrapAroundDiff > maxDiff) maxDiff = wrapAroundDiff;

        return maxDiff;
      }

      function calculateHueRangeforsingle(hues) {
         if (hues.length === 0) return 0;

         let maxHue = -Infinity;
         let minHue = Infinity;

         for (let hue of hues) {
             if (hue > maxHue) maxHue = hue;
             if (hue < minHue) minHue = hue;
         }

         return maxHue - minHue;
       }
       function getDistinctColors(imageData, threshold = 30, maxColors = 50, minDistance = 40) {
        const totalLayers = {{ layers|length }};
        const uniqueColors = new Map(); // Changed to Map to track counts
        const data = imageData.data;
        const isSingleLayer = totalLayers === 1;
    
        // First pass: collect all unique colors and count occurrences
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            const a = data[i + 3];
    
            // Skip fully transparent pixels
            if (a === 0) continue;
            // Skip near-black colors (more lenient check)
            if (r < 15 && g < 15 && b < 15) continue;
            
            const colorKey = `${r},${g},${b}`;
            if (uniqueColors.has(colorKey)) {
                uniqueColors.set(colorKey, uniqueColors.get(colorKey) + 1);
            } else {
                uniqueColors.set(colorKey, 1);
            }
        }
    
        // Convert to array and map to RGB arrays with counts
        const colors = Array.from(uniqueColors.entries()).map(([colorStr, count]) => {
            const [r, g, b] = colorStr.split(',').map(Number);
            return {
                rgb: [r, g, b],
                count: count,
                // Add HSL values to help with diversity
                hsl: rgbToHsl(r, g, b)
            };
        });
    
    
        // Sort colors by count (frequency) in descending order
        colors.sort((a, b) => b.count - a.count);
        
        // Collect distinct colors directly, applying the minimum distance requirement
        const distinctColors = [];
        
        // Always include the most frequent color
        if (colors.length > 0) {
            distinctColors.push(colors[0].rgb);
        }
        
        // For all remaining colors, check if they meet the minimum distance requirement
        for (let i = 1; i < colors.length && distinctColors.length < maxColors; i++) {
            const candidate = colors[i].rgb;
            let isDistinct = true;
            
            for (const existingColor of distinctColors) {
                const distance = colorDistance(candidate, existingColor);
                if (distance < minDistance) {
                    isDistinct = false;
                    break;
                }
            }
            
            if (isDistinct) {
                distinctColors.push(candidate);
            }
        }
        
        localStorage.setItem('distinctColorsArrayColorPallet', JSON.stringify(distinctColors));
        return distinctColors;
    }
    
    function colorDistance(c1, c2) {
        return Math.sqrt(
            Math.pow(c1[0] - c2[0], 2) +
            Math.pow(c1[1] - c2[1], 2) +
            Math.pow(c1[2] - c2[2], 2)
        );
    }
        function generateUniqueRGBColorArray(count) {
            const colors = [];
        
            while (colors.length < count) {
                const r = Math.floor(Math.random() * 256);
                const g = Math.floor(Math.random() * 256);
                const b = Math.floor(Math.random() * 256);
        
                const isGreenish = (g > r && g > b);
                const isDuplicate = colors.some(color => color[0] === r && color[1] === g && color[2] === b);
        
                if (!isGreenish && !isDuplicate) {
                    colors.push([r, g, b]);
                }
            }
        
            return colors;
        }
    
    function generateUniqueRGBColorArray(count) {
        const colors = [];
    
        while (colors.length < count) {
            const r = Math.floor(Math.random() * 256);
            const g = Math.floor(Math.random() * 256);
            const b = Math.floor(Math.random() * 256);
    
            const isGreenish = (g > r && g > b);
            const isDuplicate = colors.some(color => color[0] === r && color[1] === g && color[2] === b);
    
            if (!isGreenish && !isDuplicate) {
                colors.push([r, g, b]);
            }
        }
    
        return colors;
    }

      function showLayerInfo() {
        contextMenu.style.display = 'none';
        $('#colorPickerModal').modal('show');
        const layerIndex = contextMenu.dataset.layerIndex; // Assuming contextMenu is defined

        updateLayersWithNewColorCount(layerIndex);
      }

async function processLayerAsync(ctx, targetColor, newColor, minAreaThreshold = 1, maxSkipCount = 5) {
    return new Promise(async (resolve) => {
        const colorProcessor = new ColorProcessor();
        const canvasId = ctx.canvas.id;
        const layerIndex = parseInt(canvasId.replace('layer_canvas_', ''));
        const imageDataUrl = ctx.canvas.toDataURL();
        console.log('Processing layer:', layerIndex, 'with target color:', targetColor, 'and new color:', newColor);

        try {
            const colorMapping = await colorProcessor.getColorMapping(imageDataUrl);
            // CORRECTED: Swap parameter order here
            const processedImageUrl = await colorProcessor.applyColorMapping(
                imageDataUrl,
                colorMapping,
                targetColor,  // Original color to replace (now first)
                newColor      // New color to apply (now second)
            );

            const img = new Image();
            img.onload = () => {
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                ctx.drawImage(img, 0, 0);
                updateFooterColorButton(layerIndex, newColor);
                resolve();
            };
            img.src = processedImageUrl;
        } catch (error) {
            console.error('Error processing layer:', error);
            resolve();
        }
    });
}
// Helper function to check if a color is locked
function isColorLocked(color, layerIndex) {
    // Implement this based on how you store locked colors
    // For example:
    if (window.lockedColors && window.lockedColors[layerIndex]) {
        return window.lockedColors[layerIndex].some(lockedColor => 
            Math.abs(color[0] - lockedColor[0]) < 5 &&
            Math.abs(color[1] - lockedColor[1]) < 5 &&
            Math.abs(color[2] - lockedColor[2]) < 5
        );
    }
    return false;
}
function updateLayersWithNewColorCount(layerIndex) {
  console.info("layerIndex: " + layerIndex);
  const layerIndexCount = layerIndex - 1;
  const sliderValue = document.getElementById('color-count-slider').value;
  const totalLayers = {{ layers|length }};
  const layers = {{ layers|safe }};

  let distinctColorTolerance = totalLayers > 5 ? 180 : 200;
  let layer = layers[layerIndexCount];
  let canvas = document.getElementById('layer_canvas_' + layerIndex);
  
  // If no canvas found, return early
  if (!canvas) return;

  let ctx = canvas.getContext('2d', { willReadFrequently: true });
  let latestImageData = null;

  // Get current canvas state if it exists
  const currentState = canvas.getAttribute('data-current-state');
  const img = new Image();
  
  img.onload = function() {
      const colorPickerContainer = document.getElementById('color-pickers');
      colorPickerContainer.innerHTML = '';
      
      // Preserve canvas dimensions
      const originalWidth = canvas.width;
      const originalHeight = canvas.height;
      canvas.width = img.width || originalWidth;
      canvas.height = img.height || originalHeight;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0);

      // Save the current state
      layerStates.saveEditedState(layerIndex);

      latestImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const distinctColors = getDistinctColors(imageData, 30, 50);

      console.log('Processing colors for layer:', layerIndex);

      distinctColors.forEach((color, index) => {
          const button = document.createElement('button');
          button.className = 'color-picker';
          button.style.backgroundColor = `rgb(${color.join(',')})`;
          colorPickerContainer.appendChild(button);

          const pickr = Pickr.create({
              el: button,
              theme: 'nano',
              default: `rgb(${color.join(',')})`,
              components: {
                  preview: true,
                  opacity: true,
                  hue: true,
                  interaction: {
                      rgba: true,
                      input: true,
                      hsla: true,
                      save: true,
                  }
              }
          });

          let isProcessing = false;


        pickr.on('save', async (newColor) => {
          if (isProcessing) return;
          isProcessing = true;

          try {
              const rgbaColor = newColor.toRGBA().map(v => Math.round(v));
              // Store the original target color when the picker is created
              // This way, even if distinctColors changes, we keep the original reference
              const currentTargetColor = [...color]; // Use a copy of the original color
              
              // Save state before processing
              layerStates.saveEditedState(layerIndex);
              const rgbColor = rgbaColor.slice(0, 3);
              await processLayerAsync(ctx, currentTargetColor, rgbColor);
              
              // Update UI elements
              updateFooterColorButton(layerIndex, rgbaColor);
              button.style.backgroundColor = `rgba(${rgbaColor.join(',')})`;
              
              // Update the specific color in distinctColors
              distinctColors[index] = rgbaColor.slice(0, 3);
              
              // Update latest image data
              latestImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
              ctx.putImageData(latestImageData, 0, 0);

              // Save the new state after processing
              canvas.setAttribute('data-current-state', canvas.toDataURL());
              
              pickr.hide();
          } catch (error) {
              console.error('Error processing color change:', error);
          } finally {
              setTimeout(() => {
                  isProcessing = false;
              }, 100);
          }
        });

          // Add change event to update preview in real-time
          pickr.on('change', (color) => {
              button.style.backgroundColor = color.toRGBA().toString();
          });
      });
  };

  // Load appropriate image source
  if (currentState) {
      img.src = currentState;
  } else {
      img.src = layer.path;
      // Save original state if it hasn't been saved yet
      if (!layerStates.hasOriginalState(layerIndex)) {
          layerStates.saveOriginalState(layerIndex);
      }
  }

  img.onerror = function(error) {
      console.error('Error loading image:', error);
  };
}
      
      function changeHueWithHueAndLightnessTolerance(ctx, targetColor, newColor, hueTolerance, lightnessTolerance) {
        console.info('Processing Layer with target color:', targetColor, 'and new color:', newColor);
        const canvasWidth = ctx.canvas.width;
        const canvasHeight = ctx.canvas.height;
        const imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
        const data = imageData.data;

        // Convert target and new colors to HSL
        const targetHsl = rgbToHsl(...targetColor);
        const newHsl = rgbToHsl(...newColor);

        // Normalize hue tolerance to fraction (since hue is between 0 and 1 in HSL)
        //const hueToleranceFraction = hueTolerance / 360;
        const hueToleranceFraction = Math.max(0.05, hueTolerance / 360); // Minimum 5% tolerance
        //const lightnessTolerance = Math.max(0.1, lightnessTolerance);   // Minimum 10% tolerance

        for (let i = 0; i < data.length; i += 4) {
            const currentColor = [data[i], data[i + 1], data[i + 2]];
            const currentHsl = rgbToHsl(...currentColor);

            // Calculate hue and lightness differences
            let hueDiff = Math.abs(currentHsl[0] - targetHsl[0]);
            if (hueDiff > 0.5) hueDiff = 1 - hueDiff; // Wrap-around for hue differences
            const lightnessDiff = Math.abs(currentHsl[2] - targetHsl[2]);
            //console.log(`Pixel ${i / 4}: Matches Tolerance (HueDiff: ${hueDiff}, LightnessDiff: ${lightnessDiff})`);
            // Check if the pixel's hue and lightness are within tolerance range
            if (hueDiff <= hueToleranceFraction && lightnessDiff <= lightnessTolerance) {
                //const blendedRgb = hslToRgb(newHsl[0], currentHsl[1], currentHsl[2]);
                const blendedRgb = hslToRgb(newHsl[0], currentHsl[1], currentHsl[2]);

                // Scale RGB values to 0-255 and assign to data array
                data[i] = Math.round(blendedRgb[0] * 255);
                data[i + 1] = Math.round(blendedRgb[1] * 255);
                data[i + 2] = Math.round(blendedRgb[2] * 255);
            }
        }

        ctx.putImageData(imageData, 0, 0);
      }



      {% comment %} fav section starts  {% endcomment %}

function getHarmonyPaletteData(paletteIndex) {
    try {
        // The harmony collections are named based on the harmony type + "PaletteColors"
        const harmonyCollections = [
            'complementaryPaletteColors',
            'analogousPaletteColors', 
            'triadicPaletteColors',
            'splitComplementaryPaletteColors',
            'tetradicPaletteColors',
            'monochromaticPaletteColors',
            'squarePaletteColors'
        ];
        
        let paletteColors = null;
        let harmonyType = 'harmony';
        let collectionName = null;
        
        // Find which collection contains this palette
        for (const collection of harmonyCollections) {
            if (window[collection] && window[collection][paletteIndex]) {
                paletteColors = window[collection][paletteIndex];
                collectionName = collection;
                // Extract harmony type from collection name (remove "PaletteColors" suffix)
                harmonyType = collection.replace('PaletteColors', '');
                break;
            }
        }
        
        if (!paletteColors) {
            console.error('Could not find harmony palette with index:', paletteIndex);
            console.log('Available collections:', harmonyCollections.filter(col => window[col]));
            return null;
        }
        
        // Get background variation if available
        const bgVariation = paletteColors._backgroundVariation || 'regular';
        
        console.log(`Found harmony palette in ${collectionName} with ${paletteColors.length} colors`);
        
        return {
            palette_type: 'HARMONY',
            colors: paletteColors,
            harmony_type: harmonyType,
            background_variation: bgVariation,
            palette_index: parseInt(paletteIndex),
            collection_name: collectionName
        };
        
    } catch (error) {
        console.error('Error getting harmony palette data:', error);
        return null;
    }
}

function toggleFavorite(button, collection) {
  const paletteType = button.dataset.paletteType;
  const colorsId = button.dataset.colorsId;
  const icon = button.querySelector('i');
  const countSpan = button.querySelector('.fav-count');
  
  console.log('DEBUG - toggleFavorite called with:', {
    collection,
    paletteType,
    colorsId
  });
  
  // Handle harmony palettes differently
  let colors;
  let collectionName;
  
  if (collection === 'harmony' || paletteType === 'HARMONY') {
    // For harmony palettes, find which collection contains this palette
    const harmonyCollections = [
      'complementaryPaletteColors',
      'analogousPaletteColors', 
      'triadicPaletteColors',
      'splitComplementaryPaletteColors',
      'tetradicPaletteColors',
      'monochromaticPaletteColors',
      'squarePaletteColors'
    ];
    
    for (const harmonyCollection of harmonyCollections) {
      if (window[harmonyCollection] && window[harmonyCollection][colorsId]) {
        colors = window[harmonyCollection][colorsId];
        collectionName = harmonyCollection.replace('PaletteColors', '');
        console.log('DEBUG - Found harmony collection:', harmonyCollection, 'collectionName:', collectionName);
        break;
      }
    }
  } else {
    // For other palette types, use the original logic
    colors = window[`${collection}PaletteColors`][colorsId];
    collectionName = collection;
  }
  
  if (!colors) {
      console.error('No colors found for this palette');
      return;
  }

  // Get current image colors (no limits)
  const currentImageColors = getCurrentImageColors();
  
  // For harmony palettes, use "HR" as the type
  const finalType = (collection === 'harmony' || paletteType === 'HARMONY') ? 'HR' : paletteType;
  
  // Make a shorter name to avoid database issues
  const shortName = `${collectionName.substring(0, 10)} ${colorsId}`;
  
  const paletteData = {
      name: shortName,
      type: finalType,
      base_color_r: colors[0][0],
      base_color_g: colors[0][1], 
      base_color_b: colors[0][2],
      num_colors: colors.length, // Use actual length
      source_image_colors: currentImageColors, // All source colors
      colors: colors.map(color => ({ // All palette colors
          red: color[0],
          green: color[1],
          blue: color[2]
      }))
  };

  console.log('DEBUG - Final palette data being sent:', paletteData);
  console.log('DEBUG - Colors count:', colors.length, 'Source colors count:', currentImageColors.length);

  // Check if it's harmony (star) or other (heart)
  const isHarmony = collection === 'harmony' || paletteType === 'HARMONY';
  const emptyIcon = isHarmony ? 'bi-star' : 'bi-star';

  if (icon.classList.contains(emptyIcon)) {
      // Add to favorites
      savePalette(paletteData, button);
  } else {
      // Remove from favorites
      removePalette(button.dataset.paletteId);
  }
}

// Updated helper function to get current image colors (no limits)
function getCurrentImageColors() {
    try {
        const storedColors = localStorage.getItem('distinctColorsArrayColorPallet');
        if (storedColors) {
            const parsedColors = JSON.parse(storedColors);
            return parsedColors.filter(color => 
                Array.isArray(color) && 
                color.length === 3 && 
                color.every(v => typeof v === 'number' && !isNaN(v) && v >= 0 && v <= 255)
            ); // No slice limit - return all valid colors
        }
        return [];
    } catch (e) {
        console.error('Error getting current image colors:', e);
        return [];
    }
}




// Helper function to get CSRF token from cookies
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}



  function getColorFamily(color) {
        const [h, s, l] = rgbToHsl(...color);
        
        // Define color families with hue ranges
        if (h >= 345 || h < 15) return 'red';
        if (h >= 15 && h < 45) return 'orange';
        if (h >= 45 && h < 75) return 'yellow';
        if (h >= 75 && h < 165) return 'green';
        if (h >= 165 && h < 195) return 'cyan';
        if (h >= 195 && h < 255) return 'blue';
        if (h >= 255 && h < 285) return 'purple';
        if (h >= 285 && h < 345) return 'pink';
        
        return 'neutral';
    }
// Helper function to get CSRF token from cookies


async function savePalette(paletteData, button) {
  try {
      const response = await fetch('api/palettes/favorite/', {
          method: 'POST',
          headers: {
              'Content-Type': 'application/json',
              'X-CSRFToken': getCookie('csrftoken')
          },
          body: JSON.stringify(paletteData)
      });

      const data = await response.json();
      
      if (response.ok) {
          const icon = button.querySelector('i');
          const countSpan = button.querySelector('.fav-count');
          
          // Check if it's harmony or other palette type
          const paletteType = button.dataset.paletteType;
          const isHarmony = paletteType === 'HARMONY';
          
          if (isHarmony) {
              icon.classList.remove('bi-star');
              icon.classList.add('bi-star-fill');
          } else {
              icon.classList.remove('bi-star');
              icon.classList.add('bi-star-fill');
          }
          
          button.dataset.paletteId = data.palette_id;
          countSpan.textContent = data.favorites_count;
          
          // Refresh favorites section
          loadFavorites();
      }
  } catch (error) {
      console.error('Error saving palette:', error);
  }
}


// Helper function to get current image colors
function getCurrentImageColors() {
    try {
        const storedColors = localStorage.getItem('distinctColorsArrayColorPallet');
        if (storedColors) {
            const parsedColors = JSON.parse(storedColors);
            return parsedColors.filter(color => 
                Array.isArray(color) && 
                color.length === 3 && 
                color.every(v => typeof v === 'number' && !isNaN(v) && v >= 0 && v <= 255)
            );
        }
        return [];
    } catch (e) {
        console.error('Error getting current image colors:', e);
        return [];
    }
}

async function removePalette(paletteId) {
  try {
      const response = await fetch(`api/palettes/favorite/${paletteId}/`, {
          method: 'DELETE',
          headers: {
              'X-CSRFToken': getCookie('csrftoken')
          }
      });

      if (response.ok) {
          const button = document.querySelector(`[data-palette-id="${paletteId}"]`);
          const icon = button.querySelector('i');
          const countSpan = button.querySelector('.fav-count');
          
          // Check if it's harmony or other palette type
          const paletteType = button.dataset.paletteType;
          const isHarmony = paletteType === 'HARMONY';
          
          if (isHarmony) {
              icon.classList.remove('bi-star-fill');
              icon.classList.add('bi-star');
          } else {
              icon.classList.remove('bi-star-fill');
              icon.classList.add('bi-star');
          }
          
          delete button.dataset.paletteId;
          
          const data = await response.json();
          countSpan.textContent = data.favorites_count;
          
          // Refresh favorites section
          loadFavorites();
      }
  } catch (error) {
      console.error('Error removing palette:', error);
  }
}
function rgbToHex(r, g, b) {
    return '#' + [r, g, b].map(x => {
        const hex = x.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
    }).join('');
}
// Update the display function to be more conservative about when to apply adaptation
// Function to analyze color family compatibility
// Extract the sophisticated color analysis logic from displayColorPalette
function analyzeColorRelationships(colors) {
    // Helper functions from the original code
    function rgbToHsl(r, g, b) {
        try {
            r /= 255;
            g /= 255;
            b /= 255;
            
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            
            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            
            return [h * 360, s * 100, l * 100];
        } catch (e) {
            return [Math.random() * 360, 70 + Math.random() * 30, 45 + Math.random() * 25];
        }
    }
    
    function getColorFamily(color) {
        const [h, s, l] = rgbToHsl(...color);
        
        if (h >= 345 || h < 15) return 'red';
        if (h >= 15 && h < 45) return 'orange';
        if (h >= 45 && h < 75) return 'yellow';
        if (h >= 75 && h < 165) return 'green';
        if (h >= 165 && h < 195) return 'cyan';
        if (h >= 195 && h < 255) return 'blue';
        if (h >= 255 && h < 285) return 'purple';
        if (h >= 285 && h < 345) return 'pink';
        
        return 'neutral';
    }
    
    // Group colors by their color families (same as original)
    function groupColorsByFamily(colors) {
        const families = {};
        
        colors.forEach((color, index) => {
            const family = getColorFamily(color);
            if (!families[family]) {
                families[family] = [];
            }
            families[family].push({
                color: color,
                originalIndex: index,
                hsl: rgbToHsl(...color)
            });
        });
        
        // Sort colors within each family by lightness to maintain shade relationships
        Object.keys(families).forEach(family => {
            families[family].sort((a, b) => a.hsl[2] - b.hsl[2]); // Sort by lightness
        });
        
        return families;
    }
    
    // Analyze the color relationships
    const familyGroups = groupColorsByFamily(colors);
    const familyNames = Object.keys(familyGroups);
    
    // Calculate color distribution metrics
    const totalColors = colors.length;
    const familyCount = familyNames.length;
    const averageColorsPerFamily = totalColors / familyCount;
    
    // Calculate color ranges within each family
    const familyRanges = {};
    familyNames.forEach(family => {
        const familyColors = familyGroups[family];
        const lightnesses = familyColors.map(c => c.hsl[2]);
        const saturations = familyColors.map(c => c.hsl[1]);
        
        familyRanges[family] = {
            count: familyColors.length,
            lightnessRange: Math.max(...lightnesses) - Math.min(...lightnesses),
            saturationRange: Math.max(...saturations) - Math.min(...saturations),
            avgLightness: lightnesses.reduce((a, b) => a + b, 0) / lightnesses.length,
            avgSaturation: saturations.reduce((a, b) => a + b, 0) / saturations.length
        };
    });
    
    return {
        familyGroups,
        familyNames,
        familyCount,
        totalColors,
        averageColorsPerFamily,
        familyRanges
    };
}

function analyzePaletteCompatibilityHSL(favoriteColors, currentImageColors) {
    if (!currentImageColors || currentImageColors.length === 0) {
        return { compatible: false, reason: 'No base image colors available' };
    }
    
    if (!favoriteColors || favoriteColors.length === 0) {
        return { compatible: false, reason: 'No favorite palette colors available' };
    }
    
    // Convert all colors to HSL for better comparison
    function rgbToHsl(r, g, b) {
        r /= 255;
        g /= 255;
        b /= 255;
        
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;
        
        if (max === min) {
            h = s = 0;
        } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            
            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }
        
        return [h * 360, s * 100, l * 100];
    }
    
    // Analyze HSL characteristics of a color set
    function analyzeHSLCharacteristics(colors) {
        const hslColors = colors.map(color => rgbToHsl(...color));
        
        // Extract HSL components
        const hues = hslColors.map(hsl => hsl[0]);
        const saturations = hslColors.map(hsl => hsl[1]);
        const lightnesses = hslColors.map(hsl => hsl[2]);
        
        // Calculate statistics
        const avgSaturation = saturations.reduce((a, b) => a + b, 0) / saturations.length;
        const avgLightness = lightnesses.reduce((a, b) => a + b, 0) / lightnesses.length;
        
        const saturationRange = Math.max(...saturations) - Math.min(...saturations);
        const lightnessRange = Math.max(...lightnesses) - Math.min(...lightnesses);
        
        // Analyze hue distribution (handle circular nature of hue)
        const hueSpread = calculateHueSpread(hues);
        const dominantHueRanges = getDominantHueRanges(hues);
        
        return {
            hslColors,
            hues,
            saturations,
            lightnesses,
            avgSaturation,
            avgLightness,
            saturationRange,
            lightnessRange,
            hueSpread,
            dominantHueRanges,
            colorCount: colors.length
        };
    }
    
    // Calculate how spread out hues are (0-180, where 180 is maximum spread)
    function calculateHueSpread(hues) {
        if (hues.length < 2) return 0;
        
        // Sort hues and find the largest gap
        const sortedHues = [...hues].sort((a, b) => a - b);
        let maxGap = 0;
        
        for (let i = 0; i < sortedHues.length - 1; i++) {
            const gap = sortedHues[i + 1] - sortedHues[i];
            maxGap = Math.max(maxGap, gap);
        }
        
        // Check wrap-around gap
        const wrapGap = (360 - sortedHues[sortedHues.length - 1]) + sortedHues[0];
        maxGap = Math.max(maxGap, wrapGap);
        
        // Return the complement of the largest gap (smaller gap = more spread)
        return Math.min(360 - maxGap, 180);
    }
    
    // Get dominant hue ranges (30-degree segments)
    function getDominantHueRanges(hues) {
        const ranges = Array(12).fill(0); // 12 segments of 30 degrees each
        
        hues.forEach(hue => {
            const segment = Math.floor(hue / 30) % 12;
            ranges[segment]++;
        });
        
        return ranges.map((count, index) => ({
            range: index * 30,
            count,
            percentage: count / hues.length * 100
        })).filter(r => r.count > 0);
    }
    
    // Analyze both color sets
    const baseAnalysis = analyzeHSLCharacteristics(currentImageColors);
    const favoriteAnalysis = analyzeHSLCharacteristics(favoriteColors);
    
    console.log(`🎨 HSL Compatibility Analysis:`);
    console.log(`   Base Image HSL:`, {
        avgSat: baseAnalysis.avgSaturation.toFixed(1),
        avgLight: baseAnalysis.avgLightness.toFixed(1),
        satRange: baseAnalysis.saturationRange.toFixed(1),
        lightRange: baseAnalysis.lightnessRange.toFixed(1),
        hueSpread: baseAnalysis.hueSpread.toFixed(1),
        colorCount: baseAnalysis.colorCount
    });
    console.log(`   Favorite HSL:`, {
        avgSat: favoriteAnalysis.avgSaturation.toFixed(1),
        avgLight: favoriteAnalysis.avgLightness.toFixed(1),
        satRange: favoriteAnalysis.saturationRange.toFixed(1),
        lightRange: favoriteAnalysis.lightnessRange.toFixed(1),
        hueSpread: favoriteAnalysis.hueSpread.toFixed(1),
        colorCount: favoriteAnalysis.colorCount
    });
    
    // Calculate compatibility score based on HSL similarities
    let compatibilityScore = 0;
    let reasons = [];
    
    // 1. Saturation compatibility (25 points max)
    const saturationDiff = Math.abs(baseAnalysis.avgSaturation - favoriteAnalysis.avgSaturation);
    const saturationScore = Math.max(0, 25 - (saturationDiff / 4)); // Penalty increases with difference
    compatibilityScore += saturationScore;
    
    if (saturationScore > 15) {
        reasons.push(`Good saturation match (${saturationScore.toFixed(0)}pts)`);
    } else if (saturationScore > 8) {
        reasons.push(`Moderate saturation match (${saturationScore.toFixed(0)}pts)`);
    }
    
    // 2. Lightness compatibility (25 points max)
    const lightnessDiff = Math.abs(baseAnalysis.avgLightness - favoriteAnalysis.avgLightness);
    const lightnessScore = Math.max(0, 25 - (lightnessDiff / 3)); // Penalty increases with difference
    compatibilityScore += lightnessScore;
    
    if (lightnessScore > 15) {
        reasons.push(`Good brightness match (${lightnessScore.toFixed(0)}pts)`);
    } else if (lightnessScore > 8) {
        reasons.push(`Moderate brightness match (${lightnessScore.toFixed(0)}pts)`);
    }
    
    // 3. Hue distribution compatibility (20 points max)
    const hueSpreadDiff = Math.abs(baseAnalysis.hueSpread - favoriteAnalysis.hueSpread);
    const hueSpreadScore = Math.max(0, 20 - (hueSpreadDiff / 9)); // Penalty for very different spreads
    compatibilityScore += hueSpreadScore;
    
    if (hueSpreadScore > 12) {
        reasons.push(`Similar color variety (${hueSpreadScore.toFixed(0)}pts)`);
    }
    
    // 4. Dominant hue overlap (20 points max)
    let hueOverlapScore = 0;
    const baseRanges = new Set(baseAnalysis.dominantHueRanges.map(r => r.range));
    const favoriteRanges = new Set(favoriteAnalysis.dominantHueRanges.map(r => r.range));
    
    // Count overlapping hue ranges
    let overlapCount = 0;
    baseRanges.forEach(range => {
        if (favoriteRanges.has(range)) overlapCount++;
    });
    
    if (baseRanges.size > 0) {
        hueOverlapScore = (overlapCount / Math.max(baseRanges.size, favoriteRanges.size)) * 20;
        compatibilityScore += hueOverlapScore;
        
        if (hueOverlapScore > 10) {
            reasons.push(`Shared color families (${hueOverlapScore.toFixed(0)}pts)`);
        }
    }
    
    // 5. Color range compatibility (10 points max)
    const rangeSimilarity = 1 - Math.abs(baseAnalysis.saturationRange - favoriteAnalysis.saturationRange) / 100;
    const rangeScore = Math.max(0, rangeSimilarity * 10);
    compatibilityScore += rangeScore;
    
    // Apply bonuses and penalties
    
    // Bonus for having enough colors (up to 10 points)
    const colorCountBonus = Math.min(10, Math.min(baseAnalysis.colorCount, favoriteAnalysis.colorCount) / 2);
    compatibilityScore += colorCountBonus;
    
    // Penalty for extreme differences
    if (saturationDiff > 40) {
        compatibilityScore -= 10;
        reasons.push(`Large saturation difference (-10pts)`);
    }
    
    if (lightnessDiff > 30) {
        compatibilityScore -= 10;
        reasons.push(`Large brightness difference (-10pts)`);
    }
    
    // Final score normalization
    compatibilityScore = Math.max(0, Math.min(100, compatibilityScore));
    
    // Determine compatibility based on score
    const isCompatible = compatibilityScore >= 30; // Lowered threshold for more permissive matching
    
    console.log(`   Compatibility Score: ${compatibilityScore.toFixed(1)}/100`);
    console.log(`   Reasons:`, reasons);
    
    const result = {
        compatible: isCompatible,
        compatibilityScore,
        reason: isCompatible ? 
            `Compatible HSL match (${compatibilityScore.toFixed(0)}/100)` : 
            `Poor HSL match (${compatibilityScore.toFixed(0)}/100 - need 30+)`,
        details: {
            saturationDiff: saturationDiff.toFixed(1),
            lightnessDiff: lightnessDiff.toFixed(1),
            hueSpreadDiff: hueSpreadDiff.toFixed(1),
            overlapCount,
            reasons
        },
        baseAnalysis,
        favoriteAnalysis
    };
    
    return result;
}

// Create advanced family mapping using the sophisticated analysis
function createAdvancedFamilyMapping(favoriteAnalysis, baseAnalysis) {
    const mapping = {};
    const usedBaseFamilies = new Set();
    
    // First pass: Direct matches for common families
    favoriteAnalysis.familyNames.forEach(favFamily => {
        if (baseAnalysis.familyNames.includes(favFamily) && !usedBaseFamilies.has(favFamily)) {
            mapping[favFamily] = favFamily;
            usedBaseFamilies.add(favFamily);
            console.log(`✅ Direct family match: ${favFamily} → ${favFamily}`);
        }
    });
    
    // Second pass: Map remaining families by order of richness (most colors first)
    const unmappedFavFamilies = favoriteAnalysis.familyNames.filter(f => !mapping[f]);
    const availableBaseFamilies = baseAnalysis.familyNames.filter(f => !usedBaseFamilies.has(f));
    
    // Sort by color count (richest families first)
    unmappedFavFamilies.sort((a, b) => 
        favoriteAnalysis.familyRanges[b].count - favoriteAnalysis.familyRanges[a].count
    );
    availableBaseFamilies.sort((a, b) => 
        baseAnalysis.familyRanges[b].count - baseAnalysis.familyRanges[a].count
    );
    
    unmappedFavFamilies.forEach((favFamily, index) => {
        if (index < availableBaseFamilies.length) {
            const targetFamily = availableBaseFamilies[index];
            mapping[favFamily] = targetFamily;
            usedBaseFamilies.add(targetFamily);
            console.log(`🔄 Rich family mapping: ${favFamily} (${favoriteAnalysis.familyRanges[favFamily].count} colors) → ${targetFamily} (${baseAnalysis.familyRanges[targetFamily].count} colors)`);
        }
    });
    
    return mapping;
}



// Main function to compare all favorites with all palette categories (STANDALONE)
function syncFavoriteStarsWithAllCategories() {
    console.log('🌟 Starting sync of favorite stars with all categories...');
    
    // Get all favorites first
    fetch('/tif-editor/api/palettes/favorites/')
        .then(response => response.json())
        .then(favorites => {
            console.log(`Found ${favorites.length} favorites to sync`);
            
            if (favorites.length === 0) {
                resetAllStars();
                return;
            }
            
            // Define all possible palette categories and their storage variables
            const categories = [
                { name: 'trending', storageVar: 'trendingPaletteColors', prefix: 'trending_' },
                { name: 'ss', storageVar: 'ssPaletteColors', prefix: 'ss_' },
                { name: 'aw', storageVar: 'awPaletteColors', prefix: 'aw_' },
                // Add all harmony types
                { name: 'monochromatic', storageVar: 'monochromaticPaletteColors', prefix: 'harmony_', harmonyType: 'Monochromatic' },
                { name: 'analogous', storageVar: 'analogousPaletteColors', prefix: 'harmony_', harmonyType: 'Analogous' },
                { name: 'complementary', storageVar: 'complementaryPaletteColors', prefix: 'harmony_', harmonyType: 'Complementary' },
                { name: 'split_complementary', storageVar: 'split_complementaryPaletteColors', prefix: 'harmony_', harmonyType: 'Split Complementary' },
                { name: 'triadic', storageVar: 'triadicPaletteColors', prefix: 'harmony_', harmonyType: 'Triadic' },
                { name: 'tetradic', storageVar: 'tetradicPaletteColors', prefix: 'harmony_', harmonyType: 'Tetradic' },
                { name: 'square', storageVar: 'squarePaletteColors', prefix: 'harmony_', harmonyType: 'Square' }
            ];
            
            // Process each category
            categories.forEach(category => {
                syncCategoryWithFavorites(category, favorites);
            });
            
            console.log('✅ Finished syncing all categories with favorites');
        })
        .catch(error => {
            console.error('Error fetching favorites for sync:', error);
        });
}

function syncCategoryWithFavorites(category, favorites) {
    console.log(`\n🔍 Syncing ${category.name} category...`);
    
    // Get stored palettes for this category
    const categoryPalettes = window[category.storageVar];
    if (!categoryPalettes) {
        console.log(`❌ No stored palettes found for ${category.name} (${category.storageVar})`);
        return;
    }
    
    // Get current image colors for matching
    let currentImageColors = getCurrentImageColors();
    
    // Check each palette in this category
    Object.keys(categoryPalettes).forEach(paletteIndex => {
        const paletteColors = categoryPalettes[paletteIndex];
        if (!paletteColors || paletteColors.length === 0) return;
        
        console.log(`  🎨 Checking ${category.name} palette ${paletteIndex}...`);
        
        // Determine the category type for matching
        let matchingCategoryType;
        if (category.harmonyType) {
            // For harmony palettes, use HARMONY as the type
            matchingCategoryType = 'HARMONY';
        } else {
            matchingCategoryType = category.name.toUpperCase();
        }
        
        // Find matching favorite
        const matchingFavorite = findMatchingFavorite(
            favorites, 
            paletteColors, 
            currentImageColors, 
            matchingCategoryType,
            parseInt(paletteIndex),
            category.harmonyType // Pass harmony type for harmony palettes
        );
        
        // Update the star for this palette
        updateStarForPalette(category, paletteIndex, matchingFavorite);
    });
}

function findMatchingFavorite(favorites, paletteColors, currentImageColors, categoryType, paletteIndex, harmonyType = null) {
    for (const favorite of favorites) {
        let isMatch = false;
        
        // Method 1: Direct type and index matching
        if (favorite.type === categoryType && favorite.palette_index === paletteIndex) {
            console.log(`    ✅ Direct match found: type=${categoryType}, index=${paletteIndex}`);
            isMatch = true;
        }
        
        // Method 2: Harmony-specific matching
        if (!isMatch && harmonyType) {
            // Check if favorite type matches harmony type
            const harmonyTypeMap = {
                'Monochromatic': ['HARMONY', 'HR', 'MONOCHROMATIC'],
                'Analogous': ['HARMONY', 'HR', 'ANALOGOUS'],
                'Complementary': ['HARMONY', 'HR', 'COMPLEMENTARY'],
                'Split Complementary': ['HARMONY', 'HR', 'SPLIT_COMPLEMENTARY'],
                'Triadic': ['HARMONY', 'HR', 'TRIADIC'],
                'Tetradic': ['HARMONY', 'HR', 'TETRADIC'],
                'Square': ['HARMONY', 'HR', 'SQUARE']
            };
            
            const validTypes = harmonyTypeMap[harmonyType] || ['HARMONY', 'HR'];
            
            if (validTypes.includes(favorite.type) && favorite.palette_index === paletteIndex) {
                console.log(`    ✅ Harmony match found: ${harmonyType}, index=${paletteIndex}`);
                isMatch = true;
            }
            
            // Also check if favorite has harmony_type metadata
            if (!isMatch && favorite.harmony_type === harmonyType && favorite.palette_index === paletteIndex) {
                console.log(`    ✅ Harmony metadata match found: ${harmonyType}, index=${paletteIndex}`);
                isMatch = true;
            }
        }
        
        // Method 3: Color similarity matching (if we have current image colors)
        if (!isMatch && currentImageColors && favorite.source_image_colors) {
            const imageColorsMatch = areColorsEqual(currentImageColors, favorite.source_image_colors);
            if (imageColorsMatch) {
                // Check if palette colors are similar
                const favPaletteColors = favorite.colors.map(color => [color.red, color.green, color.blue]);
                const paletteColorsMatch = areColorsSimilar(paletteColors, favPaletteColors, 40);
                
                if (paletteColorsMatch) {
                    console.log(`    ✅ Color similarity match found for ${categoryType} palette ${paletteIndex}`);
                    isMatch = true;
                }
            }
        }
        
        if (isMatch) {
            return favorite;
        }
    }
    
    return null;
}
function updateStarForPalette(category, paletteIndex, matchingFavorite) {
    let favoriteBtn = null;
    
    // For harmony palettes, use harmony-specific button ID
    let buttonId;
    if (category.harmonyType) {
        buttonId = `harmony_fav_btn_${paletteIndex}`;
    } else {
        buttonId = `${category.name}_fav_btn_${paletteIndex}`;
    }
    
    favoriteBtn = document.getElementById(buttonId);
    
    if (!favoriteBtn) {
        // Fallback selectors including harmony-specific ones
        const fallbackSelectors = [
            `[data-palette-type="HARMONY"][data-colors-id="${paletteIndex}"].favorite-btn`,
            `[data-palette-type="${category.name.toUpperCase()}"][data-colors-id="${paletteIndex}"].favorite-btn`,
            `[data-harmony-type="${category.harmonyType}"][data-colors-id="${paletteIndex}"].favorite-btn`,
            `.favorite-btn[data-colors-id="${paletteIndex}"]`
        ];
        
        for (const selector of fallbackSelectors) {
            favoriteBtn = document.querySelector(selector);
            if (favoriteBtn) {
                console.log(`    🎯 Found button with fallback selector: ${selector}`);
                break;
            }
        }
    } else {
        console.log(`    🎯 Found button with ID: ${buttonId}`);
    }
    
    // Rest of the function remains the same...
    if (!favoriteBtn) {
        console.log(`    ❌ Could not find favorite button for ${category.name} palette ${paletteIndex}`);
        return;
    }
    
    const icon = favoriteBtn.querySelector('i');
    const countSpan = favoriteBtn.querySelector('.fav-count');
    
    if (matchingFavorite) {
        console.log(`    ⭐ Filling star for ${category.name} palette ${paletteIndex}`);
        
        if (icon) {
            icon.classList.remove('bi-star');
            icon.classList.add('bi-star-fill');
        }
        
        if (countSpan) {
            countSpan.textContent = matchingFavorite.favorites_count || 1;
        }
        
        favoriteBtn.setAttribute('data-palette-id', matchingFavorite.id);
        favoriteBtn.setAttribute('data-is-favorited', 'true');
        favoriteBtn.classList.add('active');
        
    } else {
        console.log(`    ☆ Emptying star for ${category.name} palette ${paletteIndex}`);
        
        if (icon) {
            icon.classList.remove('bi-star-fill');
            icon.classList.add('bi-star');
        }
        
        if (countSpan) {
            countSpan.textContent = '0';
        }
        
        favoriteBtn.removeAttribute('data-palette-id');
        favoriteBtn.removeAttribute('data-is-favorited');
        favoriteBtn.classList.remove('active');
    }
}
// Helper function to get the correct palette type code
function getPaletteTypeCode(categoryName) {
    const typeMap = {
        'trending': 'TR',
        'ss': 'SS', 
        'aw': 'AW',
        'harmony': 'HARMONY'
    };
    return typeMap[categoryName] || categoryName.toUpperCase();
}
// Helper function to get current image colors
function getCurrentImageColors() {
    try {
        const storedColors = localStorage.getItem('distinctColorsArrayColorPallet');
        if (storedColors) {
            const parsedColors = JSON.parse(storedColors);
            return parsedColors.filter(color => 
                Array.isArray(color) && 
                color.length === 3 && 
                color.every(v => typeof v === 'number' && !isNaN(v) && v >= 0 && v <= 255)
            );
        }
    } catch (e) {
        console.log('Error reading localStorage colors:', e);
    }
    return null;
}

// Function to reset all stars (when no favorites exist)
function resetAllStars() {
    console.log('🔄 Resetting all stars...');
    
    const allFavoriteButtons = document.querySelectorAll('.favorite-btn:not(.active)');
    
    allFavoriteButtons.forEach(btn => {
        const icon = btn.querySelector('i');
        const countSpan = btn.querySelector('.fav-count');
        
        if (icon) {
            icon.classList.remove('bi-star-fill');
            icon.classList.add('bi-star');
        }
        
        if (countSpan) {
            countSpan.textContent = '0';
        }
        
        btn.removeAttribute('data-palette-id');
        btn.removeAttribute('data-is-favorited');
    });
}

// Enhanced areColorsSimilar function with better threshold
function areColorsSimilar(colors1, colors2, threshold = 30) {
    if (!colors1 || !colors2 || colors1.length < 3 || colors2.length < 3) {
        return false;
    }
    
    // Compare first 8 colors from each palette
    const compareCount = Math.min(colors1.length, colors2.length, 8);
    let totalDistance = 0;
    let comparisons = 0;
    
    for (let i = 0; i < compareCount; i++) {
        const color1 = colors1[i];
        const color2 = colors2[i];
        
        if (!color1 || !color2 || color1.length !== 3 || color2.length !== 3) continue;
        
        const distance = Math.sqrt(
            Math.pow(color1[0] - color2[0], 2) +
            Math.pow(color1[1] - color2[1], 2) +
            Math.pow(color1[2] - color2[2], 2)
        );
        
        totalDistance += distance;
        comparisons++;
    }
    
    if (comparisons === 0) return false;
    
    const averageDistance = totalDistance / comparisons;
    const isMatch = averageDistance <= threshold;
    
    console.log(`    📏 Color similarity: avg distance = ${averageDistance.toFixed(1)}, threshold = ${threshold}, match = ${isMatch}`);
    
    return isMatch;
}

function groupColorsByFamily(colors) {
    const families = {};
    
    colors.forEach((color, index) => {
        const family = getColorFamily(color);
        if (!families[family]) {
            families[family] = [];
        }
        families[family].push({
            color: color,
            originalIndex: index,
            hsl: rgbToHsl(...color)
        });
    });
    
    // Sort colors within each family by lightness to maintain shade relationships
    Object.keys(families).forEach(family => {
        families[family].sort((a, b) => a.hsl[2] - b.hsl[2]); // Sort by lightness
    });
    
    return families;
}

// UPDATED loadFavorites function (WITHOUT the sync call)
async function loadFavorites() {
    try {
        const response = await fetch('/tif-editor/api/palettes/favorites/');
        if (!response.ok) throw new Error(`Failed to load favorites`);
        
        const favorites = await response.json();
        console.log("🟢 FRONTEND RECEIVED from API:", favorites.length, "favorites");
        
        const favContainer = document.querySelector('#favCollectionContent .layer-toggles');
        favContainer.innerHTML = '';

        if (favorites.length === 0) {
            showNoFavoritesMessage(0, "You haven't saved any favorite palettes yet.");
            return;
        }

        // Get current image colors
        let currentImageColors = null;
        try {
            const storedColors = localStorage.getItem('distinctColorsArrayColorPallet');
            if (storedColors) {
                const parsedColors = JSON.parse(storedColors);
                currentImageColors = parsedColors.filter(color => 
                    Array.isArray(color) && 
                    color.length === 3 && 
                    color.every(v => typeof v === 'number' && !isNaN(v) && v >= 0 && v <= 255)
                );
            }
        } catch (e) {
            console.log('Error reading localStorage colors:', e);
        }

        if (!currentImageColors || currentImageColors.length < 4) {
            favContainer.innerHTML = `
                <div class="alert alert-warning text-center w-100">
                    <i class="bi bi-exclamation-triangle me-2"></i>
                    <strong>No Image Colors Available</strong>
                    <div class="mt-2 small">
                        Please load an image first to see compatible favorite palettes.
                    </div>
                    <button class="btn btn-sm btn-primary mt-2" onclick="loadFavorites()">
                        <i class="bi bi-arrow-clockwise"></i> Retry
                    </button>
                </div>
            `;
            return;
        }

        console.log(`🎨 Filtering favorites based on current image colors`);

        const matchingFavorites = [];
        const nonMatchingFavorites = [];
        
        favorites.forEach((favorite, originalIndex) => {
            console.log(`\n--- Checking palette "${favorite.name}" (ID: ${favorite.id}) ---`);
            
            if (favorite.source_image_colors && Array.isArray(favorite.source_image_colors) && favorite.source_image_colors.length > 0) {
                const colorsMatch = areColorsEqual(currentImageColors, favorite.source_image_colors);
                
                if (colorsMatch) {
                    const favoriteColors = favorite.colors.map(color => [color.red, color.green, color.blue]);
                    const processedFavorite = { 
                        ...favorite, 
                        colors: favoriteColors, 
                        originalIndex 
                    };
                    matchingFavorites.push(processedFavorite);
                    console.log(`✅ "${favorite.name}" matches current image - added to matching list`);
                } else {
                    nonMatchingFavorites.push({ ...favorite, originalIndex });
                    console.log(`❌ "${favorite.name}" doesn't match current image`);
                }
            } else {
                nonMatchingFavorites.push({ ...favorite, originalIndex });
                console.log(`❌ "${favorite.name}" has no source colors stored`);
            }
        });

        console.log(`\n🎨 Final Results: ${matchingFavorites.length} matching, ${nonMatchingFavorites.length} non-matching`);

        if (matchingFavorites.length === 0) {
            favContainer.innerHTML = `
                <div class="alert alert-warning text-center w-100">
                    <i class="bi bi-exclamation-triangle me-2"></i>
                    <strong>No Matching Palettes Found</strong>
                    <div class="mt-2 small">
                        No saved palettes match your current image colors.
                    </div>
                    <button class="btn btn-sm btn-warning mt-2" onclick="showAllFavoritesOverride()">
                        <i class="bi bi-eye"></i> Show All Anyway
                    </button>
                </div>
            `;
            return;
        }

        // Clear and initialize the favorite palette colors storage
        window.favPaletteColors = {};
        
        // Display matching favorites with appropriate icons
        matchingFavorites.forEach((favorite, displayIndex) => {
            console.log(`\n--- Displaying palette ${displayIndex}: "${favorite.name}" (ID: ${favorite.id}) ---`);
            const colors = favorite.colors;
            console.log('Colors being displayed (first 5):', colors.slice(0, 5));
            
            // Store the colors
            window.favPaletteColors[displayIndex] = colors;
            
            // Determine if this is a harmony palette
            const isHarmony = favorite.type === 'HR' || favorite.type === 'HARMONY';
            const iconClass = isHarmony ? 'bi-star-fill' : 'bi-star-fill';
            
            // Create palette HTML with appropriate icon
            const paletteHtml = `
                <div class="layer-toggle-item d-flex flex-column gap-2" data-favorite-id="${favorite.id}" data-favorite-name="${favorite.name}">
                    <div id="fav_colorPalette_${displayIndex}" class="color-palette d-flex flex-column"></div>
                    <div class="d-flex align-items-center justify-content-center w-100">
                        <button type="button" class="btn favorite-btn active" data-palette-id="${favorite.id}" data-palette-type="${favorite.type}">
                            <i class="${iconClass}"></i>
                            <span class="fav-count">${favorite.favorites_count}</span>
                        </button>
                    </div>
                    <div class="text-center small mt-1">
                        <strong>${favorite.name}</strong>
                        <div class="text-muted" style="font-size: 0.75em;">
                            ${colors.length} colors • 100% match • ${isHarmony ? 'Harmony' : 'Regular'}
                        </div>
                    </div>
                </div>
            `;
            
            favContainer.insertAdjacentHTML('beforeend', paletteHtml);
            
            console.log(`🎨 CALLING displayFavoritePalette for index ${displayIndex}`);
            console.log(`   Input colors (first 5):`, colors.slice(0, 5));
            
            // Call displayFavoritePalette to create the preview interface
            displayFavoritePalette(displayIndex, colors, 'fav', 6, 1);
            
            // Add click event listener for the favorite button to remove from favorites
            const favoriteBtn = document.querySelector(`[data-palette-id="${favorite.id}"]`);
            if (favoriteBtn) {
                favoriteBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent triggering the palette click
                    removeFavorite(favoriteBtn, displayIndex);
                });
            }
        });

        console.log('\n🔍 Final verification of stored palettes:');
        Object.keys(window.favPaletteColors).forEach(key => {
            console.log(`Palette ${key} (first 3):`, window.favPaletteColors[key].slice(0, 3), '...');
        });

    } catch (error) {
        console.error('Error loading favorites:', error);
    }
}

// NEW: Function to update stars in trending/SS/AW/harmony sections based on current image colors
function updatePaletteStarsBasedOnCurrentImage(favorites, currentImageColors = null) {
    console.log('🌟 Updating palette stars based on current image colors...');
    
    // If no current image colors provided, try to get them
    if (!currentImageColors) {
        try {
            const storedColors = localStorage.getItem('distinctColorsArrayColorPallet');
            if (storedColors) {
                const parsedColors = JSON.parse(storedColors);
                currentImageColors = parsedColors.filter(color => 
                    Array.isArray(color) && 
                    color.length === 3 && 
                    color.every(v => typeof v === 'number' && !isNaN(v) && v >= 0 && v <= 255)
                );
            }
        } catch (e) {
            console.log('Error reading localStorage colors:', e);
            return;
        }
    }
    
    if (!currentImageColors || currentImageColors.length < 4) {
        console.log('❌ No current image colors available for star updating');
        return;
    }

    // Get all palette sections
    const sections = ['trending', 'ss', 'aw', 'harmony'];
    
    sections.forEach(sectionType => {
        console.log(`\n🔍 Checking ${sectionType} section...`);
        
        // Get all stored palettes for this section
        const sectionPalettes = window[`${sectionType}PaletteColors`];
        if (!sectionPalettes) {
            console.log(`❌ No stored palettes found for ${sectionType}`);
            return;
        }
        
        // Check each palette in this section
        Object.keys(sectionPalettes).forEach(paletteIndex => {
            const paletteColors = sectionPalettes[paletteIndex];
            if (!paletteColors || paletteColors.length === 0) return;
            
            // Find matching favorite based on image colors and palette colors
            const matchingFavorite = favorites.find(fav => {
                // Check if this favorite matches current image AND this specific palette
                if (!fav.source_image_colors || !areColorsEqual(currentImageColors, fav.source_image_colors)) {
                    return false;
                }
                
                // Check if the favorite's palette colors match this section's palette
                const favPaletteColors = fav.colors.map(color => [color.red, color.green, color.blue]);
                return areColorsSimilar(paletteColors, favPaletteColors, 50);
            });
            
            // Find the favorite button for this palette
            let favoriteBtn = null;
            
            // Method 1: Try to find by palette index and section type
            favoriteBtn = document.querySelector(
                `[data-palette-index="${paletteIndex}"][data-palette-type="${sectionType.toUpperCase()}"] .favorite-btn`
            );
            
            // Method 2: Try alternative selectors
            if (!favoriteBtn) {
                const possibleSelectors = [
                    `#${sectionType}_colorPalette_${paletteIndex} .favorite-btn`,
                    `[data-colors-id="${paletteIndex}"][data-palette-type="${sectionType.toUpperCase()}"]`,
                    `.palette-container[data-index="${paletteIndex}"][data-section="${sectionType}"] .favorite-btn`
                ];
                
                for (const selector of possibleSelectors) {
                    favoriteBtn = document.querySelector(selector);
                    if (favoriteBtn) break;
                }
            }
            
            if (favoriteBtn) {
                const icon = favoriteBtn.querySelector('i');
                const countSpan = favoriteBtn.querySelector('.fav-count');
                
                if (matchingFavorite) {
                    console.log(`✅ Found matching favorite for ${sectionType} palette ${paletteIndex}`);
                    
                    // Fill the star
                    if (icon) {
                        icon.classList.remove('bi-star');
                        icon.classList.add('bi-star-fill');
                    }
                    
                    // Update count
                    if (countSpan) {
                        countSpan.textContent = matchingFavorite.favorites_count || 1;
                    }
                    
                    // Store palette ID for removal functionality
                    favoriteBtn.setAttribute('data-palette-id', matchingFavorite.id);
                } else {
                    // Empty the star
                    if (icon) {
                        icon.classList.remove('bi-star-fill');
                        icon.classList.add('bi-star');
                    }
                    
                    // Reset count
                    if (countSpan) {
                        countSpan.textContent = '0';
                    }
                    
                    // Remove palette ID
                    favoriteBtn.removeAttribute('data-palette-id');
                }
            } else {
                console.log(`❌ Could not find favorite button for ${sectionType} palette ${paletteIndex}`);
            }
        });
    });
    
    console.log('✅ Finished updating palette stars based on current image');
}



function areColorsEqual(colors1, colors2, tolerance = 50) {
    if (!colors1 || !colors2) return false;
    if (colors1.length < 4 || colors2.length < 4) return false;
    
    const compareCount = Math.min(colors1.length, colors2.length, 10);
    let totalSimilarity = 0;
    
    for (let i = 0; i < compareCount; i++) {
        const color1 = colors1[i];
        const color2 = colors2[i];
        
        const distance = Math.sqrt(
            Math.pow(color1[0] - color2[0], 2) +
            Math.pow(color1[1] - color2[1], 2) +
            Math.pow(color1[2] - color2[2], 2)
        );
        
        const similarity = Math.max(0, 100 - (distance / 4.41));
        totalSimilarity += similarity;
    }
    
    const averageSimilarity = totalSimilarity / compareCount;
    const threshold = 70;
    const isMatch = averageSimilarity >= threshold;
    
    console.log(`   Average similarity: ${averageSimilarity.toFixed(1)}% (threshold: ${threshold}%) - ${isMatch ? '✅ MATCH' : '❌ NO MATCH'}`);
    
    return isMatch;
}

function isPaletteCompatibleWithImage(favoriteData, currentImageColors) {
    if (!currentImageColors || currentImageColors.length < 6) return false;
    
    // Get the stored source image colors
    const favoriteSourceColors = favoriteData.source_image_colors;
    
    if (!favoriteSourceColors || favoriteSourceColors.length < 6) {
        console.log(`❌ No source image colors stored for "${favoriteData.name}"`);
        return false;
    }
    
    console.log(`🔍 Comparing current image (${currentImageColors.length} colors) with stored source (${favoriteSourceColors.length} colors)`);
    
    // Take first 10 colors from each
    const currentFirst10 = currentImageColors.slice(0, 10);
    const storedFirst10 = favoriteSourceColors.slice(0, 10);
    
    // Calculate color similarity between the two image color sets
    let totalSimilarity = 0;
    let comparisons = 0;
    
    currentFirst10.forEach(currentColor => {
        let bestSimilarity = 0;
        
        storedFirst10.forEach(storedColor => {
            // Calculate color distance
            const distance = Math.sqrt(
                Math.pow(currentColor[0] - storedColor[0], 2) +
                Math.pow(currentColor[1] - storedColor[1], 2) +
                Math.pow(currentColor[2] - storedColor[2], 2)
            );
            
            // Convert distance to similarity (0-100%)
            const similarity = Math.max(0, 100 - (distance / 4.41)); // 4.41 is max possible distance/100
            bestSimilarity = Math.max(bestSimilarity, similarity);
        });
        
        totalSimilarity += bestSimilarity;
        comparisons++;
    });
    
    const averageSimilarity = totalSimilarity / comparisons;
    const threshold = 70; // Require 70% similarity
    
    console.log(`📊 Image similarity: ${averageSimilarity.toFixed(1)}% (threshold: ${threshold}%)`);
    
    const isCompatible = averageSimilarity >= threshold;
    
    if (isCompatible) {
        console.log(`✅ "${favoriteData.name}" is compatible - similar source images`);
    } else {
        console.log(`❌ "${favoriteData.name}" not compatible - different source images`);
    }
    
    return isCompatible;
}
// Helper function to display all favorites without filtering
function displayAllFavorites(favorites, container) {
    window.favPaletteColors = {};
    
    favorites.forEach((favorite, displayIndex) => {
        const colors = favorite.colors.map(color => [color.red, color.green, color.blue]);
        window.favPaletteColors[displayIndex] = colors;
        
        const paletteHtml = `
            <div class="layer-toggle-item d-flex flex-column gap-2">
                <div id="fav_colorPalette_${displayIndex}" class="color-palette d-flex flex-column"></div>
                <div class="d-flex align-items-center justify-content-between w-100">
                    
                    <button type="button" class="btn favorite-btn active" data-palette-id="${favorite.id}">
                        <i class="bi bi-star-fill"></i>
                        <span class="fav-count">${favorite.favorites_count}</span>
                    </button>
                    
                </div>
                <div class="text-center small">
                    ${favorite.name}
                    <div class="compatibility-info mt-1" style="font-size: 0.75em; color: #6c757d;">
                        No filtering applied
                    </div>
                </div>
            </div>
        `;
        
        container.insertAdjacentHTML('beforeend', paletteHtml);
        displayColorPalette(displayIndex, colors, 'fav', 6, 1);
        
        setupFavoriteEventListeners(displayIndex);
    });
}

// Helper function to display compatible favorites
function displayCompatibleFavorites(compatibleFavorites, container) {
    window.favPaletteColors = {};
    
    compatibleFavorites.forEach((favorite, displayIndex) => {
        const colors = favorite.colors;
        window.favPaletteColors[displayIndex] = colors;
        
        const compatibilityScore = favorite.compatibility.compatibilityScore || 0;
        const topReasons = favorite.compatibility.details.reasons.slice(0, 2);
        
        const paletteHtml = `
            <div class="layer-toggle-item d-flex flex-column gap-2">
                <div id="fav_colorPalette_${displayIndex}" class="color-palette d-flex flex-column"></div>
                <div class="d-flex align-items-center justify-content-between w-100">
                   
                    <button type="button" class="btn favorite-btn active" data-palette-id="${favorite.id}">
                        <i class="bi bi-star-fill"></i>
                        <span class="fav-count">${favorite.favorites_count}</span>
                    </button>
                   
                </div>
                <div class="text-center small">
                    ${favorite.name}
                    <div class="compatibility-info mt-1" style="font-size: 0.75em; color: #28a745;">
                        ✓ ${compatibilityScore.toFixed(0)}/100 HSL match
                        ${topReasons.length > 0 ? '<br>' + topReasons.join(', ') : ''}
                    </div>
                </div>
            </div>
        `;
        
        container.insertAdjacentHTML('beforeend', paletteHtml);
        displayFavoritePalette(displayIndex, colors, 'fav');
        
        setupFavoriteEventListeners(displayIndex);
    });
}

// Helper function to setup event listeners
function setupFavoriteEventListeners(displayIndex) {
    document.getElementById(`fav_shufflePalette_${displayIndex}`).addEventListener('click', () => {
        const colors = window.favPaletteColors[displayIndex];
        displayFavoritePalette(displayIndex, colors, 'fav');
    });
    
    document.getElementById(`fav_applyButton_${displayIndex}`).addEventListener('click', () => {
        const fullPalette = window.favPaletteColors[displayIndex];
        if (typeof window.processPallet === 'function' && fullPalette) {
            console.log(`Applying HSL-compatible favorite palette ${displayIndex}`);
            window.processPallet(null, 1, null, 0, null, fullPalette, displayIndex, 'fav');
        }
    });
}

// Updated helper function for HSL-based no compatible message
function showNoCompatibleFavoritesMessageHSL(incompatibleFavorites, baseColors) {
    const favContainer = document.querySelector('#favCollectionContent .layer-toggles');
    if (favContainer) {
        // Analyze the base image characteristics for user feedback
        function rgbToHsl(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return [h * 360, s * 100, l * 100];
        }
        
        const baseHsl = baseColors.map(color => rgbToHsl(...color));
        const avgSat = baseHsl.reduce((sum, hsl) => sum + hsl[1], 0) / baseHsl.length;
        const avgLight = baseHsl.reduce((sum, hsl) => sum + hsl[2], 0) / baseHsl.length;
        
        let imageCharacteristics = '';
        if (avgSat > 70) imageCharacteristics += 'Very saturated, ';
        else if (avgSat > 40) imageCharacteristics += 'Moderately saturated, ';
        else imageCharacteristics += 'Muted, ';
        
        if (avgLight > 70) imageCharacteristics += 'bright image';
        else if (avgLight > 30) imageCharacteristics += 'balanced lighting';
        else imageCharacteristics += 'dark image';
        
        const bestScore = incompatibleFavorites.length > 0 ? 
            Math.max(...incompatibleFavorites.map(f => f.compatibility.compatibilityScore || 0)) : 0;
        
        favContainer.innerHTML = `
            <div class="alert alert-warning text-center w-100">
                <i class="bi bi-exclamation-triangle me-2"></i>
                <strong>No Compatible Palettes Found</strong>
                <div class="mt-2 small">
                    Your current image (${imageCharacteristics}) doesn't closely match any of your ${incompatibleFavorites.length} saved palettes.
                </div>
                <div class="mt-2 small text-muted">
                    Best compatibility score: ${bestScore.toFixed(0)}/100 (need 30+)
                </div>
                <div class="mt-2">
                    <button class="btn btn-sm btn-outline-primary me-2" onclick="loadFavorites(); this.disabled=true; setTimeout(() => this.disabled=false, 2000);">
                        <i class="bi bi-arrow-clockwise"></i> Retry Analysis
                    </button>
                    <button class="btn btn-sm btn-warning" onclick="showAllFavoritesOverride()">
                        <i class="bi bi-eye"></i> Show All Anyway
                    </button>
                </div>
            </div>
        `;
    }
}


// Update showAllFavoritesOverride to show proper icons
function showAllFavoritesOverride() {
    fetch('/tif-editor/api/palettes/favorites/')
        .then(response => response.json())
        .then(favorites => {
            const favContainer = document.querySelector('#favCollectionContent .layer-toggles');
            favContainer.innerHTML = `
                <div class="alert alert-info text-center w-100 mb-3">
                    <i class="bi bi-info-circle me-2"></i>
                    <strong>Showing All Palettes (Override)</strong>
                    <div class="mt-1 small">Compatibility filtering disabled by user request.</div>
                </div>
            `;
            
            window.favPaletteColors = {};
            
            favorites.forEach((favorite, displayIndex) => {
                const colors = favorite.colors.map(color => [color.red, color.green, color.blue]);
                window.favPaletteColors[displayIndex] = colors;
                
                // Determine if this is a harmony palette
                const isHarmony = favorite.type === 'HR' || favorite.type === 'HARMONY';
                const iconClass = isHarmony ? 'bi-star-fill' : 'bi-star-fill';
                
                const paletteHtml = `
                    <div class="layer-toggle-item d-flex flex-column gap-2">
                        <div id="fav_colorPalette_${displayIndex}" class="color-palette d-flex flex-column"></div>
                        <div class="d-flex align-items-center justify-content-center w-100">
                            <button type="button" class="btn favorite-btn active" data-palette-id="${favorite.id}" data-palette-type="${favorite.type}">
                                <i class="${iconClass}"></i>
                                <span class="fav-count">${favorite.favorites_count}</span>
                            </button>
                        </div>
                        <div class="text-center small mt-1">
                            ${favorite.name}
                            <div class="text-muted" style="font-size: 0.75em;">
                                ${isHarmony ? 'Harmony' : 'Regular'} • ${colors.length} colors
                            </div>
                        </div>
                    </div>
                `;
                
                favContainer.insertAdjacentHTML('beforeend', paletteHtml);
                displayFavoritePalette(displayIndex, colors, 'fav', 6, 1);
                
                // Add remove favorite functionality
                const favoriteBtn = document.querySelector(`[data-palette-id="${favorite.id}"]:last-of-type`);
                if (favoriteBtn) {
                    favoriteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        removeFavorite(favoriteBtn, displayIndex);
                    });
                }
            });
        })
        .catch(error => console.error('Error loading all favorites:', error));
}

// Enhanced filtering info for HSL analysis
function addHSLFilteringInfo(compatibleFavorites, incompatibleFavorites) {
    const favContainer = document.querySelector('#favCollectionContent .layer-toggles');
    if (favContainer) {
        const bestScore = compatibleFavorites.length > 0 ? 
            Math.max(...compatibleFavorites.map(f => f.compatibility.compatibilityScore || 0)) : 0;
        
        const avgScore = compatibleFavorites.length > 0 ?
            compatibleFavorites.reduce((sum, f) => sum + (f.compatibility.compatibilityScore || 0), 0) / compatibleFavorites.length : 0;
        
        const infoDiv = document.createElement('div');
        infoDiv.className = 'alert alert-info text-center w-100 mt-3';
        infoDiv.innerHTML = `
            <i class="bi bi-info-circle me-2"></i>
            <small>
                <strong>HSL Color Analysis Results:</strong><br>
                ${compatibleFavorites.length} compatible palettes (best: ${bestScore.toFixed(0)}/100, avg: ${avgScore.toFixed(0)}/100)<br>
                ${incompatibleFavorites.length} filtered out for poor color harmony match
                <div class="mt-1 text-muted">
                    Analysis considers saturation, brightness, and hue distribution similarity
                </div>
            </small>
        `;
        favContainer.appendChild(infoDiv);
    }
}


// Updated helper function for better compatibility display
function showNoCompatibleFavoritesMessage(incompatibleFavorites) {
    const favContainer = document.querySelector('#favCollectionContent .layer-toggles');
    if (favContainer) {
        // Get unique reasons and group them
        const reasonGroups = {};
        incompatibleFavorites.forEach(fav => {
            const reason = fav.compatibility.reason;
            if (!reasonGroups[reason]) {
                reasonGroups[reason] = 0;
            }
            reasonGroups[reason]++;
        });
        
        const reasonsList = Object.entries(reasonGroups)
            .map(([reason, count]) => `<li>• ${reason} (${count} palette${count > 1 ? 's' : ''})</li>`)
            .join('');
        
        favContainer.innerHTML = `
            <div class="alert alert-warning text-center w-100">
                <i class="bi bi-exclamation-triangle me-2"></i>
                <strong>No Compatible Palettes Found</strong>
                <div class="mt-2 small">
                    Your current image doesn't match any of your ${incompatibleFavorites.length} saved palettes.
                </div>
                <div class="mt-2 small text-muted text-start">
                    <strong>Compatibility issues:</strong>
                    <ul class="mt-1 mb-0" style="text-align: left; display: inline-block;">
                        ${reasonsList}
                    </ul>
                </div>
                <div class="mt-2 small">
                    Try generating new palettes from the Trending section that match your current image.
                </div>
            </div>
        `;
    }
}

// Enhanced filtering info with better details
function addDetailedFilteringInfo(compatibleFavorites, incompatibleFavorites) {
    const favContainer = document.querySelector('#favCollectionContent .layer-toggles');
    if (favContainer) {
        const bestScore = compatibleFavorites.length > 0 ? 
            Math.max(...compatibleFavorites.map(f => f.compatibility.compatibilityScore || 0)) : 0;
        
        const avgScore = compatibleFavorites.length > 0 ?
            compatibleFavorites.reduce((sum, f) => sum + (f.compatibility.compatibilityScore || 0), 0) / compatibleFavorites.length : 0;
        
        const infoDiv = document.createElement('div');
        infoDiv.className = 'alert alert-info text-center w-100 mt-3';
        infoDiv.innerHTML = `
            <i class="bi bi-info-circle me-2"></i>
            <small>
                <strong>Smart Compatibility Analysis:</strong><br>
                Showing ${compatibleFavorites.length} compatible palettes (best: ${bestScore.toFixed(0)}/100, avg: ${avgScore.toFixed(0)}/100)<br>
                ${incompatibleFavorites.length} palettes filtered out due to incompatible color family relationships
                <div class="mt-1 text-muted">
                    Sorted by compatibility score • Higher scores = better matches
                </div>
            </small>
        `;
        favContainer.appendChild(infoDiv);
    }
}

// Make sure getColorFamily function is available
function getColorFamily(color) {
    function rgbToHsl(r, g, b) {
        r /= 255;
        g /= 255;
        b /= 255;
        
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;
        
        if (max === min) {
            h = s = 0;
        } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            
            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }
        
        return [h * 360, s * 100, l * 100];
    }
    
    const [h, s, l] = rgbToHsl(...color);
    
    if (h >= 345 || h < 15) return 'red';
    if (h >= 15 && h < 45) return 'orange';
    if (h >= 45 && h < 75) return 'yellow';
    if (h >= 75 && h < 165) return 'green';
    if (h >= 165 && h < 195) return 'cyan';
    if (h >= 195 && h < 255) return 'blue';
    if (h >= 255 && h < 285) return 'purple';
    if (h >= 285 && h < 345) return 'pink';
    
    return 'neutral';
}
// Update the DOMContentLoaded to delay favorites loading
document.addEventListener('DOMContentLoaded', function() {
    const sidebarLinks = document.querySelectorAll('.sidebar-nav a');
    
    sidebarLinks.forEach(link => {
        link.addEventListener('click', function(e) {
            const targetId = this.getAttribute('href').substring(1);
            
            if (targetId === 'favCollectionContent') {
                // Delay loading to give time for colors to be available
                setTimeout(() => {
                    loadFavorites();
                }, 4000); // Wait 1 second
            }
        });
    });
    
    // If favorites tab is active by default, load with longer delay
    const activeSidebarLink = document.querySelector('.sidebar-nav a.active');
    if (activeSidebarLink && activeSidebarLink.getAttribute('href') === '#favCollectionContent') {
        setTimeout(() => {
            loadFavorites();
        }, 2000); // Wait 2 seconds for initial load
    }
});

// Enhanced filtering info
function addDetailedFilteringInfo(compatibleFavorites, incompatibleFavorites) {
    const favContainer = document.querySelector('#favCollectionContent .layer-toggles');
    if (favContainer) {
        const bestScore = compatibleFavorites.length > 0 ? 
            Math.max(...compatibleFavorites.map(f => f.compatibility.compatibilityScore || 0)) : 0;
        
        const infoDiv = document.createElement('div');
        infoDiv.className = 'alert alert-info text-center w-100 mt-3';
        infoDiv.innerHTML = `
            <i class="bi bi-info-circle me-2"></i>
            <small>
                <strong>Smart Filtering Results:</strong><br>
                Showing ${compatibleFavorites.length} compatible palettes (best score: ${bestScore.toFixed(0)}/100)<br>
                ${incompatibleFavorites.length} palettes filtered out for incompatible color relationships
            </small>
        `;
        favContainer.appendChild(infoDiv);
    }
}

// Helper function to show message when no compatible favorites found
function showNoCompatibleFavoritesMessage(incompatibleFavorites) {
    const favContainer = document.querySelector('#favCollectionContent .layer-toggles');
    if (favContainer) {
        const reasons = [...new Set(incompatibleFavorites.map(f => f.compatibility.reason))];
        
        favContainer.innerHTML = `
            <div class="alert alert-warning text-center w-100">
                <i class="bi bi-exclamation-triangle me-2"></i>
                <strong>No Compatible Palettes Found</strong>
                <div class="mt-2 small">
                    Your current image doesn't match any of your ${incompatibleFavorites.length} saved palettes.
                </div>
                <div class="mt-2 small text-muted">
                    Common reasons:
                    <ul class="list-unstyled mt-1">
                        ${reasons.map(reason => `<li>• ${reason}</li>`).join('')}
                    </ul>
                </div>
                <div class="mt-2 small">
                    Try using the Trending section to generate new palettes for this image.
                </div>
            </div>
        `;
    }
}

// Helper function to add filtering info
function addFilteringInfoMessage(compatibleCount, incompatibleCount) {
    const favContainer = document.querySelector('#favCollectionContent .layer-toggles');
    if (favContainer) {
        const infoDiv = document.createElement('div');
        infoDiv.className = 'alert alert-info text-center w-100 mt-3';
        infoDiv.innerHTML = `
            <i class="bi bi-info-circle me-2"></i>
            <small>
                Showing ${compatibleCount} compatible palettes. 
                ${incompatibleCount} palettes were filtered out as they don't match your current image's color structure.
            </small>
        `;
        favContainer.appendChild(infoDiv);
    }
}

// Update displayFavoritePalette to always apply adaptation for compatible palettes

// Function to remove a favorite
function removeFavorite(button, index) {
    const paletteId = button.dataset.paletteId;
    
    if (!paletteId) {
        console.error('No palette ID found');
        return;
    }
    
    fetch(`/tif-editor/api/palettes/favorite/${paletteId}/`, {
        method: 'DELETE',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken'),
        }
    })
    .then(response => {
        if (!response.ok) {
            return response.json().then(err => { 
                throw new Error(err.error || 'Request failed');
            });
        }
        return response.json();
    })
    .then(data => {
        console.log('Favorite removed:', data);
        
        // Remove the palette from the UI
        const paletteElement = button.closest('.layer-toggle-item');
        if (paletteElement) {
            paletteElement.remove();
        }
        
        // Check if we need to show the "no favorites" message
        const favContainer = document.querySelector('#favCollectionContent .layer-toggles');
        if (favContainer && favContainer.children.length === 0) {
            const numLayers = document.querySelectorAll('[id^="layer_canvas_"]').length || 1;
            showNoFavoritesMessage(numLayers);
        }
    })
    .catch(error => {
        console.error('Error removing favorite:', error);
        {% comment %} alert('Error removing favorite: ' + error.message); {% endcomment %}
    });
}

// Helper function to show "no favorites" message
function showNoFavoritesMessage(numLayers, customMessage = null) {
    const favContainer = document.querySelector('#favCollectionContent .layer-toggles');
    if (favContainer) {
        const message = customMessage || `No favorite palettes found matching ${numLayers} layers.`;
        
        favContainer.innerHTML = `
            <div class="alert alert-info text-center w-100">
                <i class="bi bi-info-circle me-2"></i>
                ${message}
                <br>
                <small class="text-muted">Save some palettes from the Trending section to see them here.</small>
            </div>
        `;
    }
}

// Helper function to show error message
function showErrorMessage(message) {
    const favContainer = document.querySelector('#favCollectionContent .layer-toggles');
    if (favContainer) {
        favContainer.innerHTML = `
            <div class="alert alert-danger text-center w-100">
                <i class="bi bi-exclamation-triangle me-2"></i>
                ${message}
            </div>
        `;
    }
}



// Helper function to get CSRF token
function getCookie(name) {
  let cookieValue = null;
  if (document.cookie && document.cookie !== '') {
      const cookies = document.cookie.split(';');
      for (let i = 0; i < cookies.length; i++) {
          const cookie = cookies[i].trim();
          if (cookie.substring(0, name.length + 1) === (name + '=')) {
              cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
              break;
          }
      }
  }
  return cookieValue;
}



function updateColorCountDisplay() {
         const sliderValue = document.getElementById('color-count-slider').value;
         document.getElementById('color-count-display').innerText = sliderValue;

       }


 
       // Function to convert RGB to HSL
       function rgbToHsl(r, g, b) {
         r /= 255;
         g /= 255;
         b /= 255;

         const max = Math.max(r, g, b);
         const min = Math.min(r, g, b);
         let h, s, l = (max + min) / 2;

         if (max === min) {
             h = s = 0; // Achromatic
         } else {
             const d = max - min;
             s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

             switch (max) {
                 case r:
                     h = (g - b) / d + (g < b ? 6 : 0);
                     break;
                 case g:
                     h = (b - r) / d + 2;
                     break;
                 case b:
                     h = (r - g) / d + 4;
                     break;
             }

             h /= 6;
         }

         return [h, s, l];
       }
       async function generatePallateColors() {
        updateColorCountDisplay();
        const layerIndex = contextMenu.dataset.layerIndex;
        const layerIndexCount = layerIndex - 1;
        const sliderValue = document.getElementById('color-count-slider').value;
    
        const layers = {{ layers|safe }};
        let layer = layers[layerIndexCount];
        let img = new Image();
        img.src = layer.path;
        let canvas = document.getElementById('layer_canvas_'+layerIndex);
        let ctx = canvas.getContext('2d', { willReadFrequently: true });
        let latestImageData = null;
    
        img.onload = async function() {
            const colorPickerContainer = document.getElementById('color-pickers');
            colorPickerContainer.innerHTML = '';
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
    
            // Create ImageColorAnalyzer instance
            const analyzer = new ImageColorAnalyzer();
            const colorAnalysis = await analyzer.analyzeImageColors(img);
    
            // Get all colors including dominant and other colors
            let distinctColors = [colorAnalysis.dominantColor];
            if (colorAnalysis.otherColors) {
                colorAnalysis.otherColors.forEach(color => {
                    distinctColors.push(color.rgb);
                });
            }
    
            // Store original colors
            window.originalColors = [...distinctColors];
    
            // Limit colors based on slider value
            distinctColors = distinctColors.slice(0, parseInt(sliderValue));
    
            // Create color pickers for each distinct color
            distinctColors.forEach((color, index) => {
                const button = document.createElement('button');
                button.className = 'color-picker';
                button.style.backgroundColor = `rgb(${color.join(',')})`;
                
                // Get color name using analyzer
                const colorName = analyzer.getColorGroup(...color);
                button.title = colorName;
                
                document.getElementById('color-pickers').appendChild(button);
    
                const pickr = Pickr.create({
                    el: button,
                    theme: 'nano',
                    default: `rgb(${color.join(',')})`,
                    components: {
                        preview: true,
                        opacity: true,
                        hue: true,
                        interaction: {
                            rgba: true,
                            input: true,
                            hsla: true,
                            save: true,
                        }
                    }
                });
    
                let isProcessing = false;
                pickr.on('save', async (newColor) => {
                    if (isProcessing) return;
                    const rgbaColor = newColor.toRGBA().map(v => Math.round(v));
                    const currentTargetColor = distinctColors[index];
    
                    isProcessing = true;
                    await processLayerAsync(ctx, currentTargetColor, rgbaColor);
                    
                    button.style.backgroundColor = `rgba(${rgbaColor.join(',')})`;
                    distinctColors[index] = rgbaColor.slice(0, 3);
    
                    isProcessing = false;
                    pickr.hide();
                });
            });
    
            // Create a shuffle button for this color set
            const shuffleButton = document.createElement('button');
            shuffleButton.className = 'btn btn-sm btn-secondary mt-2';
            shuffleButton.innerHTML = '<i class="bi bi-shuffle"></i> Shuffle Colors';
            shuffleButton.onclick = async () => {
                const newColorAnalysis = await analyzer.analyzeImageColors(img);
                const newColors = [newColorAnalysis.dominantColor];
                
                if (newColorAnalysis.otherColors) {
                    newColorAnalysis.otherColors.forEach(color => {
                        if (newColors.length < distinctColors.length) {
                            newColors.push(color.rgb);
                        }
                    });
                }
    
                // Update existing color pickers with new colors
                const colorPickers = document.querySelectorAll('#color-pickers .color-picker');
                colorPickers.forEach((picker, index) => {
                    if (newColors[index]) {
                        picker.style.backgroundColor = `rgb(${newColors[index].join(',')})`;
                        distinctColors[index] = newColors[index];
                    }
                });
            };
            
            document.getElementById('color-pickers').appendChild(shuffleButton);
        };
    }


    // Helper function to set up palette buttons consistently
    function setupPaletteButton(buttonId, paletteIndex, collection, targetLayerIndex) {
        const button = document.getElementById(buttonId);
        if (!button) {
            // Button might not exist, especially in single layer mode with multiple palettes
            return;
        }
        com
        
        button.addEventListener('click', async function(event) {
            console.log(`Button clicked: ${buttonId}, applying ${collection} palette ${paletteIndex} to layer ${targetLayerIndex}`);
            
            // Load the original image
            const img = new Image();
            img.src = "{{ layer.path }}";
            
            await new Promise((resolve) => {
                img.onload = resolve;
            });
            
            // Reset canvas to original image
            const canvas = document.getElementById(`layer_canvas_${targetLayerIndex}`);
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0);
            
            // ----- COMPLETELY REPLACED CODE SECTION -----
            
            // Get the full palette directly from storage
            if (!window[`${collection}PaletteColors`]) {
                console.error(`Collection ${collection} not found in storage`);
                return;
            }
            
            if (!window[`${collection}PaletteColors`][paletteIndex]) {
                console.error(`Palette index ${paletteIndex} not found in ${collection}`);
                return;
            }
            
            const fullPalette = window[`${collection}PaletteColors`][paletteIndex];
            console.log(`Using full palette from storage with ${fullPalette.length} colors`);
            
            // Pass the collection name and paletteIndex correctly to processPallet
            await processPallet(
                ctx, 
                totalLayers, 
                canvas, 
                targetLayerIndex, 
                [], 
                collection,  // Pass the collection NAME
                paletteIndex  // Pass the palette INDEX
            );
        });
    }




async function processPallet(layerCtx, totalLayers, layerCanvas, currentLayerIndex, oldColorArray, collection = 'trending', paletteIndex, collectionName = null) {
  // Create and show spinner instead of full loading screen
  const mainContent = document.getElementById('mainContent');
  if (!mainContent) {
    console.error('mainContent div not found');
    return;
  }
  
  // Create spinner overlay
  const spinnerOverlay = document.createElement('div');
  spinnerOverlay.id = 'spinner-overlay';
  spinnerOverlay.style.cssText = `
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(255, 255, 255, 0.8);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 9999;
  `;
  
  // Create spinner
  const spinner = document.createElement('div');
  spinner.style.cssText = `
    width: 50px;
    height: 50px;
    border: 5px solid #f3f3f3;
    border-top: 5px solid #3498db;
    border-radius: 50%;
    animation: spin 1s linear infinite;
  `;
  
  // Add CSS animation for spinner
  if (!document.getElementById('spinner-styles')) {
    const style = document.createElement('style');
    style.id = 'spinner-styles';
    style.textContent = `
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
    `;
    document.head.appendChild(style);
  }
  
  spinnerOverlay.appendChild(spinner);
  
  // Make mainContent relative if it's not already
  const originalPosition = getComputedStyle(mainContent).position;
  if (originalPosition === 'static') {
    mainContent.style.position = 'relative';
  }
  
  mainContent.appendChild(spinnerOverlay);
  
  // Helper function to yield control to the browser
  const yieldToMain = () => {
    return new Promise(resolve => setTimeout(resolve, 0));
  };
  
  // Helper function to process image data in chunks to prevent freezing
  const processImageDataInChunks = async (data, processPixelFn, chunkSize = 10000) => {
    for (let i = 0; i < data.length; i += chunkSize * 4) {
      const endIndex = Math.min(i + chunkSize * 4, data.length);
      
      for (let j = i; j < endIndex; j += 4) {
        processPixelFn(j);
      }
      
      // Yield control to prevent freezing
      await yieldToMain();
    }
  };
  
  const colorProcessor = new ColorProcessor();

  try {
      // Add a small delay to ensure spinner is visible
      await yieldToMain();
      
      // Special handling for arrays passed instead of collection name or favorites
      let fullPalette;
      let actualCollection = collectionName || collection;
      let isHueShifted = false; // NEW: Track if this is a hue-shifted palette
      
      // NEW: Check if this is a favorite palette request
      if (typeof paletteIndex === 'string' && paletteIndex.startsWith('fav_')) {
          const favIndex = parseInt(paletteIndex.split('_')[1], 10);
          console.log(`Processing favorite palette ${favIndex}`);
          
          // Use the generated full palette for this favorite
          if (window.favGeneratedPalettes && window.favGeneratedPalettes[favIndex]) {
              fullPalette = window.favGeneratedPalettes[favIndex];
              actualCollection = 'fav';
          } else if (window.favPaletteColors && window.favPaletteColors[favIndex]) {
              // If we have favorite colors but no generated palette, generate one now
              const baseColors = window.favPaletteColors[favIndex];
              
              // Get current image colors for adaptation
              let newImageColors = null;
              const layer1Canvas = document.getElementById('layer_canvas_1');
              if (layer1Canvas) {
                  const ctx = layer1Canvas.getContext('2d', { willReadFrequently: true });
                  const imageData = ctx.getImageData(0, 0, layer1Canvas.width, layer1Canvas.height);
                  newImageColors = await getDistinctColors(imageData, 30, 50);
              }
              
              // Generate full palette using the function
              fullPalette = regenerateFullPaletteFromFavorite(baseColors, newImageColors);
              
              // Store for future use
              if (!window.favGeneratedPalettes) {
                  window.favGeneratedPalettes = {};
              }
              window.favGeneratedPalettes[favIndex] = fullPalette;
              
              actualCollection = 'fav';
          } else {
              console.error(`No favorite palette found for index ${favIndex}`);
              // Remove spinner and return
              if (spinnerOverlay.parentNode) {
                spinnerOverlay.parentNode.removeChild(spinnerOverlay);
              }
              return;
          }
      } else if (Array.isArray(collection)) {
          // If we're passed an array, use it as the palette
          console.log("Collection parameter is an array with", collection.length, "colors");
          fullPalette = collection;
          
          // If collectionName is explicitly provided, use it
          if (collectionName) {
              actualCollection = collectionName;
              console.log(`Using provided collection name: ${actualCollection}`);
              
              // Update the stored palette colors for future use
              if (!window[`${actualCollection}PaletteColors`]) {
                  window[`${actualCollection}PaletteColors`] = {};
              }
              window[`${actualCollection}PaletteColors`][paletteIndex] = fullPalette;
              
              // NEW: Check if this is hue-shifted
              if (window[`${actualCollection}PaletteHueShifted`] && 
                  window[`${actualCollection}PaletteHueShifted`][paletteIndex]) {
                  isHueShifted = true;
              }
          } else {
              // If no explicit collection name, check if this palette exists in any collection
              // Priority: If we know which collection to use, don't search others
              actualCollection = collection; // Default to original value
              
              // Only search through collections if we don't have a specific collection name
              if (typeof collection !== 'string' || !window[`${collection}PaletteColors`] || !window[`${collection}PaletteColors`][paletteIndex]) {
                  const collectionsToCheck = ['trending', 'ss', 'aw', 'base', 'fav'];
                  let foundFullPalette = false;
                  
                  for (const collName of collectionsToCheck) {
                      if (window[`${collName}PaletteColors`] && 
                          window[`${collName}PaletteColors`][paletteIndex]) {
                          
                          // Make sure we're comparing the right palettes by checking a sample color
                          const storedPalette = window[`${collName}PaletteColors`][paletteIndex];
                          
                          if (storedPalette && storedPalette.length > 0) {
                              console.log(`Found stored palette in ${collName}PaletteColors[${paletteIndex}] with ${storedPalette.length} colors`);
                              fullPalette = storedPalette;
                              actualCollection = collName;
                              foundFullPalette = true;
                              
                              // NEW: Check if this is hue-shifted
                              if (window[`${collName}PaletteHueShifted`] && 
                                  window[`${collName}PaletteHueShifted`][paletteIndex]) {
                                  isHueShifted = true;
                              }
                              break;
                          }
                      }
                  }
              }
          }
      } else {
          // Normal case: collection is a string name like 'trending', 'ss', 'aw', etc.
          console.log(`Looking for palette in ${actualCollection}PaletteColors[${paletteIndex}]`);
          
          if (!window[`${actualCollection}PaletteColors`]) {
              console.error(`No palette collection found for "${actualCollection}"`);
              // Remove spinner and return
              if (spinnerOverlay.parentNode) {
                spinnerOverlay.parentNode.removeChild(spinnerOverlay);
              }
              return;
          }
          
          fullPalette = window[`${actualCollection}PaletteColors`][paletteIndex];
          
          // NEW: Check if this is hue-shifted
          if (window[`${actualCollection}PaletteHueShifted`] && 
              window[`${actualCollection}PaletteHueShifted`][paletteIndex]) {
              isHueShifted = true;
          }
          
          if (!fullPalette || fullPalette.length === 0) {
              console.error(`No palette found for ${actualCollection}[${paletteIndex}]`);
              // Remove spinner and return
              if (spinnerOverlay.parentNode) {
                spinnerOverlay.parentNode.removeChild(spinnerOverlay);
              }
              return;
          }
      }
      
      console.log(`Using full palette with ${fullPalette.length} colors from ${actualCollection}:`);
      console.log(`Is hue-shifted palette: ${isHueShifted}`);
  
      // Yield after setup
      await yieldToMain();
      
      // NEW: Apply hue shifting method for special palettes
      if (isHueShifted) {
          console.log("Applying hue shifting method");
          
          // Get hue shift amount based on palette index
          const hueShifts = [60, 120, 180, 240, 300];
          const hueShift = hueShifts[paletteIndex % hueShifts.length];
          
          if (totalLayers === 1) {
              // Single layer hue shifting
              const layer = 1;
              const layerCanvas = document.getElementById(`layer_canvas_${layer}`);
              if (!layerCanvas) {
                  console.error("Layer canvas not found");
                  // Remove spinner and return
                  if (spinnerOverlay.parentNode) {
                    spinnerOverlay.parentNode.removeChild(spinnerOverlay);
                  }
                  return;
              }
              
              // Save current state before processing
              if (typeof layerStates !== 'undefined' && layerStates.saveEditedState) {
                  layerStates.saveEditedState(layer);
              }
              
              // IMPORTANT: Always start with the original image
              const ctx = layerCanvas.getContext('2d', { willReadFrequently: true });
              
              // First, restore the original image
              if (typeof layerStates !== 'undefined' && layerStates.hasOriginalState && layerStates.hasOriginalState(layer)) {
                  const originalImageData = layerStates.getOriginalState(layer);
                  const originalImg = new Image();
                  await new Promise(resolve => {
                      originalImg.onload = () => {
                          ctx.clearRect(0, 0, layerCanvas.width, layerCanvas.height);
                          ctx.drawImage(originalImg, 0, 0);
                          resolve();
                      };
                      originalImg.src = originalImageData;
                  });
              }
              
              // Yield after image restoration
              await yieldToMain();
              
              // Apply hue shift to the entire image
              const imageData = ctx.getImageData(0, 0, layerCanvas.width, layerCanvas.height);
              const data = imageData.data;
              
              // Convert RGB to HSL helper function
              function rgbToHsl(r, g, b) {
                  r /= 255; g /= 255; b /= 255;
                  const max = Math.max(r, g, b), min = Math.min(r, g, b);
                  let h, s, l = (max + min) / 2;
                  
                  if (max === min) {
                      h = s = 0;
                  } else {
                      const d = max - min;
                      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                      switch (max) {
                          case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                          case g: h = (b - r) / d + 2; break;
                          case b: h = (r - g) / d + 4; break;
                      }
                      h /= 6;
                  }
                  return [h * 360, s * 100, l * 100];
              }
              
              // Convert HSL to RGB helper function
              function hslToRgb(h, s, l) {
                  h /= 360; s /= 100; l /= 100;
                  let r, g, b;
                  
                  if (s === 0) {
                      r = g = b = l;
                  } else {
                      const hue2rgb = (p, q, t) => {
                          if (t < 0) t += 1;
                          if (t > 1) t -= 1;
                          if (t < 1/6) return p + (q - p) * 6 * t;
                          if (t < 1/2) return q;
                          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                          return p;
                      };
                      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                      const p = 2 * l - q;
                      r = hue2rgb(p, q, h + 1/3);
                      g = hue2rgb(p, q, h);
                      b = hue2rgb(p, q, h - 1/3);
                  }
                  return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
              }
              
              // Apply hue shift to every pixel in chunks
              await processImageDataInChunks(data, (i) => {
                  const r = data[i];
                  const g = data[i + 1];
                  const b = data[i + 2];
                  const alpha = data[i + 3];
                  
                  // Skip transparent pixels
                  if (alpha === 0) return;
                  
                  const [h, s, l] = rgbToHsl(r, g, b);
                  let newHue = (h + hueShift) % 360;
                  let newSat = s;
                  let newLight = l;
                  
                  // Apply collection-specific adjustments
                  if (actualCollection === 'ss') {
                      newSat = Math.min(100, s * 1.2);
                      newLight = Math.min(90, Math.max(40, l * 1.1));
                  } else if (actualCollection === 'aw') {
                      newSat = Math.max(20, s * 0.8);
                      newLight = Math.min(80, Math.max(25, l * 0.9));
                  }
                  
                  const [newR, newG, newB] = hslToRgb(newHue, newSat, newLight);
                  
                  data[i] = newR;
                  data[i + 1] = newG;
                  data[i + 2] = newB;
              });
              
              // Put the modified image data back
              ctx.putImageData(imageData, 0, 0);
              
              // Update color buttons with representative colors from the shifted palette
              const colorButtons = document.querySelectorAll('.color-picker');
              fullPalette.slice(0, colorButtons.length).forEach((color, idx) => {
                  if (colorButtons[idx] && colorButtons[idx].dataset.locked !== 'true') {
                      colorButtons[idx].style.backgroundColor = `rgb(${color.join(',')})`;
                  }
              });
              
              // Update footer with safety check
              if (fullPalette[0] && typeof updateFooterColorButton === 'function') {
                  updateFooterColorButton(layer, fullPalette[0]);
              }
              
          } else {
              // Multi-layer hue shifting - process each layer with yielding
              const colorButtons = document.querySelectorAll('.color-picker');
              const unlockedLayers = [];
              
              // Prepare all layers for hue shifting
              for (let layer = 1; layer <= totalLayers; layer++) {
                  const colorButton = document.querySelector(`.color-picker[data-layer-index="${layer-1}"]`);
                  if (!colorButton || colorButton.dataset.locked === 'true') {
                      console.log(`Layer ${layer} is locked or button not found, skipping`);
                      continue;
                  }
                  
                  const layerCanvas = document.getElementById(`layer_canvas_${layer}`);
                  if (!layerCanvas) {
                      console.log(`Canvas not found for layer ${layer}`);
                      continue;
                  }
                  
                  // Save current state before processing
                  if (typeof layerStates !== 'undefined' && layerStates.saveEditedState) {
                      layerStates.saveEditedState(layer);
                  }
                  
                  unlockedLayers.push({ layer, canvas: layerCanvas, button: colorButton });
              }
              
              if (unlockedLayers.length === 0) {
                  console.log('No unlocked layers to process');
                  // Remove spinner and return
                  if (spinnerOverlay.parentNode) {
                    spinnerOverlay.parentNode.removeChild(spinnerOverlay);
                  }
                  return;
              }
              
              // Process layers sequentially to prevent overwhelming the browser
              for (const { layer, canvas, button } of unlockedLayers) {
                  const layerCtx = canvas.getContext('2d', { willReadFrequently: true });
                  
                  // IMPORTANT: Always start with the original image
                  if (typeof layerStates !== 'undefined' && layerStates.hasOriginalState && layerStates.hasOriginalState(layer)) {
                      const originalImageData = layerStates.getOriginalState(layer);
                      const originalImg = new Image();
                      await new Promise(resolve => {
                          originalImg.onload = () => {
                              layerCtx.clearRect(0, 0, canvas.width, canvas.height);
                              layerCtx.drawImage(originalImg, 0, 0);
                              resolve();
                          };
                          originalImg.src = originalImageData;
                      });
                  }
                  
                  // Yield after each layer restoration
                  await yieldToMain();
                  
                  // Apply hue shift to this layer
                  const imageData = layerCtx.getImageData(0, 0, canvas.width, canvas.height);
                  const data = imageData.data;
                  
                  // Convert RGB to HSL helper function
                  function rgbToHsl(r, g, b) {
                      r /= 255; g /= 255; b /= 255;
                      const max = Math.max(r, g, b), min = Math.min(r, g, b);
                      let h, s, l = (max + min) / 2;
                      
                      if (max === min) {
                          h = s = 0;
                      } else {
                          const d = max - min;
                          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                          switch (max) {
                              case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                              case g: h = (b - r) / d + 2; break;
                              case b: h = (r - g) / d + 4; break;
                          }
                          h /= 6;
                      }
                      return [h * 360, s * 100, l * 100];
                  }
                  
                  // Convert HSL to RGB helper function
                  function hslToRgb(h, s, l) {
                      h /= 360; s /= 100; l /= 100;
                      let r, g, b;
                      
                      if (s === 0) {
                          r = g = b = l;
                      } else {
                          const hue2rgb = (p, q, t) => {
                              if (t < 0) t += 1;
                              if (t > 1) t -= 1;
                              if (t < 1/6) return p + (q - p) * 6 * t;
                              if (t < 1/2) return q;
                              if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                              return p;
                          };
                          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                          const p = 2 * l - q;
                          r = hue2rgb(p, q, h + 1/3);
                          g = hue2rgb(p, q, h);
                          b = hue2rgb(p, q, h - 1/3);
                      }
                      return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
                  }
                  
                  // Apply hue shift to every pixel in this layer in chunks
                  await processImageDataInChunks(data, (i) => {
                      const r = data[i];
                      const g = data[i + 1];
                      const b = data[i + 2];
                      const alpha = data[i + 3];
                      
                      // Skip transparent pixels
                      if (alpha === 0) return;
                      
                      const [h, s, l] = rgbToHsl(r, g, b);
                      let newHue = (h + hueShift) % 360;
                      let newSat = s;
                      let newLight = l;
                      
                      // Apply collection-specific adjustments
                      if (actualCollection === 'ss') {
                          newSat = Math.min(100, s * 1.2);
                          newLight = Math.min(90, Math.max(40, l * 1.1));
                      } else if (actualCollection === 'aw') {
                          newSat = Math.max(20, s * 0.8);
                          newLight = Math.min(80, Math.max(25, l * 0.9));
                      }
                      
                      const [newR, newG, newB] = hslToRgb(newHue, newSat, newLight);
                      
                      data[i] = newR;
                      data[i + 1] = newG;
                      data[i + 2] = newB;
                  });
                  
                  // Put the modified image data back
                  layerCtx.putImageData(imageData, 0, 0);
                  
                  // Update button color with representative color from the palette
                  const targetColorIndex = (layer - 1) % fullPalette.length;
                  const targetColor = fullPalette[targetColorIndex];
                  if (targetColor) {
                      button.style.backgroundColor = `rgb(${targetColor.join(',')})`;
                      
                      // Update footer with safety check
                      if (typeof updateFooterColorButton === 'function') {
                          updateFooterColorButton(layer, targetColor);
                      }
                  }
                  
                  // Yield after each layer
                  await yieldToMain();
              }
          }
          
      } else {
          // Original color replacement method for regular palettes (index 5+)
          console.log("Applying color replacement method");
          
          // Yield before heavy processing
          await yieldToMain();
          
          // Now use the full palette for processing
          if (totalLayers === 1) {
              // Single layer optimized processing
              const layer = 1;
              const layerCanvas = document.getElementById(`layer_canvas_${layer}`);
              if (!layerCanvas) {
                  console.error("Layer canvas not found");
                  // Remove spinner and return
                  if (spinnerOverlay.parentNode) {
                    spinnerOverlay.parentNode.removeChild(spinnerOverlay);
                  }
                  return;
              }
              
              // Cache DOM elements and computed values
              const colorButtons = document.querySelectorAll('.color-picker');
              const unlockedButtons = Array.from(colorButtons).filter(button => button.dataset.locked !== 'true');
              
              if (unlockedButtons.length === 0) {
                  console.log('All colors are locked');
                  // Remove spinner and return
                  if (spinnerOverlay.parentNode) {
                    spinnerOverlay.parentNode.removeChild(spinnerOverlay);
                  }
                  return;
              }
              
              // Save current state before processing
              if (typeof layerStates !== 'undefined' && layerStates.saveEditedState) {
                  layerStates.saveEditedState(layer);
              }
              
              // IMPORTANT CHANGE: Always start with the original image
              // Load the original image state instead of working with the current canvas
              const ctx = layerCanvas.getContext('2d', { willReadFrequently: true });
              
              // First, restore the original image
              let originalImageData;
              
              if (typeof layerStates !== 'undefined' && layerStates.hasOriginalState && layerStates.hasOriginalState(layer)) {
                  // Load original image from layer states
                  originalImageData = layerStates.getOriginalState(layer);
                  const originalImg = new Image();
                  await new Promise(resolve => {
                      originalImg.onload = () => {
                          ctx.clearRect(0, 0, layerCanvas.width, layerCanvas.height);
                          ctx.drawImage(originalImg, 0, 0);
                          resolve();
                      };
                      originalImg.src = originalImageData;
                  });
              }
              
              // Yield after image restoration
              await yieldToMain();
              
              // Now get the current image data after restoring the original
              const imageDataUrl = layerCanvas.toDataURL();
              
              // Create array of color mappings to process
              const colorMappings = [];
              
              // IMPORTANT: We need to get the original colors from the original image
              // Analyze the original image to find its colors
              const imageData = ctx.getImageData(0, 0, layerCanvas.width, layerCanvas.height);
              const originalColors = await getDistinctColors(imageData, 30, 50); // Adjust parameters as needed
              
              // Yield after color analysis
              await yieldToMain();
              
              // KEY CHANGE: Track which buttons are locked and their original colors
              const lockedIndexes = new Set();
              Array.from(colorButtons).forEach((button, idx) => {
                  if (button.dataset.locked === 'true') {
                      lockedIndexes.add(idx);
                  }
              });
              
              // Create mappings only for unlocked buttons
              let paletteColorIndex = 0;
              for (let i = 0; i < Math.min(colorButtons.length, originalColors.length); i++) {
                  const button = colorButtons[i];
                  const originalColor = originalColors[i];
                  
                  if (lockedIndexes.has(i)) {
                      // For locked colors, map the original color to itself (no change)
                      colorMappings.push({
                          originalColor,
                          targetColor: originalColor, // Same color so no change happens
                          button
                      });
                  } else {
                      // For unlocked colors, use the next color from the palette
                      const targetColor = fullPalette[paletteColorIndex % fullPalette.length];
                      paletteColorIndex++;
                      
                      if (!targetColor) {
                          console.error(`Target color not found at index ${paletteColorIndex-1}`);
                          continue;
                      }
                  
                      colorMappings.push({
                          originalColor,
                          targetColor,
                          button
                      });
                  }
              }
              
              if (colorMappings.length === 0) {
                  console.error("No valid color mappings to apply");
                  // Remove spinner and return
                  if (spinnerOverlay.parentNode) {
                    spinnerOverlay.parentNode.removeChild(spinnerOverlay);
                  }
                  return;
              }
              
              // Yield before color processing
              await yieldToMain();
              
              // Process all colors in one go
              const processedImageUrl = await colorProcessor.applyMultipleColorMappings(
                  imageDataUrl,
                  colorMappings
              );
              
              // Yield after color processing
              await yieldToMain();
              
              // Load the processed image back to canvas once
              const resultImg = new Image();
              await new Promise(resolve => {
                  resultImg.onload = () => {
                      ctx.clearRect(0, 0, layerCanvas.width, layerCanvas.height);
                      ctx.drawImage(resultImg, 0, 0);
                      
                      // FIXED: Only update colors for unlocked buttons
                      colorMappings.forEach(mapping => {
                          const buttonIndex = Array.from(colorButtons).indexOf(mapping.button);
                          // Only update if the button is not locked
                          if (!lockedIndexes.has(buttonIndex)) {
                              mapping.button.style.backgroundColor = `rgb(${mapping.targetColor.join(',')})`;
                          }
                      });
                      
                      resolve();
                  };
                  resultImg.src = processedImageUrl;
              });
              
              // Update footer once - with safety check
              if (fullPalette[0] && typeof updateFooterColorButton === 'function') {
                  updateFooterColorButton(layer, fullPalette[0]);
              }
              
          } else {
              // Multi-layer processing - process sequentially with yielding
              const colorButtons = document.querySelectorAll('.color-picker');
              const unlockedLayers = [];
              const colorMappingsPerLayer = new Map();
              
              // Prepare all color mappings first to minimize DOM access
              for (let layer = 1; layer <= totalLayers; layer++) {
                  const colorButton = document.querySelector(`.color-picker[data-layer-index="${layer-1}"]`);
                  if (!colorButton) {
                      console.log(`No color button found for layer ${layer}`);
                      continue;
                  }
                  
                  if (colorButton.dataset.locked === 'true') {
                      console.log(`Layer ${layer} is locked, skipping processing`);
                      continue;
                  }
                  
                  const layerCanvas = document.getElementById(`layer_canvas_${layer}`);
                  if (!layerCanvas) {
                      console.log(`Canvas not found for layer ${layer}`);
                      continue;
                  }
                  
                  // Save current state before processing
                  if (typeof layerStates !== 'undefined' && layerStates.saveEditedState) {
                      layerStates.saveEditedState(layer);
                  }
                  
                  // For multi-layer, we'll handle the original image restoration inside the processing loop
                  unlockedLayers.push({
                      layer,
                      canvas: layerCanvas,
                      button: colorButton
                  });
                  
                  // Get target color (cycle through the full palette)
                  const targetColorIndex = (layer - 1) % fullPalette.length;
                  const targetColor = fullPalette[targetColorIndex];
                  
                  if (!targetColor) {
                      console.error(`Target color not found at index ${targetColorIndex} for layer ${layer}`);
                      continue;
                  }
                  
                  // We'll determine the original color during processing
                  colorMappingsPerLayer.set(layer, {
                      targetColor
                  });
              }
              
              if (unlockedLayers.length === 0) {
                  console.log('No unlocked layers to process');
                  // Remove spinner and return
                  if (spinnerOverlay.parentNode) {
                    spinnerOverlay.parentNode.removeChild(spinnerOverlay);
                  }
                  return;
              }
              
              // Process layers sequentially to prevent overwhelming the browser
              for (const { layer, canvas, button } of unlockedLayers) {
                  const layerCtx = canvas.getContext('2d', { willReadFrequently: true });
                  const mapping = colorMappingsPerLayer.get(layer);
                  
                  if (!mapping) {
                      console.error(`No color mapping found for layer ${layer}`);
                      continue;
                  }
                  
                  // IMPORTANT: Always start with the original image
                  let originalImageData;
                  
                  if (typeof layerStates !== 'undefined' && layerStates.hasOriginalState && layerStates.hasOriginalState(layer)) {
                      // Load original image from layer states
                      originalImageData = layerStates.getOriginalState(layer);
                      const originalImg = new Image();
                      await new Promise(resolve => {
                          originalImg.onload = () => {
                              layerCtx.clearRect(0, 0, canvas.width, canvas.height);
                              layerCtx.drawImage(originalImg, 0, 0);
                              resolve();
                          };
                          originalImg.src = originalImageData;
                      });
                  }
                  
                  // Yield after each layer restoration
                  await yieldToMain();
                  
                  // Now get the current image data after restoring the original
                  const imageDataUrl = canvas.toDataURL();
                  
                  // Analyze the original image data to find its dominant color
                  const imageData = layerCtx.getImageData(0, 0, canvas.width, canvas.height);
                  const originalColors = await getDistinctColors(imageData, 30, 50); // Adjust parameters as needed
                  
                  if (originalColors.length === 0) {
                      console.error(`No original colors found for layer ${layer}`);
                      continue;
                  }
                  
                  // Use the first original color
                  const originalColor = originalColors[0];
                  mapping.originalColor = originalColor;
                  
                  // Yield before processing
                  await yieldToMain();
                  
                  // Now process with the original color and target color
                  const processedImageUrl = await colorProcessor.applyColorMapping(
                      imageDataUrl,
                      await colorProcessor.getColorMapping(imageDataUrl),
                      mapping.targetColor,
                      mapping.originalColor
                  );
                  
                  // Yield after processing
                  await yieldToMain();
                  
                  // Load the processed image back to canvas
                  const resultImg = new Image();
                  await new Promise(resolve => {
                      resultImg.onload = () => {
                          layerCtx.clearRect(0, 0, canvas.width, canvas.height);
                          layerCtx.drawImage(resultImg, 0, 0);
                          
                          // Update button color
                          button.style.backgroundColor = `rgb(${mapping.targetColor.join(',')})`;
                          
                          // Update footer with safety check
                          if (typeof updateFooterColorButton === 'function') {
                              updateFooterColorButton(layer, mapping.targetColor);
                          }
                          
                          resolve();
                      };
                      resultImg.src = processedImageUrl;
                  });
                  
                  // Yield after each layer
                  await yieldToMain();
              }
          }
      }
  } catch (error) {
      console.error("Error while processing pallet:", error);
      console.error("Error details:", error.stack);
  } finally {
      // Remove spinner
      if (spinnerOverlay.parentNode) {
        spinnerOverlay.parentNode.removeChild(spinnerOverlay);
      }
      
      // Restore original position if we changed it
      if (originalPosition === 'static') {
        mainContent.style.position = 'static';
      }
  }
}



function getRandomColor() {
  const r = Math.floor(Math.random() * 256);
  const g = Math.floor(Math.random() * 256);
  const b = Math.floor(Math.random() * 256);
  return [r, g, b];
}


function updateFooterColorButton(layerIndex, newColor) {
    const colorButton = document.querySelector(`.color-picker[data-layer-index="${layerIndex-1}"]`);
    if (colorButton) {
        colorButton.style.backgroundColor = Array.isArray(newColor) ? 
            `rgb(${newColor.join(',')})` : newColor;
    }
}


class ImageColorAnalyzer {
    constructor() {
        this.logger = console;
        this.cv = null;
        this.isReady = false;
        this.initializationPromise = null;
    }

    async initialize() {
        // If already initialized, return
        if (this.isReady) return;

        // If initialization is in progress, return the existing promise
        if (this.initializationPromise) {
            return this.initializationPromise;
        }

        this.initializationPromise = new Promise((resolve, reject) => {
            // Check if OpenCV is already loaded
            if (typeof cv !== 'undefined') {
                this.cv = cv;
                this.isReady = true;
                resolve();
                return;
            }

            // Check if the script is already being loaded
            const existingScript = document.querySelector('script[src*="opencv.js"]');
            if (existingScript) {
                existingScript.addEventListener('load', () => {
                    this.cv = cv;
                    this.isReady = true;
                    resolve();
                });
                existingScript.addEventListener('error', () => {
                    reject(new Error('Failed to load OpenCV.js'));
                });
                return;
            }

            // Load OpenCV if not already loading
            const script = document.createElement('script');
            script.src = 'https://docs.opencv.org/4.8.0/opencv.js';
            script.async = true;
            script.type = 'text/javascript';

            // Only set Module if it's not already defined
            if (typeof window.Module === 'undefined') {
                window.Module = {
                    onRuntimeInitialized: () => {
                        this.cv = cv;
                        this.isReady = true;
                        resolve();
                    }
                };
            }

            script.onerror = () => {
                reject(new Error('Failed to load OpenCV.js'));
            };

            document.body.appendChild(script);
        });

        return this.initializationPromise;
    }

    rgbToLab(r, g, b) {
        // Convert RGB to XYZ
        r = r / 255;
        g = g / 255;
        b = b / 255;

        // RGB to XYZ conversion
        r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
        g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
        b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;

        r *= 100;
        g *= 100;
        b *= 100;

        const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
        const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
        const z = r * 0.0193 + g * 0.1192 + b * 0.9505;

        // XYZ to Lab conversion
        const xn = 95.047;
        const yn = 100.000;
        const zn = 108.883;

        const fx = x / xn > 0.008856 ? Math.pow(x / xn, 1/3) : (7.787 * x / xn) + 16/116;
        const fy = y / yn > 0.008856 ? Math.pow(y / yn, 1/3) : (7.787 * y / yn) + 16/116;
        const fz = z / zn > 0.008856 ? Math.pow(z / zn, 1/3) : (7.787 * z / zn) + 16/116;

        const L = (116 * fy) - 16;
        const a = 500 * (fx - fy);
        const b_val = 200 * (fy - fz);

        return [L, a, b_val];
    }

    calculateColorDifference(lab1, lab2) {
        // Delta E 2000 calculation (simplified version)
        const deltaL = lab2[0] - lab1[0];
        const deltaA = lab2[1] - lab1[1];
        const deltaB = lab2[2] - lab1[2];

        return Math.sqrt(
            Math.pow(deltaL, 2) +
            Math.pow(deltaA, 2) +
            Math.pow(deltaB, 2)
        );
    }

    async analyzeImageColors(imageElement) {
        if (!this.isReady) {
            await this.initialize();
        }

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = imageElement.width;
        canvas.height = imageElement.height;
        ctx.drawImage(imageElement, 0, 0);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const pixels = imageData.data;

        // Store colors with their frequency and LAB values
        const colorMap = new Map();
        const totalPixels = pixels.length / 4;

        // Sample pixels (analyze every 4th pixel for performance)
        for (let i = 0; i < pixels.length; i += 16) {
            const r = pixels[i];
            const g = pixels[i + 1];
            const b = pixels[i + 2];
            const a = pixels[i + 3];

            // Skip transparent pixels
            if (a < 127) continue;

            const key = `${r},${g},${b}`;
            const lab = this.rgbToLab(r, g, b);

            if (colorMap.has(key)) {
                colorMap.get(key).count++;
            } else {
                colorMap.set(key, {
                    rgb: [r, g, b],
                    lab: lab,
                    count: 1
                });
            }
        }

        // Convert map to array for processing
        let colors = Array.from(colorMap.values());

        // Merge similar colors
        const mergedColors = [];
        const threshold = 5; // Color difference threshold

        while (colors.length > 0) {
            const baseColor = colors[0];
            let totalCount = baseColor.count;
            const similarColors = [baseColor];

            // Find and merge similar colors
            for (let i = 1; i < colors.length; i++) {
                const diff = this.calculateColorDifference(baseColor.lab, colors[i].lab);
                if (diff < threshold) {
                    totalCount += colors[i].count;
                    similarColors.push(colors[i]);
                }
            }

            // Calculate weighted average color
            const avgColor = similarColors.reduce((acc, curr) => {
                const weight = curr.count / totalCount;
                return {
                    rgb: [
                        acc.rgb[0] + curr.rgb[0] * weight,
                        acc.rgb[1] + curr.rgb[1] * weight,
                        acc.rgb[2] + curr.rgb[2] * weight
                    ]
                };
            }, { rgb: [0, 0, 0] });

            mergedColors.push({
                rgb: avgColor.rgb.map(Math.round),
                percentage: (totalCount / (totalPixels / 4)) * 100
            });

            // Remove processed colors
            colors = colors.filter(c => !similarColors.includes(c));
        }

        // Sort by percentage and group by basic color categories
        const colorGroups = {};
        
        mergedColors.sort((a, b) => b.percentage - a.percentage)
            .forEach(color => {
                const colorGroup = this.getColorGroup(...color.rgb);
                
                if (!colorGroups[colorGroup]) {
                    colorGroups[colorGroup] = {
                        totalPercentage: 0,
                        shades: []
                    };
                }

                colorGroups[colorGroup].shades.push({
                    rgb: color.rgb,
                    percentage: color.percentage
                });
                colorGroups[colorGroup].totalPercentage += color.percentage;
            });

        // Sort and format results
        const sortedGroups = Object.entries(colorGroups)
            .map(([name, data]) => ({
                name,
                totalPercentage: data.totalPercentage,
                dominantShade: data.shades.sort((a, b) => b.percentage - a.percentage)[0]
            }))
            .sort((a, b) => b.totalPercentage - a.totalPercentage);

        const dominantGroup = sortedGroups[0];
        const otherColors = sortedGroups.slice(1, 5).map(group => ({
            colorName: group.name,
            rgb: group.dominantShade.rgb,
            percentage: group.totalPercentage
        }));



        const [h, s, l] = this.rgbToHsl(...dominantGroup.dominantShade.rgb);

        return {
            dominantColor: dominantGroup.dominantShade.rgb,
            dominantColorName: dominantGroup.name,
            dominantPercentage: dominantGroup.totalPercentage,
            otherColors: otherColors,
            hue: h * 360,
            saturation: s * 100,
            lightness: l * 100
        };
    }

    rgbToHsl(r, g, b) {
        r /= 255;
        g /= 255;
        b /= 255;

        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;

        if (max === min) {
            h = s = 0;
        } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }

            h /= 6;
        }

        return [h, s, l];
    }

    getColorGroup(r, g, b) {
    const [h, s, l] = this.rgbToHsl(r, g, b);
    const hue = h * 360;

    // Define color ranges by hue
    if (l < 0.1) return 'black';
    if (l > 0.9 && s < 0.1) return 'white';
    if (s < 0.15 && l > 0.1 && l < 0.9) return 'gray';

    // Hue-based color grouping
    if ((hue >= 345 || hue <= 10) && s > 0.15) return 'red';
    if (hue > 10 && hue <= 45) return 'orange';
    if (hue > 45 && hue <= 65) return 'yellow';
    if (hue > 65 && hue <= 170) return 'green';
    if (hue > 170 && hue <= 190) return 'cyan';
    if (hue > 190 && hue <= 260) return 'blue';
    if (hue > 260 && hue <= 320) return 'magenta';
    if (hue > 320 && hue <= 345) return 'purple';

    return 'other';
}
}

class ColorProcessor {
  constructor() {
        this.EPSILON = 0.0001;
        this.COLOR_SIMILARITY_THRESHOLD = 30;
        this.COLOR_QUANTIZATION_STEP = 15; // Added for color quantization
        this.cv = null; // Will store OpenCV instance
        
        // Bind methods
        this.applyColorMapping = this.applyColorMapping.bind(this);
   
       
        this.rgbToHsvProcessor = this.rgbToHsvProcessor.bind(this);
        this.hsvToRgbProcessor = this.hsvToRgbProcessor.bind(this);
        this.quantizeColor = this.quantizeColor.bind(this)
    }

    rgbToLab(rgb) {
      // First, convert RGB to XYZ using D65 illuminant
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;

      // Convert to sRGB space
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;

      // Convert to XYZ space
      const x = (r * 0.4124564 + g * 0.3575761 + b * 0.1804375) * 100;
      const y = (r * 0.2126729 + g * 0.7151522 + b * 0.0721750) * 100;
      const z = (r * 0.0193339 + g * 0.1191920 + b * 0.9503041) * 100;

      // Convert XYZ to Lab
      const xn = 95.047;
      const yn = 100.000;
      const zn = 108.883;

      const fx = x / xn > 0.008856 ? Math.pow(x / xn, 1/3) : (903.3 * x / xn + 16) / 116;
      const fy = y / yn > 0.008856 ? Math.pow(y / yn, 1/3) : (903.3 * y / yn + 16) / 116;
      const fz = z / zn > 0.008856 ? Math.pow(z / zn, 1/3) : (903.3 * z / zn + 16) / 116;

      const L = Math.max(0, 116 * fy - 16);
      const a = 500 * (fx - fy);
      const c = 200 * (fy - fz);

      return [L, a, c];
  }

  rgbToHsvProcessor(rgb) {
        const r = rgb[0] / 255;
        const g = rgb[1] / 255;
        const b = rgb[2] / 255;
        
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        const diff = max - min;
        
        let h = 0;
        if (max === min) {
            h = 0;
        } else if (max === r) {
            h = (60 * ((g - b) / diff) + 360) % 360;
        } else if (max === g) {
            h = (60 * ((b - r) / diff) + 120) % 360;
        } else {
            h = (60 * ((r - g) / diff) + 240) % 360;
        }
        
        const s = max === 0 ? 0 : diff / max;
        const v = max;
        
        return [h, s, v];
    }







   
    isColorSimilar(color1, color2) {
    const hsv1 = this.rgbToHsvProcessor(color1);
    const hsv2 = this.rgbToHsvProcessor(color2);
    
    // Calculate hue difference
    let hueDiff = Math.abs(hsv1[0] - hsv2[0]);
    if (hueDiff > 180) hueDiff = 360 - hueDiff;
    
    // Make the similarity check more strict
    const saturationThreshold = (hsv1[1] < 0.1 || hsv2[1] < 0.1) ? 0.1 : 0.2;
    
    return (
        (hueDiff < 20 || (hsv1[1] < 0.1 && hsv2[1] < 0.1)) && // Stricter hue check
        Math.abs(hsv1[1] - hsv2[1]) < saturationThreshold && 
        Math.abs(hsv1[2] - hsv2[2]) < 0.3
    );
}
quantizeColor(rgb) {
    return rgb.map(v => Math.round(v / this.COLOR_QUANTIZATION_STEP) * this.COLOR_QUANTIZATION_STEP);
}
calculateColorDistance(lab1, lab2) {
    // Use Delta E 2000 instead of Euclidean distance for more perceptually accurate color differences
    const kL = 1;
    const kC = 1;
    const kH = 1;
    
    const deltaL = lab1[0] - lab2[0];
    const L1 = lab1[0], L2 = lab2[0];
    const a1 = lab1[1], a2 = lab2[1];
    const b1 = lab1[2], b2 = lab2[2];
    
    const C1 = Math.sqrt(a1 * a1 + b1 * b1);
    const C2 = Math.sqrt(a2 * a2 + b2 * b2);
    const deltaC = C1 - C2;
    
    const deltaA = a1 - a2;
    const deltaB = b1 - b2;
    
    const deltaH = Math.sqrt(deltaA * deltaA + deltaB * deltaB - deltaC * deltaC);
    
    const SL = 1;
    const SC = 1 + 0.045 * (C1 + C2) / 2;
    const SH = 1 + 0.015 * (C1 + C2) / 2;
    
    return Math.sqrt(
        Math.pow(deltaL / (kL * SL), 2) +
        Math.pow(deltaC / (kC * SC), 2) +
        Math.pow(deltaH / (kH * SH), 2)
    );
}

    findSimilarColors(currentLab, shades, threshold = 25) {
        return shades.filter(shade => 
            this.calculateColorDistance(currentLab, shade.lab) < threshold
        );
    }

async getColorMapping(imageData) {
      return new Promise((resolve) => {
          const img = new Image();
          img.onload = () => {
              const canvas = document.createElement('canvas');
              const ctx = canvas.getContext('2d');
              canvas.width = img.width;
              canvas.height = img.height;
              ctx.drawImage(img, 0, 0);
              
              const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
              const pixels = imgData.data;
              const totalPixels = pixels.length / 4;
              
              // Store colors with their frequency and LAB values
              const colorMap = new Map();
  
              // Analyze every pixel for better accuracy
              for (let i = 0; i < pixels.length; i += 4) {
                  const r = pixels[i];
                  const g = pixels[i + 1];
                  const b = pixels[i + 2];
                  const a = pixels[i + 3];
  
                  // Skip fully transparent pixels and pure black/white
                  if (a < 127) continue;
                  if (r === 0 && g === 0 && b === 0) continue;
                  if (r === 255 && g === 255 && b === 255) continue;
  
                  const key = `${r},${g},${b}`;
                  const lab = this.rgbToLab([r, g, b]);
                  const hsv = this.rgbToHsv(r, g, b);
  
                  if (colorMap.has(key)) {
                      colorMap.get(key).count++;
                  } else {
                      colorMap.set(key, {
                          rgb: [r, g, b],
                          lab: lab,
                          hsv: hsv,
                          count: 1
                      });
                  }
              }
  
              // Convert map to array for processing
              let colors = Array.from(colorMap.values());
  
              // Initial filtering of insignificant colors
              colors = colors.filter(color => 
                  (color.count / totalPixels) * 100 > 0.1 && // More than 0.1% of image
                  color.hsv[1] > 0.05 // Has some saturation
              );
  
              // Merge similar colors with adaptive threshold
              const mergedColors = [];
              const baseThreshold = 5; // Base threshold for color difference
  
              while (colors.length > 0) {
                  const baseColor = colors[0];
                  let totalCount = baseColor.count;
                  const similarColors = [baseColor];
  
                  // Adaptive threshold based on color properties
                  const adaptiveThreshold = this.calculateAdaptiveThreshold(baseColor, baseThreshold);
  
                  // Find and merge similar colors
                  for (let i = 1; i < colors.length; i++) {
                      const diff = this.calculateColorDistance(baseColor.lab, colors[i].lab);
                      const hsvDiff = this.calculateHSVDifference(baseColor.hsv, colors[i].hsv);
                      
                      if (diff < adaptiveThreshold || hsvDiff < 0.15) {
                          totalCount += colors[i].count;
                          similarColors.push(colors[i]);
                      }
                  }
  
                  // Calculate weighted average color
                  const avgColor = similarColors.reduce((acc, curr) => {
                      const weight = curr.count / totalCount;
                      return {
                          rgb: [
                              acc.rgb[0] + curr.rgb[0] * weight,
                              acc.rgb[1] + curr.rgb[1] * weight,
                              acc.rgb[2] + curr.rgb[2] * weight
                          ]
                      };
                  }, { rgb: [0, 0, 0] });
  
                  const finalRGB = avgColor.rgb.map(Math.round);
                  mergedColors.push({
                      rgb: finalRGB,
                      lab: this.rgbToLab(finalRGB),
                      hsv: this.rgbToHsv(...finalRGB),
                      percentage: (totalCount / totalPixels) * 100
                  });
  
                  // Remove processed colors
                  colors = colors.filter(c => !similarColors.includes(c));
              }
  
              // Sort by perceptual importance (combination of frequency and distinctiveness)
              mergedColors.sort((a, b) => {
                  const aScore = this.calculateColorImportance(a);
                  const bScore = this.calculateColorImportance(b);
                  return bScore - aScore;
              });
  
              // Get distinct colors while maintaining relationships
              const distinctColors = this.filterDistinctColors(mergedColors);
  
              // Get base color and shades
              const baseColor = distinctColors[0].rgb;
              const shades = distinctColors.map(color => ({
                  original: color.rgb,
                  lab: color.lab,
                  hsv: color.hsv,
                  frequency: color.percentage,
                  distance: this.calculateColorDistance(color.lab, distinctColors[0].lab)
              }));
  
              resolve({
                  baseColor,
                  shades
              });
          };
          img.src = imageData;
      });
  }
  // Add this new method to the ColorProcessor class





  async applyDirectColorMapping(imageData, colorMappings) {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        console.time('directColorMapping');
        const canvasElement = document.createElement('canvas');
        const ctx = canvasElement.getContext('2d');
        canvasElement.width = img.width;
        canvasElement.height = img.height;
  
        ctx.drawImage(img, 0, 0);
        const imageDataObj = ctx.getImageData(0, 0, img.width, img.height);
        const data = imageDataObj.data;
        
        // Function to convert RGB to HSV for better comparison
        function rgbToHsv(r, g, b) {
          r /= 255; g /= 255; b /= 255;
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          const d = max - min;
          let h, s = max === 0 ? 0 : d / max, v = max;
  
          if (max === min) {
            h = 0;
          } else {
            switch (max) {
              case r: h = (g - b) / d + (g < b ? 6 : 0); break;
              case g: h = (b - r) / d + 2; break;
              case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
          }
          return [h * 360, s * 100, v * 100];
        }
        
        function hsvToRgb(h, s, v) {
          h /= 360; s /= 100; v /= 100;
          let r, g, b;
          
          if (s === 0) {
            r = g = b = v;
          } else {
            const i = Math.floor(h * 6);
            const f = h * 6 - i;
            const p = v * (1 - s);
            const q = v * (1 - f * s);
            const t = v * (1 - (1 - f) * s);
            
            switch (i % 6) {
              case 0: r = v, g = t, b = p; break;
              case 1: r = q, g = v, b = p; break;
              case 2: r = p, g = v, b = t; break;
              case 3: r = p, g = q, b = v; break;
              case 4: r = t, g = p, b = v; break;
              case 5: r = v, g = p, b = q; break;
            }
          }
          
          return [
            Math.round(r * 255),
            Math.round(g * 255),
            Math.round(b * 255)
          ];
        }
        
        // Prepare color mappings with HSV values
        const preparedMappings = colorMappings.map(mapping => {
          const { originalColor, targetColor } = mapping;
          return {
            originalRgb: originalColor,
            targetRgb: targetColor,
            originalHsv: rgbToHsv(...originalColor),
            targetHsv: rgbToHsv(...targetColor)
          };
        });
        
        // Use a cache for transformed colors
        const transformCache = new Map();
        
        // Process each pixel
        for (let i = 0; i < data.length; i += 4) {
          if (data[i + 3] < 128) continue; // Skip transparent pixels
          
          const r = data[i];
          const g = data[i + 1];
          const b = data[i + 2];
          
          // Skip absolute black
          if (r <= 3 && g <= 3 && b <= 3) continue;
          
          // Check cache for this color
          const colorKey = `${r},${g},${b}`;
          if (transformCache.has(colorKey)) {
            const newColor = transformCache.get(colorKey);
            data[i] = newColor[0];
            data[i + 1] = newColor[1];
            data[i + 2] = newColor[2];
            continue;
          }
          
          // Find the best matching mapping
          let bestMatch = null;
          let minDistance = Infinity;
          
          // Convert pixel to HSV
          const pixelHsv = rgbToHsv(r, g, b);
          
          // Find closest match
          for (const mapping of preparedMappings) {
            const { originalRgb, originalHsv } = mapping;
            
            // Calculate RGB distance (primary metric)
            const rgbDistance = Math.sqrt(
              Math.pow(r - originalRgb[0], 2) +
              Math.pow(g - originalRgb[1], 2) +
              Math.pow(b - originalRgb[2], 2)
            );
            
            // Also consider HSV for better matching
            let hueDiff = Math.abs(pixelHsv[0] - originalHsv[0]);
            if (hueDiff > 180) hueDiff = 360 - hueDiff;
            
            const satDiff = Math.abs(pixelHsv[1] - originalHsv[1]);
            const valDiff = Math.abs(pixelHsv[2] - originalHsv[2]);
            
            // Lower weight for hue if saturation is low
            const hueWeight = pixelHsv[1] < 20 ? 0.1 : 0.6;
            
            // Combined distance (RGB and HSV)
            const distance = rgbDistance * 0.7 + ((hueDiff/180) * hueWeight + satDiff/100 + valDiff/100) * 30;
            
            if (distance < minDistance) {
              minDistance = distance;
              bestMatch = mapping;
            }
          }
          
          // Transform the color if we found a match
          if (bestMatch && minDistance < 100) {
            const { originalHsv, targetHsv } = bestMatch;
            
            // Preserve relative brightness and saturation
            const relativeBrightness = originalHsv[2] > 0 ? pixelHsv[2] / originalHsv[2] : 1;
            const relativeSaturation = originalHsv[1] > 0 ? pixelHsv[1] / originalHsv[1] : 1;
            
            // Apply transformation with preserved relationships
            const newHue = targetHsv[0];
            const newSat = Math.min(100, targetHsv[1] * relativeSaturation);
            const newVal = Math.min(100, targetHsv[2] * relativeBrightness);
            
            // Convert back to RGB
            const newColor = hsvToRgb(newHue, newSat, newVal);
            
            // Apply the new color
            data[i] = newColor[0];
            data[i + 1] = newColor[1];
            data[i + 2] = newColor[2];
            
            // Cache the transformation
            transformCache.set(colorKey, newColor);
          }
        }
  
        // Apply changes
        ctx.putImageData(imageDataObj, 0, 0);
        const dataUrl = canvasElement.toDataURL('image/png');
        console.timeEnd('directColorMapping');
        resolve(dataUrl);
      };
      img.src = imageData;
    });
  }



  async applyMultipleColorMappingsextra(imageData, colorMappings) {
    return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
            console.time('colorMapping');
            const canvasElement = document.createElement('canvas');
            const ctx = canvasElement.getContext('2d');
            canvasElement.width = img.width;
            canvasElement.height = img.height;

            ctx.drawImage(img, 0, 0);
            const imageDataObj = ctx.getImageData(0, 0, img.width, img.height);
            const data = imageDataObj.data;
            const width = img.width;
            const height = img.height;

            // Color conversion utilities
            function rgbToHsv(r, g, b) {
                r /= 255; g /= 255; b /= 255;
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                const d = max - min;
                let h, s = max === 0 ? 0 : d / max, v = max;

                if (max === min) {
                    h = 0;
                } else {
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    h /= 6;
                }
                return [h * 360, s * 100, v * 100];
            }

            function hsvToRgb(h, s, v) {
                h /= 360; s /= 100; v /= 100;
                let r, g, b;
                const i = Math.floor(h * 6);
                const f = h * 6 - i;
                const p = v * (1 - s);
                const q = v * (1 - f * s);
                const t = v * (1 - (1 - f) * s);

                switch (i % 6) {
                    case 0: r = v; g = t; b = p; break;
                    case 1: r = q; g = v; b = p; break;
                    case 2: r = p; g = v; b = t; break;
                    case 3: r = p; g = q; b = v; break;
                    case 4: r = t; g = p; b = v; break;
                    case 5: r = v; g = p; b = q; break;
                }

                return [
                    Math.round(r * 255),
                    Math.round(g * 255),
                    Math.round(b * 255)
                ];
            }
            
            // IMPROVED: More flexible color family detection for blurry images
            function sameColorFamily(color1, color2) {
                const [r1, g1, b1] = color1;
                const [r2, g2, b2] = color2;
                
                // Convert to HSV for better comparison
                const hsv1 = rgbToHsv(r1, g1, b1);
                const hsv2 = rgbToHsv(r2, g2, b2);
                
                // Check if both are achromatic (black, white, gray)
                const isAchromatic1 = hsv1[1] < 20; // More lenient threshold
                const isAchromatic2 = hsv2[1] < 20; 
                
                // If both are achromatic, compare by value (brightness)
                if (isAchromatic1 && isAchromatic2) {
                    // Allow more variance in brightness for achromatic colors
                    return Math.abs(hsv1[2] - hsv2[2]) < 40; // More lenient
                }
                
                // If one is achromatic and the other not, they're different families
                if (isAchromatic1 !== isAchromatic2) {
                    return false;
                }
                
                // For chromatic colors, check hue similarity with adaptive threshold
                // Calculate hue difference with wrap-around
                let hueDiff = Math.abs(hsv1[0] - hsv2[0]);
                if (hueDiff > 180) hueDiff = 360 - hueDiff;
                
                // For very dark or low saturation colors, hue is less reliable
                const areBothDark = hsv1[2] < 35 && hsv2[2] < 35;
                const lowSaturation = hsv1[1] < 40 || hsv2[1] < 40;
                
                // Adapt thresholds based on color properties
                // CHANGE: Tighter hue threshold (40 → 30) for better handling of many colors
                const hueThreshold = areBothDark || lowSaturation ? 45 : 30;
                const satThreshold = areBothDark ? 50 : 40;
                
                // Colors in the same family should have similar hue and not too different saturation
                return hueDiff < hueThreshold && 
                       Math.abs(hsv1[1] - hsv2[1]) < satThreshold;
            }
            
            // IMPROVED: Better gradient detection for blurry images
            function detectGradients() {
                // Store gradient information
                const gradientMap = new Array(width * height).fill(false);
                const gradientStrengthMap = new Array(width * height).fill(0);
                
                // First pass: detect gradient pixels with more sensitivity
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const centerIdx = (y * width + x) * 4;
                        if (data[centerIdx + 3] < 128) continue; // Skip transparent
                        
                        const centerColor = [data[centerIdx], data[centerIdx + 1], data[centerIdx + 2]];
                        const centerHsv = rgbToHsv(...centerColor);
                        
                        // Adaptive thresholds - more sensitive for blurry images
                        const minDiffThreshold = Math.max(2, 5 - centerHsv[1] * 0.05);
                        const maxDiffThreshold = 60 + (1 - centerHsv[1]/100) * 20;
                        
                        // Check neighbors
                        let maxDiff = 0;
                        let hasGradient = false;
                        
                        // Check in all directions for better detection
                        const directions = [
                            { dx: -1, dy: 0 }, { dx: 1, dy: 0 },
                            { dx: 0, dy: -1 }, { dx: 0, dy: 1 },
                            { dx: -1, dy: -1 }, { dx: 1, dy: -1 },
                            { dx: -1, dy: 1 }, { dx: 1, dy: 1 }
                        ];
                        
                        for (const { dx, dy } of directions) {
                            const nx = x + dx;
                            const ny = y + dy;
                            
                            if (nx < 0 || nx >= width || ny < 0 || ny >= height) continue;
                            
                            const neighborIdx = (ny * width + nx) * 4;
                            if (data[neighborIdx + 3] < 128) continue;
                            
                            const neighborColor = [data[neighborIdx], data[neighborIdx + 1], data[neighborIdx + 2]];
                            
                            // Calculate color difference
                            const diff = Math.sqrt(
                                Math.pow(centerColor[0] - neighborColor[0], 2) +
                                Math.pow(centerColor[1] - neighborColor[1], 2) +
                                Math.pow(centerColor[2] - neighborColor[2], 2)
                            );
                            
                            // More relaxed condition for gradients
                            if (diff > minDiffThreshold && diff < maxDiffThreshold) {
                                // For very subtle gradients, don't strictly require same family
                                if (diff < 15 || sameColorFamily(centerColor, neighborColor)) {
                                    hasGradient = true;
                                    maxDiff = Math.max(maxDiff, diff);
                                }
                            }
                        }
                        
                        if (hasGradient) {
                            gradientMap[y * width + x] = true;
                            gradientStrengthMap[y * width + x] = Math.min(1, maxDiff / maxDiffThreshold);
                        }
                    }
                }
                
                // Second pass: expand gradient regions more aggressively
                const expandedGradientMap = [...gradientMap];
                
                // Multiple expansion passes for better coverage
                for (let pass = 0; pass < 2; pass++) {
                    for (let y = 1; y < height - 1; y++) {
                        for (let x = 1; x < width - 1; x++) {
                            const pixelIndex = y * width + x;
                            if (expandedGradientMap[pixelIndex] || data[(pixelIndex * 4) + 3] < 128) continue;
                            
                            // Check if surrounded by gradient pixels
                            let gradientNeighbors = 0;
                            
                            for (let dy = -2; dy <= 2; dy++) {
                                for (let dx = -2; dx <= 2; dx++) {
                                    if (dx === 0 && dy === 0) continue;
                                    
                                    const nx = x + dx;
                                    const ny = y + dy;
                                    
                                    if (nx < 0 || nx >= width || ny < 0 || ny >= height) continue;
                                    
                                    const nIndex = ny * width + nx;
                                    
                                    if (expandedGradientMap[nIndex]) {
                                        // Weight by distance
                                        gradientNeighbors += (Math.abs(dx) + Math.abs(dy) <= 2) ? 1 : 0.5;
                                    }
                                }
                            }
                            
                            // More aggressive expansion for blurry images
                            if (gradientNeighbors >= 1.5) {
                                expandedGradientMap[pixelIndex] = true;
                                gradientStrengthMap[pixelIndex] = 0.6;
                            }
                        }
                    }
                }
                
                return { gradientMap: expandedGradientMap, gradientStrengthMap };
            }
            
            // Identify color families with improved logic
            function identifyColorFamilies() {
                const colorFamilies = [];
                const pixelFamilyMap = new Array(width * height).fill(-1);
                
                // Process pixels to form initial color families
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const pixelIndex = y * width + x;
                        const colorIdx = pixelIndex * 4;
                        
                        if (data[colorIdx + 3] < 128) continue; // Skip transparent
                        
                        // Skip if already assigned to a family
                        if (pixelFamilyMap[pixelIndex] !== -1) continue;
                        
                        const pixelColor = [data[colorIdx], data[colorIdx + 1], data[colorIdx + 2]];
                        
                        // Only skip pure black (almost zero in all channels)
                        if (pixelColor[0] <= 3 && pixelColor[1] <= 3 && pixelColor[2] <= 3) continue;
                        
                        // CHANGE: For many colors, be more selective about family membership
                        // Check if this color fits into an existing family with stricter thresholds
                        let foundFamily = false;
                        
                        // CHANGE: Only check recent families first to improve performance with many colors
                        const startIdx = Math.max(0, colorFamilies.length - 50);
                        for (let i = startIdx; i < colorFamilies.length; i++) {
                            const family = colorFamilies[i];
                            
                            // Check if color belongs to this family with improved detection
                            if (sameColorFamily(pixelColor, family.referenceColor)) {
                                // Add to family
                                family.pixels.push(pixelIndex);
                                family.sumR += pixelColor[0];
                                family.sumG += pixelColor[1];
                                family.sumB += pixelColor[2];
                                family.count++;
                                
                                pixelFamilyMap[pixelIndex] = i;
                                foundFamily = true;
                                break;
                            }
                        }
                        
                        // If no matching family in recent ones, check older ones
                        if (!foundFamily && startIdx > 0) {
                            for (let i = 0; i < startIdx; i++) {
                                const family = colorFamilies[i];
                                
                                if (sameColorFamily(pixelColor, family.referenceColor)) {
                                    // Add to family
                                    family.pixels.push(pixelIndex);
                                    family.sumR += pixelColor[0];
                                    family.sumG += pixelColor[1];
                                    family.sumB += pixelColor[2];
                                    family.count++;
                                    
                                    pixelFamilyMap[pixelIndex] = i;
                                    foundFamily = true;
                                    break;
                                }
                            }
                        }
                        
                        // If no matching family, create a new one
                        if (!foundFamily) {
                            const familyIndex = colorFamilies.length;
                            colorFamilies.push({
                                referenceColor: pixelColor,
                                pixels: [pixelIndex],
                                sumR: pixelColor[0],
                                sumG: pixelColor[1],
                                sumB: pixelColor[2],
                                count: 1,
                                mappingIndex: -1 // Will be set later
                            });
                            
                            pixelFamilyMap[pixelIndex] = familyIndex;
                        }
                    }
                }
                
                // Calculate average color for each family
                colorFamilies.forEach(family => {
                    family.avgColor = [
                        Math.round(family.sumR / family.count),
                        Math.round(family.sumG / family.count),
                        Math.round(family.sumB / family.count)
                    ];
                    
                    // Also calculate HSV for easier comparisons
                    family.hsv = rgbToHsv(...family.avgColor);
                });
                
                console.log(`Identified ${colorFamilies.length} color families`);
                return { colorFamilies, pixelFamilyMap };
            }
            
            // Process color mappings
            function prepareColorMappings() {
                return colorMappings.map((mapping, index) => {
                    const { originalColor, targetColor } = mapping;
                    
                    // Convert to HSV for easier transformations
                    const originalHsv = rgbToHsv(...originalColor);
                    const targetHsv = rgbToHsv(...targetColor);
                    
                    // Calculate transformation parameters more explicitly
                    let hueShift = targetHsv[0] - originalHsv[0];
                    if (hueShift > 180) hueShift -= 360;
                    else if (hueShift < -180) hueShift += 360;
                    
                    // Calculate more precise ratios to maintain the exact relationship
                    const satRatio = originalHsv[1] > 5 ? targetHsv[1] / originalHsv[1] : 1;
                    const valRatio = originalHsv[2] > 5 ? targetHsv[2] / originalHsv[2] : 1;
                    
                    // Include the original button reference to maintain the exact mapping relationship
                    return {
                        originalColor,
                        targetColor,
                        originalHsv,
                        targetHsv,
                        hueShift,
                        satRatio,
                        valRatio,
                        index,
                        buttonReference: mapping.button // Store the button reference
                    };
                });
            }
            
            // IMPROVED: Better mapping for more colors
            function mapFamiliesToMappings(colorFamilies, processedMappings) {
                // CHANGE: For each color family, find the best matching source color
                // When dealing with many colors, we need more precise mapping
                colorFamilies.forEach(family => {
                    let bestMappingIndex = -1;
                    let bestScore = Infinity;
                    
                    for (let i = 0; i < processedMappings.length; i++) {
                        const mapping = processedMappings[i];
                        
                        // Calculate weighted distance in both RGB and HSV space
                        // RGB distance for precise matching
                        const rgbDistance = Math.sqrt(
                            Math.pow(family.avgColor[0] - mapping.originalColor[0], 2) +
                            Math.pow(family.avgColor[1] - mapping.originalColor[1], 2) +
                            Math.pow(family.avgColor[2] - mapping.originalColor[2], 2)
                        );
                        
                        // HSV comparison for perceptual matching
                        const familyHsv = family.hsv;
                        const mappingHsv = mapping.originalHsv;
                        
                        // Calculate hue difference with wrap-around
                        let hueDiff = Math.abs(familyHsv[0] - mappingHsv[0]);
                        if (hueDiff > 180) hueDiff = 360 - hueDiff;
                        
                        // Weight the components differently
                        const isAchromatic = familyHsv[1] < 15 || mappingHsv[1] < 15;
                        
                        let score;
                        if (isAchromatic) {
                            // For achromatic colors, focus on brightness
                            score = (rgbDistance * 0.3) + (Math.abs(familyHsv[2] - mappingHsv[2]) * 2);
                        } else {
                            // For chromatic colors, prioritize hue match
                            score = (rgbDistance * 0.3) + (hueDiff * 0.5) + 
                                    (Math.abs(familyHsv[1] - mappingHsv[1]) * 0.3) + 
                                    (Math.abs(familyHsv[2] - mappingHsv[2]) * 0.2);
                        }
                        
                        if (score < bestScore) {
                            bestScore = score;
                            bestMappingIndex = i;
                        }
                    }
                    
                    // CHANGE: Use a threshold that scales with the number of color mappings
                    // More colors need more relaxed threshold to ensure proper mapping
                    const threshold = 60 + Math.min(40, processedMappings.length * 2);
                    
                    if (bestScore < threshold) {
                        family.mappingIndex = bestMappingIndex;
                    } else {
                        // For families without a good match, leave unmapped
                        family.mappingIndex = -1;
                    }
                });
            }
            
            // IMPROVED: Better color transformation logic
            function transformColor(r, g, b, mappingIndex, isGradient = false, gradientStrength = 0) {
                // Get the mapping
                const mapping = processedMappings[mappingIndex];
                
                // Get color in HSV space
                const pixelHsv = rgbToHsv(r, g, b);
                
                // Check if colors are very close to the original mapping color
                const originalRGB = mapping.originalColor;
                const rgbDistance = Math.sqrt(
                    Math.pow(r - originalRGB[0], 2) +
                    Math.pow(g - originalRGB[1], 2) +
                    Math.pow(b - originalRGB[2], 2)
                );
                
                // If very close to original color, use target color directly
                if (rgbDistance < 10) {
                    return mapping.targetColor;
                }
                
                // Check if color is achromatic (low saturation)
                const isAchromatic = pixelHsv[1] < 15;
                const isDark = pixelHsv[2] < 30;
                
                // Calculate relative brightness compared to the original mapping color
                // This is crucial for preserving shading and transparency effects
                const relativeBrightness = mapping.originalHsv[2] > 0 ? 
                    pixelHsv[2] / mapping.originalHsv[2] : 1;
                
                // Calculate hue difference with wrap-around handling
                let hueDiff = ((pixelHsv[0] - mapping.originalHsv[0] + 360) % 360);
                hueDiff = hueDiff > 180 ? hueDiff - 360 : hueDiff;
                
                // For saturation, calculate the relative value
                const relativeSaturation = mapping.originalHsv[1] > 0 ? 
                    pixelHsv[1] / mapping.originalHsv[1] : 1;
                
                // Different transformation strategy based on pixel characteristics
                let newHue, newSat, newVal;
                
                if (isAchromatic) {
                    // For grayscale, adopt target hue but preserve relative brightness
                    newHue = mapping.targetHsv[0];
                    
                    // Keep very low saturation for achromatic colors
                    newSat = Math.min(10, pixelHsv[1]);
                    
                    // Crucial: Preserve relative brightness for shading effects
                    newVal = Math.max(0, Math.min(100, mapping.targetHsv[2] * relativeBrightness));
                } 
                else if (isGradient) {
                    // For gradients, preserve the relative brightness even more carefully
                    
                    // Use target hue but adjust based on original variations for natural gradients
                    newHue = (mapping.targetHsv[0] + hueDiff * 0.3) % 360;
                    if (newHue < 0) newHue += 360;
                    
                    // Blend saturation but respect original variations
                    newSat = Math.max(5, Math.min(100, mapping.targetHsv[1] * relativeSaturation));
                    
                    // Most important: accurately preserve relative brightness
                    newVal = Math.max(0, Math.min(100, mapping.targetHsv[2] * relativeBrightness));
                } 
                else {
                    // For regular pixels, carefully preserve shading
                    if (isDark) {
                        // For dark areas, maintain darkness but use target hue
                        newHue = mapping.targetHsv[0];
                        newSat = Math.min(100, mapping.targetHsv[1] * 0.7);
                        
                        // Preserve darkness but map to target's darkness range
                        // This ensures dark areas remain distinguishable but adopt target color
                        newVal = Math.max(0, Math.min(40, mapping.targetHsv[2] * relativeBrightness));
                    } 
                    else {
                        // For normal colors, preserve shading variations
                        newHue = mapping.targetHsv[0];
                        
                        // Maintain saturation relationship to preserve texture
                        newSat = Math.max(0, Math.min(100, mapping.targetHsv[1] * relativeSaturation));
                        
                        // Crucial: accurately preserve brightness relationships
                        newVal = Math.max(0, Math.min(100, mapping.targetHsv[2] * relativeBrightness));
                    }
                }
                
                // Convert back to RGB
                return hsvToRgb(newHue, newSat, newVal);
            }
            
            // Main processing pipeline
            
            // Step 1: Detect gradients
            console.log("Detecting gradients...");
            const { gradientMap, gradientStrengthMap } = detectGradients();
            
            // Step 2: Identify color families
            console.log("Identifying color families...");
            const { colorFamilies, pixelFamilyMap } = identifyColorFamilies();
            
            // Step 3: Process mappings
            console.log("Processing color mappings...");
            const processedMappings = prepareColorMappings();
            
            // Step 4: Map families to mappings - IMPROVED for more colors
            console.log("Mapping color families to target colors...");
            mapFamiliesToMappings(colorFamilies, processedMappings);
            
            // CHANGE: Set a better default mapping for unmatched pixels
            // Find the most dominant mapping by counting pixels
            let mappingCounts = new Array(processedMappings.length).fill(0);
            colorFamilies.forEach(family => {
                if (family.mappingIndex !== -1) {
                    mappingCounts[family.mappingIndex] += family.count;
                }
            });
            
            let defaultMappingIndex = 0;
            let maxCount = mappingCounts[0];
            for (let i = 1; i < mappingCounts.length; i++) {
                if (mappingCounts[i] > maxCount) {
                    maxCount = mappingCounts[i];
                    defaultMappingIndex = i;
                }
            }
            
            console.log("Transforming colors...");

            // Use a cache for processed colors
            const transformCache = new Map();

            // Apply transformations
            for (let i = 0; i < data.length; i += 4) {
                if (data[i + 3] < 128) continue; // Skip transparent
                
                const r = data[i], g = data[i + 1], b = data[i + 2];
                
                // Only skip absolute black
                if (r <= 3 && g <= 3 && b <= 3) continue;
                
                const pixelIndex = Math.floor(i / 4);
                const familyIndex = pixelFamilyMap[pixelIndex];
                
                // Determine which mapping to use, with fallback for unassigned pixels
                let mappingToUse = defaultMappingIndex;
                
                if (familyIndex !== -1 && familyIndex < colorFamilies.length) {
                    const family = colorFamilies[familyIndex];
                    if (family.mappingIndex !== -1) {
                        mappingToUse = family.mappingIndex;
                    } else {
                        // CHANGE: For families with no mapping, find closest mapping directly
                        // This helps with more accurate color matching for many colors
                        const pixelHsv = rgbToHsv(r, g, b);
                        let bestDistance = Infinity;
                        
                        for (let j = 0; j < processedMappings.length; j++) {
                            const mappingHsv = processedMappings[j].originalHsv;
                            
                            // Weighted distance calculation for perceptual matching
                            let hueDiff = Math.abs(pixelHsv[0] - mappingHsv[0]);
                            if (hueDiff > 180) hueDiff = 360 - hueDiff;
                            
                            // For low saturation, focus on brightness
                            const distance = (pixelHsv[1] < 15 || mappingHsv[1] < 15) ? 
                                Math.abs(pixelHsv[2] - mappingHsv[2]) / 100 :
                                (hueDiff / 180) * 0.6 + 
                                Math.abs(pixelHsv[1] - mappingHsv[1]) / 100 * 0.2 + 
                                Math.abs(pixelHsv[2] - mappingHsv[2]) / 100 * 0.2;
                            
                            if (distance < bestDistance) {
                                bestDistance = distance;
                                mappingToUse = j;
                            }
                        }
                    }
                }
                
                // Check cache for this color and mapping combination
                const colorKey = `${r},${g},${b},${mappingToUse}`;
                if (transformCache.has(colorKey)) {
                    const cachedColor = transformCache.get(colorKey);
                    data[i] = cachedColor[0];
                    data[i + 1] = cachedColor[1];
                    data[i + 2] = cachedColor[2];
                    continue;
                }
                
                // Check if this pixel is part of a gradient
                const isGradient = gradientMap[pixelIndex];
                const gradientStrength = gradientStrengthMap[pixelIndex];
                
                // Transform the color
                const newColor = transformColor(r, g, b, mappingToUse, isGradient, gradientStrength);
                
                // Apply the transformed color
                data[i] = newColor[0];
                data[i + 1] = newColor[1];
                data[i + 2] = newColor[2];
                
                // Cache this transformation
                // CHANGE: Limit cache size to prevent memory issues with many colors
                if (transformCache.size < 100000) {
                    transformCache.set(colorKey, newColor);
                }
            }

            console.log("Finished color mapping!");

            // Apply the changes to the canvas
            ctx.putImageData(imageDataObj, 0, 0);
            const dataUrl = canvasElement.toDataURL('image/png');
            console.timeEnd('colorMapping');
            resolve(dataUrl);
        };
        img.src = imageData;
    });
}


async applyMultipleColorMappings(imageData, colorMappings, useJimp = false) {
  

  // If useJimp is true, send to the backend for Jimp processing
  if (useJimp) {
    console.log("Using Jimp for backend processing");
    try {
      // Create form data for sending to backend
      const formData = new FormData();
      
      // Handle image data based on format
      if (typeof imageData === 'string' && imageData.startsWith('data:image')) {
        // If it's a data URL, convert to blob
        try {
          const fetchResponse = await fetch(imageData);
          if (!fetchResponse.ok) throw new Error("Failed to fetch image data");
          const blob = await fetchResponse.blob();
          formData.append('image', blob, 'image.png');
          console.log("Added image as blob to form data");
        } catch (blobError) {
          console.error("Error converting data URL to blob:", blobError);
          // Fallback: send as base64 string
          formData.append('imageData', imageData);
          console.log("Added image as base64 string (fallback)");
        }
      } else {
        // For other formats (already blob, etc.)
        formData.append('imageData', imageData);
        console.log("Added image data to form data");
      }
      
      // Add color mappings as JSON string
      formData.append('colorMappings', JSON.stringify(colorMappings));
      
      
      // Send to backend endpoint with proper CORS settings
      console.log("Sending request to Jimp backend...");
      const response = await fetch('http://13.203.1.189:8000/api/process-image-with-jimp', {
        method: 'POST',
        body: formData,
        // No need to set Content-Type with FormData
        // Let the browser handle it with the correct multipart boundary
      });
      
      // Handle non-200 responses
      if (!response.ok) {
        const errorText = await response.text();
        console.error("Backend response error:", response.status, errorText);
        throw new Error(`Backend processing failed: ${response.status} ${response.statusText}`);
      }
      
      // Parse the JSON response
      const result = await response.json();
      
      if (!result.success || !result.processedImage) {
        console.error("Invalid response from backend:", result);
        throw new Error("Backend returned an invalid response format");
      }
      
      console.log("Successfully processed image with Jimp backend");
      return result.processedImage; // Base64 image data
    } catch (error) {
      console.error('Error with Jimp processing:', error);
      // Fall back to frontend processing if backend fails
     
      // Recursively call with useJimp=false to use frontend processing
      return this.applyMultipleColorMappings(imageData, colorMappings, false);
    }
  }
  
  // Otherwise, use the original frontend Canvas implementation
  return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
          console.time('colorMapping');
          const canvasElement = document.createElement('canvas');
          const ctx = canvasElement.getContext('2d');
          canvasElement.width = img.width;
          canvasElement.height = img.height;

          ctx.drawImage(img, 0, 0);
          const imageDataObj = ctx.getImageData(0, 0, img.width, img.height);
          const data = imageDataObj.data;

          // Color conversion utilities
          function rgbToLab(r, g, b) {
              r /= 255; g /= 255; b /= 255;

              r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
              g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
              b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;

              let x = (r * 0.4124564 + g * 0.3575761 + b * 0.1804375) * 100;
              let y = (r * 0.2126729 + g * 0.7151522 + b * 0.0721750) * 100;
              let z = (r * 0.0193339 + g * 0.1191920 + b * 0.9503041) * 100;

              x /= 95.047; y /= 100; z /= 108.883;

              x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + 16/116;
              y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + 16/116;
              z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + 16/116;

              return [
                  116 * y - 16,   // L
                  500 * (x - y),   // a
                  200 * (y - z)    // b
              ];
          }

          function rgbToHsv(r, g, b) {
              r /= 255; g /= 255; b /= 255;
              const max = Math.max(r, g, b);
              const min = Math.min(r, g, b);
              const d = max - min;
              let h, s = max === 0 ? 0 : d / max, v = max;

              if (max === min) {
                  h = 0;
              } else {
                  switch (max) {
                      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                      case g: h = (b - r) / d + 2; break;
                      case b: h = (r - g) / d + 4; break;
                  }
                  h /= 6;
              }
              return [h * 360, s * 100, v * 100];
          }

          function hsvToRgb(h, s, v) {
              h /= 360; s /= 100; v /= 100;
              let r, g, b;
              const i = Math.floor(h * 6);
              const f = h * 6 - i;
              const p = v * (1 - s);
              const q = v * (1 - f * s);
              const t = v * (1 - (1 - f) * s);

              switch (i % 6) {
                  case 0: r = v; g = t; b = p; break;
                  case 1: r = q; g = v; b = p; break;
                  case 2: r = p; g = v; b = t; break;
                  case 3: r = p; g = q; b = v; break;
                  case 4: r = t; g = p; b = v; break;
                  case 5: r = v; g = p; b = q; break;
              }

              return [
                  Math.round(r * 255),
                  Math.round(g * 255),
                  Math.round(b * 255)
              ];
          }

          // Calculate direct RGB distance
          function rgbDistance(r1, g1, b1, r2, g2, b2) {
              return Math.sqrt(
                  Math.pow(r1 - r2, 2) +
                  Math.pow(g1 - g2, 2) +
                  Math.pow(b1 - b2, 2)
              );
          }

          // LAB to RGB conversion
          function labToRgb(L, A, B) {
              let y = (L + 16) / 116;
              let x = A / 500 + y;
              let z = y - B / 200;
              
              x = 0.95047 * ((x * x * x > 0.008856) ? x * x * x : (x - 16/116) / 7.787);
              y = 1.00000 * ((y * y * y > 0.008856) ? y * y * y : (y - 16/116) / 7.787);
              z = 1.08883 * ((z * z * z > 0.008856) ? z * z * z : (z - 16/116) / 7.787);
              
              let rr = x *  3.2406 + y * -1.5372 + z * -0.4986;
              let gg = x * -0.9689 + y *  1.8758 + z *  0.0415;
              let bb = x *  0.0557 + y * -0.2040 + z *  1.0570;
              
              rr = (rr > 0.0031308) ? (1.055 * Math.pow(rr, 1/2.4) - 0.055) : 12.92 * rr;
              gg = (gg > 0.0031308) ? (1.055 * Math.pow(gg, 1/2.4) - 0.055) : 12.92 * gg;
              bb = (bb > 0.0031308) ? (1.055 * Math.pow(bb, 1/2.4) - 0.055) : 12.92 * bb;
              
              return [
                  Math.max(0, Math.min(255, Math.round(rr * 255))),
                  Math.max(0, Math.min(255, Math.round(gg * 255))),
                  Math.max(0, Math.min(255, Math.round(bb * 255)))
              ];
          }

          // Prepare all color mappings with their properties
          const processedMappings = colorMappings.map(mapping => {
              const originalColor = mapping.originalColor;
              const replacementColor = mapping.targetColor;

              
              // Get color properties
              const originalHsv = rgbToHsv(...originalColor);
              const replacementHsv = rgbToHsv(...replacementColor);
              const originalLab = rgbToLab(...originalColor);
              const replacementLab = rgbToLab(...replacementColor);
              
              // Only check if this is a black color (3,3,3 or less)
              const isBlack = originalColor[0] <= 3 && originalColor[1] <= 3 && originalColor[2] <= 3;
              
              return {
                  originalColor,
                  replacementColor,
                  originalHsv,
                  replacementHsv,
                  originalLab,
                  replacementLab,
                  isBlack
              };
          });

          // Create a cache for color transformations
          const transformCache = new Map();

          // Define tolerances - improved for better gradient handling
          const RGB_TOLERANCE = 80;       // Increased for better gradient detection
          const HUE_TOLERANCE = 20;       // Slightly increased
          const SAT_TOLERANCE = 25;       // Increased for better pattern handling
          const VAL_TOLERANCE = 30;       // Increased for better shade detection
          const LAB_TOLERANCE = 30;       // Increased for better perceptual matching
          
          // Maintain a gradient map - colors that are part of gradients
          const gradientColors = new Set();
          
          // First pass - identify gradient colors by analyzing local neighborhoods
          // This is simplified for performance, but could be more sophisticated
          if (img.width > 10 && img.height > 10) {  // Only for reasonably sized images
              for (let y = 1; y < img.height - 1; y++) {
                  for (let x = 1; x < img.width - 1; x++) {
                      const idx = (y * img.width + x) * 4;
                      if (data[idx + 3] < 128) continue; // Skip transparent
                      
                      // Get this pixel's color
                      const r = data[idx];
                      const g = data[idx + 1];
                      const b = data[idx + 2];
                      
                      // Skip true black
                      if (r <= 3 && g <= 3 && b <= 3) continue;
                      
                      // Check neighbors for gradient patterns
                      let isGradient = false;
                      
                      // Check horizontal neighbors
                      const leftIdx = (y * img.width + (x-1)) * 4;
                      const rightIdx = (y * img.width + (x+1)) * 4;
                      
                      if (data[leftIdx + 3] >= 128 && data[rightIdx + 3] >= 128) {
                          const leftDist = rgbDistance(r, g, b, data[leftIdx], data[leftIdx + 1], data[leftIdx + 2]);
                          const rightDist = rgbDistance(r, g, b, data[rightIdx], data[rightIdx + 1], data[rightIdx + 2]);
                          
                          // If colors change gradually, likely a gradient
                          if (leftDist < 15 && rightDist < 15 && leftDist + rightDist > 5) {
                              isGradient = true;
                          }
                      }
                      
                      // Check vertical neighbors if not already identified
                      if (!isGradient) {
                          const topIdx = ((y-1) * img.width + x) * 4;
                          const bottomIdx = ((y+1) * img.width + x) * 4;
                          
                          if (data[topIdx + 3] >= 128 && data[bottomIdx + 3] >= 128) {
                              const topDist = rgbDistance(r, g, b, data[topIdx], data[topIdx + 1], data[topIdx + 2]);
                              const bottomDist = rgbDistance(r, g, b, data[bottomIdx], data[bottomIdx + 1], data[bottomIdx + 2]);
                              
                              if (topDist < 15 && bottomDist < 15 && topDist + bottomDist > 5) {
                                  isGradient = true;
                              }
                          }
                      }
                      
                      // Mark as gradient for special handling
                      if (isGradient) {
                          gradientColors.add(`${r},${g},${b}`);
                      }
                  }
              }
          }

          // Process each pixel
          for (let i = 0; i < data.length; i += 4) {
              if (data[i + 3] < 128) continue; // Skip transparent pixels

              const r = data[i];
              const g = data[i + 1];
              const b = data[i + 2];
              
              // Skip pure black for efficiency (and we won't modify it)
              if (r <= 3 && g <= 3 && b <= 3) continue;
              
              // Create a key for the cache
              const colorKey = `${r},${g},${b}`;
              if (transformCache.has(colorKey)) {
                  const cachedColor = transformCache.get(colorKey);
                  data[i] = cachedColor[0];
                  data[i + 1] = cachedColor[1];
                  data[i + 2] = cachedColor[2];
                  continue;
              }
              
              // Check if this is a gradient color
              const isGradientColor = gradientColors.has(colorKey);
              
              // Find all matching mappings for this color with their scores
              const matchedMappings = [];
              
              for (const mapping of processedMappings) {
                  // Skip black mappings for non-black pixels
                  if (mapping.isBlack && !(r <= 3 && g <= 3 && b <= 3)) continue;
                  
                  // Direct RGB distance - fastest check
                  const rgbDist = rgbDistance(r, g, b, 
                      mapping.originalColor[0], 
                      mapping.originalColor[1], 
                      mapping.originalColor[2]);
                  
                  // Skip if too far in RGB space for efficiency
                  if (rgbDist > RGB_TOLERANCE * 1.5) continue;
                  
                  // Calculate pixel color in HSV space
                  const pixelHsv = rgbToHsv(r, g, b);
                  
                  // Calculate hue distance (accounting for circularity)
                  let hueDist = Math.abs(pixelHsv[0] - mapping.originalHsv[0]);
                  if (hueDist > 180) hueDist = 360 - hueDist;
                  
                  // Set a uniform matching criteria for all colors
                  const hueMultiplier = isGradientColor ? 1.3 : 1.0;
                  const satMultiplier = isGradientColor ? 1.4 : 1.0;
                  const valMultiplier = isGradientColor ? 1.3 : 1.0;
                  
                  const isColorMatch = 
                      hueDist < HUE_TOLERANCE * hueMultiplier && 
                      Math.abs(pixelHsv[1] - mapping.originalHsv[1]) < SAT_TOLERANCE * satMultiplier &&
                      Math.abs(pixelHsv[2] - mapping.originalHsv[2]) < VAL_TOLERANCE * valMultiplier;
                  
                  // If HSV check passes or RGB is close, do a more expensive Lab check
                  if (isColorMatch || rgbDist < RGB_TOLERANCE * (isGradientColor ? 0.7 : 0.5)) {
                      const pixelLab = rgbToLab(r, g, b);
                      
                      const labDistance = Math.sqrt(
                          Math.pow(pixelLab[0] - mapping.originalLab[0], 2) +
                          Math.pow(pixelLab[1] - mapping.originalLab[1], 2) +
                          Math.pow(pixelLab[2] - mapping.originalLab[2], 2)
                      );
                      
                      // For gradients and patterns, be more generous with matching
                      const labToleranceAdjusted = isGradientColor ? LAB_TOLERANCE * 1.3 : LAB_TOLERANCE;
                      
                      // Calculate match score - lower is better
                      // Combine different metrics with appropriate weights
                      const rgbScore = rgbDist / (isGradientColor ? RGB_TOLERANCE * 1.2 : RGB_TOLERANCE);
                      const labScore = labDistance / labToleranceAdjusted;
                      
                      // Emphasize LAB distance more for gradients (better perceptual matching)
                      const matchScore = isGradientColor ? 
                          (rgbScore * 0.2 + labScore * 0.8) : 
                          (rgbScore * 0.3 + labScore * 0.7);
                      
                      // If this is a reasonable match, save it with its score
                      if (matchScore < 1.2) {  // Slightly more permissive threshold
                          matchedMappings.push({
                              mapping,
                              matchScore
                          });
                      }
                  }
              }
              
              // Sort matched mappings by score (best matches first)
              matchedMappings.sort((a, b) => a.matchScore - b.matchScore);
              
              let newColor;
              
              // If we found at least one mapping
              if (matchedMappings.length > 0) {
                  // For gradient colors, blend between closest matches if we have multiple matches
                  if (isGradientColor && matchedMappings.length > 1) {
                      // Get the best two matches
                      const bestMapping = matchedMappings[0].mapping;
                      const secondBestMapping = matchedMappings[1].mapping;
                      const bestScore = matchedMappings[0].matchScore;
                      const secondBestScore = matchedMappings[1].matchScore;
                      
                      // Calculate weights for blending based on scores
                      // Lower score gets higher weight
                      const totalWeight = (1 - bestScore) + (1 - secondBestScore);
                      const bestWeight = (1 - bestScore) / totalWeight;
                      const secondWeight = (1 - secondBestScore) / totalWeight;
                      
                      // Calculate pixel in LAB space for smooth blending
                      const pixelLab = rgbToLab(r, g, b);
                      
                      // Calculate LAB deltas for both mappings
                      const labDelta1 = [
                          bestMapping.replacementLab[0] - bestMapping.originalLab[0],
                          bestMapping.replacementLab[1] - bestMapping.originalLab[1],
                          bestMapping.replacementLab[2] - bestMapping.originalLab[2]
                      ];
                      
                      const labDelta2 = [
                          secondBestMapping.replacementLab[0] - secondBestMapping.originalLab[0],
                          secondBestMapping.replacementLab[1] - secondBestMapping.originalLab[1],
                          secondBestMapping.replacementLab[2] - secondBestMapping.originalLab[2]
                      ];
                      
                      // Blend the two transformations
                      const blendedLab = [
                          pixelLab[0] + (labDelta1[0] * bestWeight + labDelta2[0] * secondWeight),
                          pixelLab[1] + (labDelta1[1] * bestWeight + labDelta2[1] * secondWeight),
                          pixelLab[2] + (labDelta1[2] * bestWeight + labDelta2[2] * secondWeight)
                      ];
                      
                      // Convert back to RGB
                      newColor = labToRgb(...blendedLab);
                  } 
                  else {
                      // Use the best match
                      const bestMapping = matchedMappings[0].mapping;
                      const matchScore = matchedMappings[0].matchScore;
                      
                      // Calculate pixel in HSV space for transformation
                      const pixelHsv = rgbToHsv(r, g, b);
                      
                      // Determine how close the match is (fuzzy threshold based on gradient status)
                      const exactMatchThreshold = isGradientColor ? 0.4 : 0.3;
                      const exactMatch = matchScore < exactMatchThreshold;
                      
                      if (exactMatch) {
                          // Direct replacement for very close matches
                          newColor = bestMapping.replacementColor;
                      } else {
                          // Calculate relative shifts
                          const hueDiff = bestMapping.replacementHsv[0] - bestMapping.originalHsv[0];
                          const satRatio = bestMapping.originalHsv[1] > 5 ? 
                                           bestMapping.replacementHsv[1] / bestMapping.originalHsv[1] : 1;
                          const valRatio = bestMapping.originalHsv[2] > 5 ? 
                                           bestMapping.replacementHsv[2] / bestMapping.originalHsv[2] : 1;
                          
                          // Apply transformations with gradient-aware adjustments
                          let newHue = (pixelHsv[0] + hueDiff) % 360;
                          if (newHue < 0) newHue += 360;
                          
                          // Preserve more of the original variation for gradients
                          const preservationFactor = isGradientColor ? 0.3 : 0.15;
                          
                          let newSat = Math.max(0, Math.min(100, 
                              (pixelHsv[1] * satRatio * (1 - preservationFactor)) + 
                              (pixelHsv[1] * preservationFactor)));
                              
                          let newVal = Math.max(0, Math.min(100, 
                              (pixelHsv[2] * valRatio * (1 - preservationFactor)) + 
                              (pixelHsv[2] * preservationFactor)));
                          
                          // Convert back to RGB
                          newColor = hsvToRgb(newHue, newSat, newVal);
                      }
                  }
                  
                  // Apply new color
                  data[i] = newColor[0];
                  data[i + 1] = newColor[1];
                  data[i + 2] = newColor[2];
                  
                  // Cache this transformation
                  transformCache.set(colorKey, newColor);
              }
          }

          ctx.putImageData(imageDataObj, 0, 0);
          const dataUrl = canvasElement.toDataURL('image/png');
          console.timeEnd('colorMapping');
          resolve(dataUrl);
      };
      img.src = imageData;
  });
}
  // Helper methods
  calculateAdaptiveThreshold(color, baseThreshold) {
      const saturation = color.hsv[1];
      const value = color.hsv[2];
      return baseThreshold * (1 + (1 - saturation) * 0.5) * (1 + (1 - value) * 0.5);
  }
  
  calculateHSVDifference(hsv1, hsv2) {
      const hueDiff = Math.abs(hsv1[0] - hsv2[0]) / 360;
      const satDiff = Math.abs(hsv1[1] - hsv2[1]);
      const valDiff = Math.abs(hsv1[2] - hsv2[2]);
      return (hueDiff + satDiff + valDiff) / 3;
  }
  
  calculateColorImportance(color) {
      const saturationWeight = 0.3;
      const valueWeight = 0.2;
      const frequencyWeight = 0.5;
  
      return (color.hsv[1] * saturationWeight) +
             (color.hsv[2] * valueWeight) +
             (color.percentage * frequencyWeight);
  }
  
  filterDistinctColors(colors) {
      const distinct = [];
      const minDistance = 15; // Minimum distance for distinct colors
  
      for (const color of colors) {
          const isDistinct = !distinct.some(existingColor =>
              this.calculateColorDistance(color.lab, existingColor.lab) < minDistance &&
              this.calculateHSVDifference(color.hsv, existingColor.hsv) < 0.2
          );
  
          if (isDistinct) {
              distinct.push(color);
          }
      }
  
      return distinct;
  }
  
  rgbToHsv(r, g, b) {
      r /= 255;
      g /= 255;
      b /= 255;
  
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      const diff = max - min;
  
      let h = 0;
      let s = max === 0 ? 0 : diff / max;
      let v = max;
  
      if (max !== min) {
          switch (max) {
              case r: h = (g - b) / diff + (g < b ? 6 : 0); break;
              case g: h = (b - r) / diff + 2; break;
              case b: h = (r - g) / diff + 4; break;
          }
          h /= 6;
      }
  
      return [h, s, v];
  }


  async applyColorMapping(imageData, colorMapping, targetColor, newColor, totalLayers) {

    
    return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
            const canvasElement = document.createElement('canvas');
            const ctx = canvasElement.getContext('2d');
            canvasElement.width = img.width;
            canvasElement.height = img.height;

            ctx.drawImage(img, 0, 0);
            const imageDataObj = ctx.getImageData(0, 0, img.width, img.height);
            const data = imageDataObj.data;

            // Original color (to be replaced)
            const originalColor = targetColor;
            // New color (to replace with)
            const replacementColor = newColor;

            // Color conversion utilities
            function rgbToLab(r, g, b) {
                r /= 255; g /= 255; b /= 255;

                r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
                g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
                b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;

                let x = (r * 0.4124564 + g * 0.3575761 + b * 0.1804375) * 100;
                let y = (r * 0.2126729 + g * 0.7151522 + b * 0.0721750) * 100;
                let z = (r * 0.0193339 + g * 0.1191920 + b * 0.9503041) * 100;

                x /= 95.047; y /= 100; z /= 108.883;

                x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + 16/116;
                y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + 16/116;
                z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + 16/116;

                return [
                    116 * y - 16,   // L
                    500 * (x - y),   // a
                    200 * (y - z)    // b
                ];
            }

            function rgbToHsv(r, g, b) {
                r /= 255; g /= 255; b /= 255;
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                const d = max - min;
                let h, s = max === 0 ? 0 : d / max, v = max;

                if (max === min) {
                    h = 0;
                } else {
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    h /= 6;
                }
                return [h * 360, s * 100, v * 100];
            }

            function hsvToRgb(h, s, v) {
                let r, g, b;
                const i = Math.floor(h * 6);
                const f = h * 6 - i;
                const p = v * (1 - s);
                const q = v * (1 - f * s);
                const t = v * (1 - (1 - f) * s);

                switch (i % 6) {
                    case 0: r = v; g = t; b = p; break;
                    case 1: r = q; g = v; b = p; break;
                    case 2: r = p; g = v; b = t; break;
                    case 3: r = p; g = q; b = v; break;
                    case 4: r = t; g = p; b = v; break;
                    case 5: r = v; g = p; b = q; break;
                }

                return [
                    Math.round(r * 255),
                    Math.round(g * 255),
                    Math.round(b * 255)
                ];
            }

            // Calculate direct RGB distance
            function rgbDistance(r1, g1, b1, r2, g2, b2) {
                return Math.sqrt(
                    Math.pow(r1 - r2, 2) +
                    Math.pow(g1 - g2, 2) +
                    Math.pow(b1 - b2, 2)
                );
            }

            // Get color properties of the colors we care about
            const originalHsv = rgbToHsv(...originalColor);
            const replacementHsv = rgbToHsv(...replacementColor);
            const originalLab = rgbToLab(...originalColor);

            // Define stricter tolerance for color matching
            // These can be adjusted based on the specific colors in your images
            const RGB_TOLERANCE = 60;       // Direct RGB distance (0-441)
            const HUE_TOLERANCE = 15;       // Hue degrees (0-180)
            const SAT_TOLERANCE = 15;       // Saturation % (0-100)
            const VAL_TOLERANCE = 20;       // Value % (0-100)
            const LAB_TOLERANCE = 25;       // Lab distance

            // If original color is very dark or very light, we need different handling
            const isOriginalDark = originalHsv[2] < 20;
            const isOriginalLight = originalHsv[2] > 90 && originalHsv[1] < 15;
            const isOriginalGray = originalHsv[1] < 15;
            
            // Process each pixel
            for (let i = 0; i < data.length; i += 4) {
                if (data[i + 3] < 128) continue; // Skip transparent pixels

                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                // Direct RGB distance - fastest check
                const rgbDist = rgbDistance(r, g, b, originalColor[0], originalColor[1], originalColor[2]);
                
                // Only compute other color spaces if the RGB distance is within a reasonable range
                if (rgbDist > RGB_TOLERANCE * 1.5) continue;
                
                // Calculate color spaces
                const pixelHsv = rgbToHsv(r, g, b);
                
                // Calculate hue distance (accounting for circularity)
                let hueDist = Math.abs(pixelHsv[0] - originalHsv[0]);
                if (hueDist > 180) hueDist = 360 - hueDist;
                
                // Determine if color is similar based on HSV
                let isColorMatch = false;
                
                // Special case for grays, blacks, whites
                if (isOriginalGray) {
                    // For gray colors, focus on brightness and saturation
                    isColorMatch = 
                        pixelHsv[1] < 20 && // Low saturation
                        Math.abs(pixelHsv[2] - originalHsv[2]) < VAL_TOLERANCE; // Similar brightness
                } 
                else if (isOriginalDark) {
                    // For dark colors, focus more on hue
                    isColorMatch = 
                        pixelHsv[2] < 25 && // Dark
                        (pixelHsv[1] < 20 || hueDist < HUE_TOLERANCE * 1.5); // Either unsaturated or similar hue
                }
                else if (isOriginalLight) {
                    // For light colors, focus more on hue
                    isColorMatch = 
                        pixelHsv[2] > 85 && // Light
                        pixelHsv[1] < 20;  // Low saturation
                }
                else {
                    // For normal colors, use stricter HSV matching
                    isColorMatch = 
                        hueDist < HUE_TOLERANCE && 
                        Math.abs(pixelHsv[1] - originalHsv[1]) < SAT_TOLERANCE &&
                        Math.abs(pixelHsv[2] - originalHsv[2]) < VAL_TOLERANCE;
                }
                
                // If HSV check passes, do a more expensive Lab check for confirmation
                if (isColorMatch || rgbDist < RGB_TOLERANCE/2) {
                    const pixelLab = rgbToLab(r, g, b);
                    
                    const labDistance = Math.sqrt(
                        Math.pow(pixelLab[0] - originalLab[0], 2) +
                        Math.pow(pixelLab[1] - originalLab[1], 2) +
                        Math.pow(pixelLab[2] - originalLab[2], 2)
                    );
                    
                    // Final decision based on Lab distance or very close RGB match
                    if (labDistance < LAB_TOLERANCE || rgbDist < RGB_TOLERANCE/3) {
                        // Apply color transformation
                        if (labDistance < LAB_TOLERANCE/2 || rgbDist < RGB_TOLERANCE/4) {
                            // Direct replacement for very close matches
                            data[i] = replacementColor[0];
                            data[i + 1] = replacementColor[1];
                            data[i + 2] = replacementColor[2];
                        } else {
                            // For less exact matches, transform while preserving some variation
                            // Calculate relative shifts
                            const hueDiff = replacementHsv[0] - originalHsv[0];
                            const satRatio = originalHsv[1] > 5 ? replacementHsv[1] / originalHsv[1] : 1;
                            const valRatio = originalHsv[2] > 5 ? replacementHsv[2] / originalHsv[2] : 1;
                            
                            // Apply transformations
                            let newHue = (pixelHsv[0] + hueDiff) % 360;
                            if (newHue < 0) newHue += 360;
                            
                            let newSat = Math.max(0, Math.min(100, pixelHsv[1] * satRatio));
                            let newVal = Math.max(0, Math.min(100, pixelHsv[2] * valRatio));
                            
                            // Convert back to RGB
                            const newRGB = hsvToRgb(newHue / 360, newSat / 100, newVal / 100);
                            
                            data[i] = newRGB[0];
                            data[i + 1] = newRGB[1];
                            data[i + 2] = newRGB[2];
                        }
                    }
                }
            }

            ctx.putImageData(imageDataObj, 0, 0);
            const dataUrl = canvasElement.toDataURL('image/png');
            resolve(dataUrl);
        };
        img.src = imageData;
    });
}
// Helper functions
calculateDeltaE(lab1, lab2) {
    const deltaL = lab1[0] - lab2[0];
    const deltaA = lab1[1] - lab2[1];
    const deltaB = lab1[2] - lab2[2];
    return Math.sqrt(deltaL * deltaL + deltaA * deltaA + deltaB * deltaB);
}

hsvToRgbProcessor(hsv) {
    let h = hsv[0];
    let s = hsv[1];
    let v = hsv[2];
    
    let r, g, b;
    const i = Math.floor(h * 6);
    const f = h * 6 - i;
    const p = v * (1 - s);
    const q = v * (1 - f * s);
    const t = v * (1 - (1 - f) * s);

    switch (i % 6) {
        case 0: r = v; g = t; b = p; break;
        case 1: r = q; g = v; b = p; break;
        case 2: r = p; g = v; b = t; break;
        case 3: r = p; g = q; b = v; break;
        case 4: r = t; g = p; b = v; break;
        case 5: r = v; g = p; b = q; break;
    }

    return [
        Math.round(r * 255),
        Math.round(g * 255),
        Math.round(b * 255)
    ];
}
}  


async function processHarmony(layerCtx, totalLayers, layerCanvas, currentLayerIndex, harmonyType, showInSidebar = false, backgroundVariation = 'regular') {
  const loadingScreen = document.getElementById('loading-screen');
  const sidebarLoading = document.getElementById('harmonyLoadingIndicator');
  
  if (showInSidebar) {
    if (sidebarLoading) sidebarLoading.style.display = 'block';
  } else {
    if (loadingScreen) loadingScreen.style.display = 'block';
  }
  
  const analyzer = new ImageColorAnalyzer();
  const colorProcessor = new ColorProcessor();

  try {
    const harmonyCollection = harmonyType.toLowerCase().replace(/\s+/g, '_');
    
    console.log(`Processing ${harmonyType} harmony with ${backgroundVariation} background for layer ${currentLayerIndex}`);
    
    if (!window.harmonySeeds) {
      window.harmonySeeds = {
        'Monochromatic': Date.now(),
        'Analogous': Date.now() + 100,
        'Complementary': Date.now() + 200,
        'Split Complementary': Date.now() + 300,
        'Triadic': Date.now() + 400,
        'Tetradic': Date.now() + 500,
        'Square': Date.now() + 600
      };
    }
    
    // Function to robustly extract colors
    async function getImageColors(maxAttempts = 10) {
      let validColors = [];
      let attempts = 0;
      
      while (validColors.length === 0 && attempts < maxAttempts) {
        attempts++;
        
        if (localStorage.getItem('distinctColorsArrayColorPallet')) {
          try {
            const storedColorsString = localStorage.getItem('distinctColorsArrayColorPallet');
            const storedColors = JSON.parse(storedColorsString);

            if (Array.isArray(storedColors) && storedColors.length > 0) {
              validColors = storedColors.filter(color =>
                Array.isArray(color) &&
                color.length === 3 &&
                color.every(val => typeof val === 'number' && !isNaN(val))
              );
              
              if (validColors.length > 0) {
                console.log(`Found ${validColors.length} valid colors in localStorage`);
                break;
              }
            }
          } catch (parseError) {
            console.error("Error parsing colors from localStorage:", parseError);
          }
        }
        
        try {
          if (typeof window.distinctColorsArrayColorPallet === 'function') {
            const newColors = await window.distinctColorsArrayColorPallet();
            if (Array.isArray(newColors)) {
              validColors = newColors.filter(color => 
                Array.isArray(color) && 
                color.length === 3 && 
                color.every(val => typeof val === 'number' && !isNaN(val) && val >= 0 && val <= 255)
              );
            }
          } else if (window.distinctColorsArrayColorPallet) {
            const newColors = window.distinctColorsArrayColorPallet;
            if (Array.isArray(newColors)) {
              validColors = newColors.filter(color => 
                Array.isArray(color) && 
                color.length === 3 && 
                color.every(val => typeof val === 'number' && !isNaN(val) && val >= 0 && val <= 255)
              );
            }
          }
        } catch (e) {
          console.warn("Error accessing distinctColorsArrayColorPallet:", e);
        }
        
        if (validColors.length === 0 && layerCtx && layerCanvas) {
          try {
            const imageData = layerCtx.getImageData(0, 0, layerCanvas.width, layerCanvas.height);
            const extractedColors = await analyzer.getDistinctColors(imageData, 30, 50);
            
            if (Array.isArray(extractedColors) && extractedColors.length > 0) {
              validColors = extractedColors.filter(color =>
                Array.isArray(color) &&
                color.length === 3 &&
                color.every(val => typeof val === 'number' && !isNaN(val))
              );
              
              if (validColors.length > 0) {
                console.log(`Extracted ${validColors.length} valid colors from image`);
                break;
              }
            }
          } catch (extractError) {
            console.error("Error extracting colors from image:", extractError);
          }
        }
        
        if (validColors.length === 0) {
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      }
      
      if (validColors.length === 0) {
        console.warn("Using fallback colors after exhausting all options");
        validColors = [
          [0, 32, 46], [0, 63, 92], [44, 72, 117], [138, 80, 143], 
          [188, 80, 144], [255, 99, 97], [255, 133, 49], [255, 166, 0], [255, 211, 128]
        ];
      }
      
      return validColors;
    }
    
    // Color conversion utilities
    function rgbToHsl(r, g, b) {
      try {
        r /= 255; g /= 255; b /= 255;
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;
        
        if (max === min) {
          h = s = 0;
        } else {
          const d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
          }
          h /= 6;
        }
        return [h * 360, s * 100, l * 100];
      } catch (e) {
        console.error("Error in rgbToHsl:", e);
        return [0, 0, 50];
      }
    }
    
    function hslToRgb(h, s, l) {
      try {
        h = (typeof h === 'number' && !isNaN(h)) ? (h % 360) / 360 : 0;
        s = (typeof s === 'number' && !isNaN(s)) ? Math.min(100, Math.max(0, s)) / 100 : 0;
        l = (typeof l === 'number' && !isNaN(l)) ? Math.min(100, Math.max(0, l)) / 100 : 0.5;
        
        let r, g, b;
        
        if (s === 0) {
          r = g = b = l;
        } else {
          const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1/6) return p + (q - p) * 6 * t;
            if (t < 1/2) return q;
            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
          };
          
          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          const p = 2 * l - q;
          
          r = hue2rgb(p, q, h + 1/3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1/3);
        }
        
        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
      } catch (e) {
        console.error("Error in hslToRgb:", e);
        return [128, 128, 128];
      }
    }
    
    // Helper functions
    function colorDistance(color1, color2) {
      try {
        const rDiff = color1[0] - color2[0];
        const gDiff = color1[1] - color2[1];
        const bDiff = color1[2] - color2[2];
        return Math.sqrt(rDiff * rDiff + gDiff * gDiff + bDiff * bDiff);
      } catch (e) {
        return 1000;
      }
    }
    
    function perceptualColorDifference(rgb1, rgb2) {
      try {
        const hsl1 = rgbToHsl(...rgb1);
        const hsl2 = rgbToHsl(...rgb2);
        
        let hueDiff = Math.abs(hsl1[0] - hsl2[0]);
        hueDiff = Math.min(hueDiff, 360 - hueDiff);
        
        const satDiff = Math.abs(hsl1[1] - hsl2[1]);
        const lightDiff = Math.abs(hsl1[2] - hsl2[2]);
        
        return (hueDiff * 1.5 + satDiff + lightDiff * 1.2);
      } catch (e) {
        return 1000;
      }
    }
    
    function rgbToHex(r, g, b) {
      return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }
    
    function isLightColor(r, g, b) {
      return (r * 0.299 + g * 0.587 + b * 0.114) > 128;
    }
    
    function logPalette(palette, paletteName) {
      if (!palette || palette.length === 0) {
        console.log(`${paletteName}: No colors`);
        return;
      }
      
      console.log(`${paletteName} (${palette.length} colors):`);
      
      const colorBoxes = palette.map(([r, g, b]) => {
        const hex = rgbToHex(r, g, b);
        return `%c ${hex} `;
      }).join('');
      
      const styles = palette.map(([r, g, b]) => {
        const hex = rgbToHex(r, g, b);
        return `background: ${hex}; color: ${isLightColor(r, g, b) ? '#000' : '#fff'}; padding: 3px; border-radius: 3px;`;
      });
      
      console.log(colorBoxes, ...styles);
      console.log("Palette colors:", palette.map(color => [...color]));
    }
    
    function showToast(message) {
      const toast = document.createElement('div');
      toast.textContent = message;
      toast.style.cssText = `
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0,0,0,0.8);
        color: white;
        padding: 12px 24px;
        border-radius: 6px;
        z-index: 10001;
        font-family: Arial, sans-serif;
        font-size: 14px;
      `;
      document.body.appendChild(toast);
      
      setTimeout(() => {
        if (document.body.contains(toast)) {
          document.body.removeChild(toast);
        }
      }, 3000);
    }
    
    // New function to create background variations
// New function to create background variations
function createBackgroundVariations(baseColor, variationType) {
  const [h, s, l] = rgbToHsl(...baseColor);
  
  switch (variationType) {
    case 'dark':
      // Create dark background (low lightness, maintain some saturation)
      return hslToRgb(h, Math.max(s * 0.6, 8), Math.max(l * 0.25, 3));
      
    case 'faint':
      // Apply SS collection logic - light and bright with slight warm/cool tint
      const newSat = Math.min(25, s + 10); // Slight increase in saturation
      const newLight = Math.max(85, Math.min(95, l + 5)); // Keep very light
      return hslToRgb(h, newSat, newLight);
      
    case 'regular':
    default:
      // Keep original color but ensure it's suitable as background
      return hslToRgb(h, Math.max(s * 0.7, 12), Math.min(Math.max(l * 0.9, 15), 75));
  }
}
    
    // Harmony generation functions
    function generateMonochromaticPalette(baseColor, imageColors) {
      try {
        const [baseH, baseS, baseL] = rgbToHsl(...baseColor);
        
        const monoPalette = imageColors.map((color) => {
          const [_, originalS, originalL] = rgbToHsl(...color);
          return hslToRgb(baseH, originalS, originalL);
        });
        
        if (!monoPalette.some(color => perceptualColorDifference(color, baseColor) < 20)) {
          monoPalette[0] = [...baseColor];
        }
        
        const hslValues = monoPalette.map(color => rgbToHsl(...color));
        const lightnesses = hslValues.map(hsl => hsl[2]);
        const lightRange = Math.max(...lightnesses) - Math.min(...lightnesses);
        
        if (lightRange < 40) {
          monoPalette.push(hslToRgb(baseH, baseS, Math.min(baseL + 30, 95)));
          monoPalette.push(hslToRgb(baseH, baseS, Math.max(baseL - 30, 15)));
        }
        
        return monoPalette;
      } catch (error) {
        console.error("Error generating monochromatic palette:", error);
        return [baseColor, ...imageColors.slice(0, Math.min(imageColors.length - 1, 8))];
      }
    }
    
    function generateAnalogousPalette(baseColor, imageColors) {
      try {
        const [baseH, baseS, baseL] = rgbToHsl(...baseColor);
        const analogousRange = 30;
        
        const analogousPalette = imageColors.map((color, i) => {
          const [originalH, originalS, originalL] = rgbToHsl(...color);
          
          let hueDiff = originalH - baseH;
          if (hueDiff > 180) hueDiff -= 360;
          if (hueDiff < -180) hueDiff += 360;
          
          const scaledHueDiff = hueDiff * (analogousRange / 180);
          let newHue = baseH + scaledHueDiff;
          if (newHue < 0) newHue += 360;
          if (newHue >= 360) newHue -= 360;
          
          return hslToRgb(newHue, originalS, originalL);
        });
        
        if (!analogousPalette.some(color => perceptualColorDifference(color, baseColor) < 20)) {
          analogousPalette[0] = baseColor;
        }
        
        return analogousPalette;
      } catch (error) {
        console.error("Error generating analogous palette:", error);
        return [baseColor, ...imageColors.slice(0, Math.min(imageColors.length - 1, 8))];
      }
    }
    
    function generateComplementaryPalette(baseColor, imageColors) {
      try {
        const [baseH, baseS, baseL] = rgbToHsl(...baseColor);
        const complementH = (baseH + 180) % 360;
        
        const complementaryPalette = imageColors.map((color, i) => {
          const [h, s, l] = rgbToHsl(...color);
          
          let distFromBase = Math.abs(h - baseH);
          if (distFromBase > 180) distFromBase = 360 - distFromBase;
          
          let distFromComplement = Math.abs(h - complementH);
          if (distFromComplement > 180) distFromComplement = 360 - distFromComplement;
          
          let newHue;
          if (distFromBase <= distFromComplement) {
            const shiftAmount = (distFromBase / 180) * 30;
            newHue = (baseH + shiftAmount) % 360;
          } else {
            const shiftAmount = (distFromComplement / 180) * 30;
            newHue = (complementH + shiftAmount) % 360;
          }
          
          return hslToRgb(newHue, s, l);
        });
        
        let hasBase = false;
        let hasComplement = false;
        
        for (const color of complementaryPalette) {
          const [h] = rgbToHsl(...color);
          const distFromBase = Math.abs(h - baseH);
          const distFromComplement = Math.abs(h - complementH);
          
          if (distFromBase < 15) hasBase = true;
          if (distFromComplement < 15) hasComplement = true;
          
          if (hasBase && hasComplement) break;
        }
        
        if (!hasBase) complementaryPalette[0] = baseColor;
        if (!hasComplement) {
          const pureComplement = hslToRgb(complementH, baseS, baseL);
          complementaryPalette[complementaryPalette.length - 1] = pureComplement;
        }
        
        return complementaryPalette;
      } catch (error) {
        console.error("Error generating complementary palette:", error);
        return [baseColor, ...imageColors.slice(0, Math.min(imageColors.length - 1, 8))];
      }
    }
    
    function generateSplitComplementaryPalette(baseColor, imageColors) {
      try {
        const [baseH, baseS, baseL] = rgbToHsl(...baseColor);
        const splitComp1H = (baseH + 150) % 360;
        const splitComp2H = (baseH + 210) % 360;
        
        const splitPalette = imageColors.map((color, i) => {
          const [h, s, l] = rgbToHsl(...color);
          
          let distFromBase = Math.abs(h - baseH);
          if (distFromBase > 180) distFromBase = 360 - distFromBase;
          
          let distFromSplit1 = Math.abs(h - splitComp1H);
          if (distFromSplit1 > 180) distFromSplit1 = 360 - distFromSplit1;
          
          let distFromSplit2 = Math.abs(h - splitComp2H);
          if (distFromSplit2 > 180) distFromSplit2 = 360 - distFromSplit2;
          
          const minDist = Math.min(distFromBase, distFromSplit1, distFromSplit2);
          
          let newHue;
          if (minDist === distFromBase) {
            newHue = baseH;
          } else if (minDist === distFromSplit1) {
            newHue = splitComp1H;
          } else {
            newHue = splitComp2H;
          }
          
          const variation = (i % 5) - 2;
          newHue = (newHue + variation + 360) % 360;
          
          return hslToRgb(newHue, s, l);
        });
        
        let hasBase = false, hasSplit1 = false, hasSplit2 = false;
        
        for (const color of splitPalette) {
          const [h] = rgbToHsl(...color);
          
          if (Math.abs(h - baseH) < 15 || Math.abs(h - baseH - 360) < 15) hasBase = true;
          if (Math.abs(h - splitComp1H) < 15) hasSplit1 = true;
          if (Math.abs(h - splitComp2H) < 15) hasSplit2 = true;
          
          if (hasBase && hasSplit1 && hasSplit2) break;
        }
        
        if (!hasBase) splitPalette[0] = baseColor;
        if (!hasSplit1) splitPalette[1] = hslToRgb(splitComp1H, baseS, baseL);
        if (!hasSplit2) splitPalette[2] = hslToRgb(splitComp2H, baseS, baseL);
        
        return splitPalette;
      } catch (error) {
        console.error("Error generating split complementary palette:", error);
        return [baseColor, ...imageColors.slice(0, Math.min(imageColors.length - 1, 8))];
      }
    }
    
    function generateTriadicPalette(baseColor, imageColors) {
      try {
        const [baseH, baseS, baseL] = rgbToHsl(...baseColor);
        const triad1H = (baseH + 120) % 360;
        const triad2H = (baseH + 240) % 360;
        
        const triadicPalette = imageColors.map((color, i) => {
          const [h, s, l] = rgbToHsl(...color);
          
          let distFromBase = Math.abs(h - baseH);
          if (distFromBase > 180) distFromBase = 360 - distFromBase;
          
          let distFromTriad1 = Math.abs(h - triad1H);
          if (distFromTriad1 > 180) distFromTriad1 = 360 - distFromTriad1;
          
          let distFromTriad2 = Math.abs(h - triad2H);
          if (distFromTriad2 > 180) distFromTriad2 = 360 - distFromTriad2;
          
          const minDist = Math.min(distFromBase, distFromTriad1, distFromTriad2);
          
          let newHue;
          if (minDist === distFromBase) {
            newHue = baseH;
          } else if (minDist === distFromTriad1) {
            newHue = triad1H;
          } else {
            newHue = triad2H;
          }
          
          const variation = (i % 7) - 3;
          newHue = (newHue + variation + 360) % 360;
          
          return hslToRgb(newHue, s, l);
        });
        
        let hasBase = false, hasTriad1 = false, hasTriad2 = false;
        
        for (const color of triadicPalette) {
          const [h] = rgbToHsl(...color);
          
          if (Math.abs(h - baseH) < 15 || Math.abs(h - baseH - 360) < 15) hasBase = true;
          if (Math.abs(h - triad1H) < 15) hasTriad1 = true;
          if (Math.abs(h - triad2H) < 15) hasTriad2 = true;
          
          if (hasBase && hasTriad1 && hasTriad2) break;
        }
        
        if (!hasBase) triadicPalette[0] = baseColor;
        if (!hasTriad1) triadicPalette[1] = hslToRgb(triad1H, baseS, baseL);
        if (!hasTriad2) triadicPalette[2] = hslToRgb(triad2H, baseS, baseL);
        
        return triadicPalette;
      } catch (error) {
        console.error("Error generating triadic palette:", error);
        return [baseColor, ...imageColors.slice(0, Math.min(imageColors.length - 1, 8))];
      }
    }
    
    function generateTetradicPalette(baseColor, imageColors) {
      try {
        const [baseH, baseS, baseL] = rgbToHsl(...baseColor);
        const tetrad1H = (baseH + 60) % 360;
        const tetrad2H = (baseH + 180) % 360;
        const tetrad3H = (baseH + 240) % 360;
        
        const tetradicPalette = imageColors.map((color, i) => {
          const [h, s, l] = rgbToHsl(...color);
          
          let distFromBase = Math.abs(h - baseH);
          if (distFromBase > 180) distFromBase = 360 - distFromBase;
          
          let distFromTetrad1 = Math.abs(h - tetrad1H);
          if (distFromTetrad1 > 180) distFromTetrad1 = 360 - distFromTetrad1;
          
          let distFromTetrad2 = Math.abs(h - tetrad2H);
          if (distFromTetrad2 > 180) distFromTetrad2 = 360 - distFromTetrad2;
          
          let distFromTetrad3 = Math.abs(h - tetrad3H);
          if (distFromTetrad3 > 180) distFromTetrad3 = 360 - distFromTetrad3;
          
          const minDist = Math.min(distFromBase, distFromTetrad1, distFromTetrad2, distFromTetrad3);
          
          let newHue;
          if (minDist === distFromBase) {
            newHue = baseH;
          } else if (minDist === distFromTetrad1) {
            newHue = tetrad1H;
          } else if (minDist === distFromTetrad2) {
            newHue = tetrad2H;
          } else {
            newHue = tetrad3H;
          }
          
          const variation = (i % 9) - 4;
          newHue = (newHue + variation + 360) % 360;
          
          return hslToRgb(newHue, s, l);
        });
        
        let hasBase = false, hasTetrad1 = false, hasTetrad2 = false, hasTetrad3 = false;
        
        for (const color of tetradicPalette) {
          const [h] = rgbToHsl(...color);
          
          if (Math.abs(h - baseH) < 15 || Math.abs(h - baseH - 360) < 15) hasBase = true;
          if (Math.abs(h - tetrad1H) < 15) hasTetrad1 = true;
          if (Math.abs(h - tetrad2H) < 15) hasTetrad2 = true;
          if (Math.abs(h - tetrad3H) < 15) hasTetrad3 = true;
          
          if (hasBase && hasTetrad1 && hasTetrad2 && hasTetrad3) break;
        }
        
        if (!hasBase) tetradicPalette[0] = baseColor;
        if (!hasTetrad1) tetradicPalette[1] = hslToRgb(tetrad1H, baseS, baseL);
        if (!hasTetrad2) tetradicPalette[2] = hslToRgb(tetrad2H, baseS, baseL);
        if (!hasTetrad3) tetradicPalette[3] = hslToRgb(tetrad3H, baseS, baseL);
        
        return tetradicPalette;
      } catch (error) {
        console.error("Error generating tetradic palette:", error);
        return [baseColor, ...imageColors.slice(0, Math.min(imageColors.length - 1, 8))];
      }
    }
    
    function generateSquarePalette(baseColor, imageColors) {
      try {
        const [baseH, baseS, baseL] = rgbToHsl(...baseColor);
        const square1H = (baseH + 90) % 360;
        const square2H = (baseH + 180) % 360;
        const square3H = (baseH + 270) % 360;
        
        const squarePalette = imageColors.map((color, i) => {
          const [h, s, l] = rgbToHsl(...color);
          
          let distFromBase = Math.abs(h - baseH);
          if (distFromBase > 180) distFromBase = 360 - distFromBase;
          
          let distFromSquare1 = Math.abs(h - square1H);
          if (distFromSquare1 > 180) distFromSquare1 = 360 - distFromSquare1;
          
          let distFromSquare2 = Math.abs(h - square2H);
          if (distFromSquare2 > 180) distFromSquare2 = 360 - distFromSquare2;
          
          let distFromSquare3 = Math.abs(h - square3H);
          if (distFromSquare3 > 180) distFromSquare3 = 360 - distFromSquare3;
          
          const minDist = Math.min(distFromBase, distFromSquare1, distFromSquare2, distFromSquare3);
          
          let newHue;
          if (minDist === distFromBase) {
            newHue = baseH;
          } else if (minDist === distFromSquare1) {
            newHue = square1H;
          } else if (minDist === distFromSquare2) {
            newHue = square2H;
          } else {
            newHue = square3H;
          }
          
          const variation = (i % 9) - 4;
          newHue = (newHue + variation + 360) % 360;
          
          return hslToRgb(newHue, s, l);
        });
        
        let hasBase = false, hasSquare1 = false, hasSquare2 = false, hasSquare3 = false;
        
        for (const color of squarePalette) {
          const [h] = rgbToHsl(...color);
          
          if (Math.abs(h - baseH) < 15 || Math.abs(h - baseH - 360) < 15) hasBase = true;
          if (Math.abs(h - square1H) < 15) hasSquare1 = true;
          if (Math.abs(h - square2H) < 15) hasSquare2 = true;
          if (Math.abs(h - square3H) < 15) hasSquare3 = true;
          
          if (hasBase && hasSquare1 && hasSquare2 && hasSquare3) break;
        }
        
        if (!hasBase) squarePalette[0] = baseColor;
        if (!hasSquare1) squarePalette[1] = hslToRgb(square1H, baseS, baseL);
        if (!hasSquare2) squarePalette[2] = hslToRgb(square2H, baseS, baseL);
        if (!hasSquare3) squarePalette[3] = hslToRgb(square3H, baseS, baseL);
        
        return squarePalette;
      } catch (error) {
        console.error("Error generating square palette:", error);
        return [baseColor, ...imageColors.slice(0, Math.min(imageColors.length - 1, 8))];
      }
    }
    
    // Modified generateHarmonyPalettes function with background variations
    async function generateHarmonyPalettes(imageColors) {
      const paletteCollectionName = `${harmonyCollection}PaletteColors`;
      
      if (!window[paletteCollectionName]) {
        window[paletteCollectionName] = {};
      }
      
      const totalColors = imageColors.length;
      console.log(`Total distinct colors available: ${totalColors}`);
      
      // Generate palettes based on background variation setting
      const palettesToGenerate = backgroundVariation === 'mixed' ? 30 : 10;
      
      for (let i = 0; i < palettesToGenerate; i++) {
        let palette = [];
        const baseColorIndex = i % totalColors;
        const baseColor = imageColors[baseColorIndex];
        
        // Determine background variation for this palette
        let currentBgVariation = backgroundVariation;
        if (backgroundVariation === 'mixed') {
          const variations = ['regular', 'dark', 'faint'];
          currentBgVariation = variations[i % variations.length];
        }
        
        console.log(`Generating ${harmonyType} palette ${i} with ${currentBgVariation} background using base color:`, [...baseColor]);
        
        // Generate the harmony palette
        switch(harmonyType) {
          case 'Monochromatic':
            palette = generateMonochromaticPalette(baseColor, imageColors);
            break;
          case 'Analogous':
            palette = generateAnalogousPalette(baseColor, imageColors);
            break;
          case 'Complementary':
            palette = generateComplementaryPalette(baseColor, imageColors);
            break;
          case 'Split Complementary':
            palette = generateSplitComplementaryPalette(baseColor, imageColors);
            break;
          case 'Triadic':
            palette = generateTriadicPalette(baseColor, imageColors);
            break;
          case 'Tetradic':
            palette = generateTetradicPalette(baseColor, imageColors);
            break;
          case 'Square':
            palette = generateSquarePalette(baseColor, imageColors);
            break;
          default:
            palette = [...imageColors];
        }
        
        // Apply background variation to the first color (background color)
        if (palette.length > 0) {
          palette[0] = createBackgroundVariations(palette[0], currentBgVariation);
        }
        
        // Store additional metadata about the palette
        palette._backgroundVariation = currentBgVariation;
        palette._harmonyType = harmonyType;
        
        logPalette(palette, `${harmonyType} Palette ${i} (${currentBgVariation} bg)`);
        
        // Store the palette
        window[paletteCollectionName][i] = palette;
        console.log(`Stored palette in window.${paletteCollectionName}[${i}] with ${currentBgVariation} background`);
      }
      
      // Create backup in truePaletteColors for processPallet compatibility
      if (!window.truePaletteColors) {
        window.truePaletteColors = {};
      }
      
      // If showing in sidebar, display the palettes
      if (showInSidebar) {
        displayHarmonyPalettesInSidebar(harmonyType, paletteCollectionName, backgroundVariation);
      } else {
        // Auto-apply random palette (existing behavior)
        const randomIndex = Math.floor(Math.random() * palettesToGenerate);
        console.log(`Auto-applying random ${harmonyType} palette ${randomIndex}`);
        
        window.truePaletteColors[randomIndex] = window[paletteCollectionName][randomIndex];
        
        setTimeout(async () => {
          try {
            if (typeof processPallet === 'function') {
              await processPallet(
                layerCtx, 
                totalLayers, 
                layerCanvas, 
                currentLayerIndex, 
                null, 
                "true",
                randomIndex,
                true
              );
              
              const bgType = window[paletteCollectionName][randomIndex]._backgroundVariation || 'regular';
              showToast(`Applied ${harmonyType} palette ${randomIndex} (${bgType} background)`);
            } else {
              console.error('processPallet function not available');
              showToast(`Error: processPallet function not found`);
            }
          } catch (applyError) {
            console.error('Error applying palette:', applyError);
            showToast(`Error applying palette: ${applyError.message}`);
          }
        }, 100);
      }
    }
    
    // Main execution
    const imageColors = await getImageColors();
    
    if (!imageColors || imageColors.length === 0) {
      throw new Error("Could not extract colors from the image");
    }
    
    console.log(`Successfully extracted ${imageColors.length} colors from the image`);
    await generateHarmonyPalettes(imageColors);
    
  } catch (error) {
    console.error("Error while processing harmony:", error);
    if (showInSidebar) {
      showToast(`Error processing ${harmonyType} harmony: ${error.message}`);
    } else {
      showToast(`Error processing ${harmonyType} harmony: ${error.message}`);
    }
  } finally {
    if (showInSidebar) {
      if (sidebarLoading) sidebarLoading.style.display = 'none';
    } else {
      if (loadingScreen) loadingScreen.style.display = 'none';
    }
  }
}

// Function to apply harmony palette
async function applyHarmonyPalette(paletteIndex, paletteCollectionName) {
  try {
    const canvas = document.getElementById('layer_canvas_1');
    if (!canvas) {
      const toast = document.createElement('div');
      toast.textContent = 'Canvas not found';
      toast.style.cssText = `
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(255,0,0,0.8);
        color: white;
        padding: 12px 24px;
        border-radius: 6px;
        z-index: 10001;
        font-family: Arial, sans-serif;
        font-size: 14px;
      `;
      document.body.appendChild(toast);
      setTimeout(() => document.body.removeChild(toast), 3000);
      return;
    }
    
    const ctx = canvas.getContext('2d');
    const palette = window[paletteCollectionName][paletteIndex];
    
    if (!palette) {
      const toast = document.createElement('div');
      toast.textContent = 'Palette not found';
      toast.style.cssText = `
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(255,0,0,0.8);
        color: white;
        padding: 12px 24px;
        border-radius: 6px;
        z-index: 10001;
        font-family: Arial, sans-serif;
        font-size: 14px;
      `;
      document.body.appendChild(toast);
      setTimeout(() => document.body.removeChild(toast), 3000);
      return;
    }
    
    // Create backup in truePaletteColors
    if (!window.truePaletteColors) {
      window.truePaletteColors = {};
    }
    window.truePaletteColors[paletteIndex] = palette;
    
    if (typeof processPallet === 'function') {
      await processPallet(ctx, 1, canvas, 0, null, "true", paletteIndex, true);
      
      const bgType = palette._backgroundVariation || 'regular';
      const toast = document.createElement('div');
      toast.textContent = `Applied harmony palette ${paletteIndex} (${bgType} background)`;
      toast.style.cssText = `
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0,128,0,0.8);
        color: white;
        padding: 12px 24px;
        border-radius: 6px;
        z-index: 10001;
        font-family: Arial, sans-serif;
        font-size: 14px;
      `;
      document.body.appendChild(toast);
      setTimeout(() => document.body.removeChild(toast), 3000);
    } else {
      const toast = document.createElement('div');
      toast.textContent = 'Error: processPallet function not available';
      toast.style.cssText = `
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(255,0,0,0.8);
        color: white;
        padding: 12px 24px;
        border-radius: 6px;
        z-index: 10001;
        font-family: Arial, sans-serif;
        font-size: 14px;
      `;
      document.body.appendChild(toast);
      setTimeout(() => document.body.removeChild(toast), 3000);
    }
  } catch (error) {
    console.error('Error applying harmony palette:', error);
    const toast = document.createElement('div');
    toast.textContent = `Error applying palette: ${error.message}`;
    toast.style.cssText = `
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255,0,0,0.8);
      color: white;
      padding: 12px 24px;
      border-radius: 6px;
      z-index: 10001;
      font-family: Arial, sans-serif;
      font-size: 14px;
    `;
    document.body.appendChild(toast);
    setTimeout(() => document.body.removeChild(toast), 3000);
  }
}

// Function to regenerate a specific harmony palette
async function regenerateHarmonyPalette(paletteIndex, harmonyType) {
  try {
    const canvas = document.getElementById('layer_canvas_1');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    
    const toast = document.createElement('div');
    toast.textContent = 'Regenerating palettes...';
    toast.style.cssText = `
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,255,0.8);
      color: white;
      padding: 12px 24px;
      border-radius: 6px;
      z-index: 10001;
      font-family: Arial, sans-serif;
      font-size: 14px;
    `;
    document.body.appendChild(toast);
    
    // Get current background variation setting
    const backgroundVariationSelect = document.getElementById('backgroundVariationSelect');
    const backgroundVariation = backgroundVariationSelect ? backgroundVariationSelect.value : 'regular';
    
    await processHarmony(ctx, 1, canvas, 0, harmonyType, true, backgroundVariation);
    
    setTimeout(() => document.body.removeChild(toast), 1000);
    
  } catch (error) {
    console.error('Error regenerating harmony palette:', error);
    const toast = document.createElement('div');
    toast.textContent = 'Error regenerating palette';
    toast.style.cssText = `
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255,0,0,0.8);
      color: white;
      padding: 12px 24px;
      border-radius: 6px;
      z-index: 10001;
      font-family: Arial, sans-serif;
      font-size: 14px;
    `;
    document.body.appendChild(toast);
    setTimeout(() => document.body.removeChild(toast), 3000);
  }
}


function displayHarmonyPalettesInSidebar(harmonyType, paletteCollectionName, backgroundVariation) {
  const container = document.getElementById('harmonyPalettesContainer');
  if (!container) return;
  
  container.innerHTML = ''; // Clear existing content
  
  const palettes = window[paletteCollectionName];
  
  if (!palettes) {
    container.innerHTML = '<div class="text-center text-muted">No palettes generated</div>';
    return;
  }
  
  // Determine how many palettes to show based on background variation
  const palettesToShow = backgroundVariation === 'mixed' ? 15 : 10;
  
  // Helper functions (copied from your trending palette code)
  function rgbToHex(r, g, b) {
    return '#' + [r, g, b].map(x => {
      const hex = x.toString(16);
      return hex.length === 1 ? '0' + hex : hex;
    }).join('');
  }
  
  function rgbToHsl(r, g, b) {
    try {
      r /= 255;
      g /= 255;
      b /= 255;
      
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      let h, s, l = (max + min) / 2;
      
      if (max === min) {
        h = s = 0;
      } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        
        switch (max) {
          case r: h = (g - b) / d + (g < b ? 6 : 0); break;
          case g: h = (b - r) / d + 2; break;
          case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
      }
      
      return [h * 360, s * 100, l * 100];
    } catch (e) {
      return [Math.random() * 360, 70 + Math.random() * 30, 45 + Math.random() * 25];
    }
  }
  
  function hslToRgb(h, s, l) {
    try {
      h /= 360;
      s /= 100;
      l /= 100;
      
      let r, g, b;
      
      if (s === 0) {
        r = g = b = l;
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        };
        
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }
      
      return [
        Math.round(r * 255),
        Math.round(g * 255),
        Math.round(b * 255)
      ];
    } catch (e) {
      return [
        Math.floor(Math.random() * 256),
        Math.floor(Math.random() * 256),
        Math.floor(Math.random() * 256)
      ];
    }
  }
  
  function getColorName(rgb) {
    try {
      const [r, g, b] = rgb;
      
      const rNorm = r / 255;
      const gNorm = g / 255;
      const bNorm = b / 255;
      const max = Math.max(rNorm, gNorm, bNorm);
      const min = Math.min(rNorm, gNorm, bNorm);
      const diff = max - min;
      
      let h = 0;
      if (max !== min) {
        if (max === rNorm) {
          h = (60 * ((gNorm - bNorm) / diff) + 360) % 360;
        } else if (max === gNorm) {
          h = (60 * ((bNorm - rNorm) / diff) + 120) % 360;
        } else {
          h = (60 * ((rNorm - gNorm) / diff) + 240) % 360;
        }
      }
      
      const v = max;
      
      let hueName;
      if (h < 15 || h >= 345) hueName = "Red";
      else if (h >= 15 && h < 45) hueName = "Orange";
      else if (h >= 45 && h < 75) hueName = "Yellow";
      else if (h >= 75 && h < 165) hueName = "Green";
      else if (h >= 165 && h < 195) hueName = "Cyan";
      else if (h >= 195 && h < 255) hueName = "Blue";
      else if (h >= 255 && h < 285) hueName = "Purple";
      else if (h >= 285 && h < 345) hueName = "Pink";
      
      let shadePrefix = "";
      if (v < 0.4) shadePrefix = "Dark";
      else if (v > 0.7) shadePrefix = "Light";
      
      return shadePrefix ? `${shadePrefix} ${hueName}` : hueName;
    } catch (e) {
      return "Color";
    }
  }
  
  function prepareDisplayColors(colors) {
    const MAX_DISPLAY_COUNT = 8;
    const MIN_DISPLAY_COUNT = 4;
    
    let validColors = colors.filter(color => 
      Array.isArray(color) && 
      color.length === 3 && 
      color.every(val => typeof val === 'number' && !isNaN(val) && val >= 0 && val <= 255)
    );
    
    if (validColors.length === 0) {
      validColors = [];
      for (let i = 0; i < MIN_DISPLAY_COUNT; i++) {
        const hue = i * (360 / MIN_DISPLAY_COUNT);
        validColors.push(hslToRgb(hue, 70 + Math.random() * 30, 45 + Math.random() * 25));
      }
      return validColors;
    }
    
    const colorFamilies = [
      { name: "Red", range: [345, 15] },
      { name: "Orange", range: [15, 45] },
      { name: "Yellow", range: [45, 75] },
      { name: "Green", range: [75, 165] },
      { name: "Cyan", range: [165, 195] },
      { name: "Blue", range: [195, 255] },
      { name: "Purple", range: [255, 285] },
      { name: "Pink", range: [285, 345] }
    ];
    
    const colorsByFamily = {};
    colorFamilies.forEach(family => {
      colorsByFamily[family.name] = [];
    });
    
    validColors.forEach(color => {
      const [h, s, l] = rgbToHsl(...color);
      
      let foundFamily = false;
      for (const family of colorFamilies) {
        if (family.name === "Red") {
          if (h >= family.range[0] || h < family.range[1]) {
            colorsByFamily[family.name].push(color);
            foundFamily = true;
            break;
          }
        } else if (h >= family.range[0] && h < family.range[1]) {
          colorsByFamily[family.name].push(color);
          foundFamily = true;
          break;
        }
      }
      
      if (!foundFamily) {
        colorsByFamily['Blue'].push(color);
      }
    });
    
    let displayColors = [validColors[0]];
    
    const [firstColorH, firstColorS, firstColorL] = rgbToHsl(...validColors[0]);
    let firstColorFamily = null;
    
    for (const family of colorFamilies) {
      if (family.name === "Red") {
        if (firstColorH >= family.range[0] || firstColorH < family.range[1]) {
          firstColorFamily = family.name;
          break;
        }
      } else if (firstColorH >= family.range[0] && firstColorH < family.range[1]) {
        firstColorFamily = family.name;
        break;
      }
    }
    
    const sortedFamilies = Object.entries(colorsByFamily)
      .sort((a, b) => b[1].length - a[1].length)
      .filter(([_, colors]) => colors.length > 0);
    
    let optimalDisplayCount = Math.min(
      MAX_DISPLAY_COUNT,
      Math.max(MIN_DISPLAY_COUNT, sortedFamilies.length + 1)
    );
    
    for (const [familyName, familyColors] of sortedFamilies) {
      if (familyName === firstColorFamily) continue;
      if (displayColors.length >= optimalDisplayCount) break;
      
      let bestColor = familyColors[0];
      let highestSat = 0;
      
      for (const color of familyColors) {
        const [_, s, __] = rgbToHsl(...color);
        if (s > highestSat) {
          highestSat = s;
          bestColor = color;
        }
      }
      
      displayColors.push(bestColor);
    }
    
    return displayColors.slice(0, MAX_DISPLAY_COUNT);
  }
  
  // Generate and show preview function for harmony palettes - NOW PROPERLY ASYNC
  async function generateHarmonyPreview(previewCanvas, paletteColors, paletteIndex) {
    try {
      const originalCanvas = document.getElementById('layer_canvas_1');
      if (!originalCanvas) {
        drawHarmonyFallbackPreview(previewCanvas, paletteIndex);
        return;
      }
      
      const ctx = previewCanvas.getContext('2d', { willReadFrequently: true });
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
      
      const originalAspect = originalCanvas.width / originalCanvas.height;
      
      const tempCanvas = document.createElement('canvas');
      if (originalAspect > 1) {
        tempCanvas.width = 200;
        tempCanvas.height = Math.round(200 / originalAspect);
      } else {
        tempCanvas.height = 200;
        tempCanvas.width = Math.round(200 * originalAspect);
      }
      
      const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
      tempCtx.drawImage(originalCanvas, 0, 0, tempCanvas.width, tempCanvas.height);
      
      const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
      
      // Get original colors from the image
      let originalColors = [];
      if (typeof getDistinctColors === 'function') {
        try {
          originalColors = await getDistinctColors(imageData, 30, 50, 40);
        } catch (e) {
          console.warn('Error calling getDistinctColors:', e);
        }
      }
      
      if (!originalColors || originalColors.length === 0) {
        // Extract colors from localStorage as fallback
        try {
          const storedColors = localStorage.getItem('distinctColorsArrayColorPallet');
          if (storedColors) {
            originalColors = JSON.parse(storedColors).slice(0, 10);
          }
        } catch (e) {
          console.warn('Could not get original colors for harmony preview');
        }
      }
      
      if (!originalColors || originalColors.length === 0) {
        // Just draw the original image without color processing
        const displayScale = Math.min(
          previewCanvas.width / tempCanvas.width,
          previewCanvas.height / tempCanvas.height
        );
        
        const displayWidth = tempCanvas.width * displayScale;
        const displayHeight = tempCanvas.height * displayScale;
        
        const displayX = (previewCanvas.width - displayWidth) / 2;
        const displayY = (previewCanvas.height - displayHeight) / 2;
        
        ctx.drawImage(tempCanvas, displayX, displayY, displayWidth, displayHeight);
        markHarmonyPreviewReady(previewCanvas);
        return;
      }
      
      // Create color mappings
      const colorMappings = [];
      for (let i = 0; i < Math.min(originalColors.length, paletteColors.length); i++) {
        colorMappings.push({
          originalColor: originalColors[i],
          targetColor: paletteColors[i % paletteColors.length]
        });
      }
      
      // Use ColorProcessor if available
      if (typeof ColorProcessor !== 'undefined') {
        try {
          const colorProcessor = new ColorProcessor();
          const imageUrl = tempCanvas.toDataURL();
          
          const processedImageUrl = await colorProcessor.applyMultipleColorMappings(
            imageUrl,
            colorMappings
          );
          
          return new Promise((resolve) => {
            const resultImg = new Image();
            resultImg.onload = () => {
              const displayScale = Math.min(
                previewCanvas.width / resultImg.width,
                previewCanvas.height / resultImg.height
              );
              
              const displayWidth = resultImg.width * displayScale;
              const displayHeight = resultImg.height * displayScale;
              
              const displayX = (previewCanvas.width - displayWidth) / 2;
              const displayY = (previewCanvas.height - displayHeight) / 2;
              
              ctx.drawImage(resultImg, displayX, displayY, displayWidth, displayHeight);
              markHarmonyPreviewReady(previewCanvas);
              resolve();
            };
            resultImg.onerror = (e) => {
              console.error("Error loading processed harmony preview:", e);
              drawHarmonyFallbackPreview(previewCanvas, paletteIndex);
              resolve();
            };
            resultImg.src = processedImageUrl;
          });
        } catch (processingError) {
          console.error("Error in ColorProcessor:", processingError);
          // Fallback to original image
          const displayScale = Math.min(
            previewCanvas.width / tempCanvas.width,
            previewCanvas.height / tempCanvas.height
          );
          
          const displayWidth = tempCanvas.width * displayScale;
          const displayHeight = tempCanvas.height * displayScale;
          
          const displayX = (previewCanvas.width - displayWidth) / 2;
          const displayY = (previewCanvas.height - displayHeight) / 2;
          
          ctx.drawImage(tempCanvas, displayX, displayY, displayWidth, displayHeight);
          markHarmonyPreviewReady(previewCanvas);
        }
      } else {
        // Fallback: just show original image
        const displayScale = Math.min(
          previewCanvas.width / tempCanvas.width,
          previewCanvas.height / tempCanvas.height
        );
        
        const displayWidth = tempCanvas.width * displayScale;
        const displayHeight = tempCanvas.height * displayScale;
        
        const displayX = (previewCanvas.width - displayWidth) / 2;
        const displayY = (previewCanvas.height - displayHeight) / 2;
        
        ctx.drawImage(tempCanvas, displayX, displayY, displayWidth, displayHeight);
        markHarmonyPreviewReady(previewCanvas);
      }
      
    } catch (error) {
      console.error("Error generating harmony preview:", error);
      drawHarmonyFallbackPreview(previewCanvas, paletteIndex);
    }
  }
  
  function drawHarmonyFallbackPreview(canvas, paletteIndex) {
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#f5f5f5';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#999';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = '14px sans-serif';
    ctx.fillText(`${harmonyType} ${paletteIndex}`, canvas.width/2, canvas.height/2);
    markHarmonyPreviewReady(canvas);
  }
  
  function markHarmonyPreviewReady(canvas) {
    const container = canvas.closest('.palette-clickable-container');
    if (container) {
      container.classList.add('preview-ready');
    }
  }
  
  // Show full palette modal function
  function showHarmonyFullPaletteModal(fullPalette, harmonyType, paletteIndex) {
    // Remove any existing modal
    const existingModal = document.getElementById('harmonyFullPaletteModal');
    if (existingModal) {
      existingModal.remove();
    }
    
    const bgVariation = fullPalette._backgroundVariation || 'regular';
    
    // Create modal
    const modal = document.createElement('div');
    modal.id = 'harmonyFullPaletteModal';
    modal.className = 'full-palette-modal';
    modal.style.display = 'block';
    
    const modalContent = document.createElement('div');
    modalContent.className = 'full-palette-modal-content';
    
    const closeBtn = document.createElement('span');
    closeBtn.className = 'close-palette-modal';
    closeBtn.innerHTML = '&times;';
    closeBtn.onclick = () => modal.remove();
    
    const title = document.createElement('h3');
    title.className = 'palette-modal-title';
    title.textContent = `${harmonyType} Harmony Palette ${paletteIndex} (${bgVariation} background) - All Colors`;
    
    const colorsContainer = document.createElement('div');
    colorsContainer.className = 'all-colors-container';
    
    fullPalette.forEach((color, index) => {
      if (Array.isArray(color) && color.length === 3) {
        const colorDiv = document.createElement('div');
        colorDiv.className = 'full-palette-color';
        colorDiv.style.backgroundColor = `rgb(${color.join(',')})`;
        
        const colorInfo = document.createElement('div');
        colorInfo.className = 'color-info';
        const hexValue = rgbToHex(color[0], color[1], color[2]);
        const colorName = index === 0 ? `Background (${bgVariation})` : getColorName(color);
        colorInfo.textContent = `${colorName}\n${hexValue}`;
        
        colorDiv.appendChild(colorInfo);
        colorsContainer.appendChild(colorDiv);
      }
    });
    
    modalContent.appendChild(closeBtn);
    modalContent.appendChild(title);
    modalContent.appendChild(colorsContainer);
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
    
    // Close modal when clicking outside
    modal.onclick = (e) => {
      if (e.target === modal) {
        modal.remove();
      }
    };
  }
  
  // Create palette items
  for (let i = 0; i < Math.min(palettesToShow, Object.keys(palettes).length); i++) {
    const palette = palettes[i];
    
    if (!palette || palette.length === 0) continue;
    
    // Get background variation info
    const bgVariation = palette._backgroundVariation || 'regular';
    
    // Create layer-toggle-item structure to match your trending palettes
    const layerToggleItem = document.createElement('div');
    layerToggleItem.className = 'layer-toggle-item d-flex flex-column gap-2';
    
    // Add background variation indicator
    const bgIndicator = document.createElement('div');
    bgIndicator.className = 'bg-variation-indicator';
    bgIndicator.textContent = bgVariation.charAt(0).toUpperCase() + bgVariation.slice(1);
    bgIndicator.style.cssText = `
      font-size: 10px;
      text-align: center;
      padding: 2px 4px;
      border-radius: 3px;
      margin-bottom: 2px;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    `;
    
    // Style the indicator based on background type
    switch (bgVariation) {
      case 'dark':
        bgIndicator.style.backgroundColor = '#333';
        bgIndicator.style.color = '#fff';
        break;
      case 'faint':
        bgIndicator.style.backgroundColor = '#f8f9fa';
        bgIndicator.style.color = '#666';
        bgIndicator.style.border = '1px solid #dee2e6';
        break;
      case 'regular':
      default:
        bgIndicator.style.backgroundColor = '#e9ecef';
        bgIndicator.style.color = '#495057';
        break;
    }
    
    layerToggleItem.appendChild(bgIndicator);
    
    // Create the main color palette container (matching your existing structure)
    const colorPaletteDiv = document.createElement('div');
    colorPaletteDiv.className = 'color-palette d-flex flex-column';
    colorPaletteDiv.id = `harmony_colorPalette_${i}`;
    
    // Create clickable container (same as trending)
    const clickableContainer = document.createElement('div');
    clickableContainer.classList.add('palette-clickable-container');
    clickableContainer.dataset.paletteIndex = i;
    clickableContainer.dataset.collection = 'harmony';
    
    // Add preview container
    const previewContainer = document.createElement('div');
    previewContainer.classList.add('palette-preview-container');
    clickableContainer.appendChild(previewContainer);
    
    // Create preview canvas
    const previewCanvas = document.createElement('canvas');
    previewCanvas.width = 200;
    previewCanvas.height = 200;
    previewCanvas.classList.add('palette-preview-canvas');
    previewContainer.appendChild(previewCanvas);
    
    // Create swatch container
    const swatchContainer = document.createElement('div');
    swatchContainer.classList.add('swatch-container');
    clickableContainer.appendChild(swatchContainer);
    
    // Prepare display colors (same logic as trending)
    const displayColors = prepareDisplayColors(palette);
    
    // Add color swatches
    displayColors.forEach((color, idx) => {
      if (Array.isArray(color) && color.length === 3) {
        const swatch = document.createElement('div');
        swatch.classList.add('color-swatch');
        swatch.style.backgroundColor = `rgb(${color.join(',')})`;
        
        const hexValue = rgbToHex(color[0], color[1], color[2]);
        const colorName = idx === 0 ? `Background (${bgVariation})` : getColorName(color);
        swatch.title = `${colorName} - ${hexValue}`;
        
        swatchContainer.appendChild(swatch);
      }
    });
    
    // Add "Show All" button
    const showAllButton = document.createElement('div');
    showAllButton.classList.add('show-all-colors-btn');
    showAllButton.innerHTML = '+';
    showAllButton.title = 'Show all colors in harmony palette';
    clickableContainer.appendChild(showAllButton);
    
    // Add event listeners
    clickableContainer.addEventListener('click', function(e) {
      if (e.target === showAllButton) return; // Don't trigger on show all button
      
      const paletteIndex = parseInt(this.dataset.paletteIndex, 10);
      if (typeof applyHarmonyPalette === 'function') {
        applyHarmonyPalette(paletteIndex, paletteCollectionName);
      }
    });
    
    showAllButton.addEventListener('click', function(e) {
      e.stopPropagation();
      showHarmonyFullPaletteModal(palette, harmonyType, i);
    });
    
    // Add to main container
    colorPaletteDiv.appendChild(clickableContainer);
    
    // Create button container for harmony controls - ONLY FAVORITE BUTTON
    const buttonContainer = document.createElement('div');
    buttonContainer.className = 'd-flex align-items-center justify-content-center w-100';
    
    // Favorite button (only button now)
    const favBtn = document.createElement('button');
    favBtn.className = 'btn favorite-btn';
    favBtn.innerHTML = '<i class="bi bi-star"></i><span class="fav-count">0</span>';
    favBtn.setAttribute('data-palette-type', 'HARMONY');
    favBtn.setAttribute('data-colors-id', i);
    favBtn.onclick = (e) => {
      e.stopPropagation();
      if (typeof toggleFavorite === 'function') {
        toggleFavorite(favBtn, 'harmony');
      }
    };
    
    // Only add the favorite button
    buttonContainer.appendChild(favBtn);
    
    layerToggleItem.appendChild(colorPaletteDiv);
    layerToggleItem.appendChild(buttonContainer);
    container.appendChild(layerToggleItem);
    
    // Generate preview with a small delay - PROPERLY HANDLE THE ASYNC CALL
    setTimeout(() => {
      generateHarmonyPreview(previewCanvas, palette, i).catch(error => {
        console.error(`Error generating preview for palette ${i}:`, error);
        drawHarmonyFallbackPreview(previewCanvas, i);
      });
    }, i * 50);
  }
}
    

// Function to regenerate a specific harmony palette
async function regenerateHarmonyPalette(paletteIndex, harmonyType) {
  try {
    const canvas = document.getElementById('layer_canvas_1');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    
    // Regenerate all palettes for now (you could optimize this to regenerate just one)
    showToast('Regenerating palettes...');
    await processHarmony(ctx, 1, canvas, 0, harmonyType, true);
    
  } catch (error) {
    console.error('Error regenerating harmony palette:', error);
    showToast('Error regenerating palette');
  }
}

// Helper function for toast messages (if not already defined globally)
if (typeof showToast !== 'function') {
  window.showToast = function(message) {
    const toast = document.createElement('div');
    toast.textContent = message;
    toast.style.cssText = `
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 12px 24px;
      border-radius: 6px;
      z-index: 10001;
      font-family: Arial, sans-serif;
      font-size: 14px;
    `;
    document.body.appendChild(toast);
    
    setTimeout(() => {
      if (document.body.contains(toast)) {
        document.body.removeChild(toast);
      }
    }, 3000);
  };
  setTimeout(() => loadFavorites(), 200);
}

// Keep your existing keyboard shortcuts
document.addEventListener('keydown', function(event) {
  if (event.ctrlKey && event.altKey) {
    const canvas = document.getElementById('layer_canvas_1');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    
    switch(event.key) {
      case '1':
        processHarmony(ctx, 1, canvas, 0, 'Monochromatic');
        break;
      case '2':
        processHarmony(ctx, 1, canvas, 0, 'Analogous');
        break;
      case '3':
        processHarmony(ctx, 1, canvas, 0, 'Complementary');
        break;
      case '4':
        processHarmony(ctx, 1, canvas, 0, 'Split Complementary');
        break;
      case '5':
        processHarmony(ctx, 1, canvas, 0, 'Triadic');
        break;
      case '6':
        processHarmony(ctx, 1, canvas, 0, 'Tetradic');
        break;
      case '7':
        processHarmony(ctx, 1, canvas, 0, 'Square');
        break;
    }
  }
});

// Update the event listeners for harmony functionality
document.addEventListener('DOMContentLoaded', function() {
  const generateHarmonyBtn = document.getElementById('generateHarmonyBtn');
  const harmonyTypeSelect = document.getElementById('harmonyTypeSelect');
  const backgroundVariationSelect = document.getElementById('backgroundVariationSelect');
  
  if (generateHarmonyBtn) {
    generateHarmonyBtn.addEventListener('click', async function() {
      const selectedHarmonyType = harmonyTypeSelect.value;
      const selectedBackgroundVariation = backgroundVariationSelect.value;
      const canvas = document.getElementById('layer_canvas_1');
      
      if (!canvas) {
        showToast('Please load an image first');
        return;
      }
      
      const ctx = canvas.getContext('2d');
      await processHarmony(ctx, 1, canvas, 0, selectedHarmonyType, true, selectedBackgroundVariation);
    });
  }
});

// Update keyboard shortcuts to include background variations
document.addEventListener('keydown', function(event) {
  if (event.ctrlKey && event.altKey) {
    const canvas = document.getElementById('layer_canvas_1');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    
    // Default to regular background for keyboard shortcuts
    const bgVariation = 'regular';
    
    switch(event.key) {
      case '1':
        processHarmony(ctx, 1, canvas, 0, 'Monochromatic', false, bgVariation);
        break;
      case '2':
        processHarmony(ctx, 1, canvas, 0, 'Analogous', false, bgVariation);
        break;
      case '3':
        processHarmony(ctx, 1, canvas, 0, 'Complementary', false, bgVariation);
        break;
      case '4':
        processHarmony(ctx, 1, canvas, 0, 'Split Complementary', false, bgVariation);
        break;
      case '5':
        processHarmony(ctx, 1, canvas, 0, 'Triadic', false, bgVariation);
        break;
      case '6':
        processHarmony(ctx, 1, canvas, 0, 'Tetradic', false, bgVariation);
        break;
      case '7':
        processHarmony(ctx, 1, canvas, 0, 'Square', false, bgVariation);
        break;
    }
  }
});





// Function to check if two colors are similar
function isColorSimilar(color1, color2, threshold = 30) {
  // Calculate Euclidean distance between colors in RGB space
  const rDiff = color1[0] - color2[0];
  const gDiff = color1[1] - color2[1];
  const bDiff = color1[2] - color2[2];
  
  const distance = Math.sqrt(rDiff * rDiff + gDiff * gDiff + bDiff * bDiff);
  return distance < threshold;
}

// Add HSV conversion functions first
function rgbToHsv(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;

  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  let h, s, v = max;
  const d = max - min;
  s = max === 0 ? 0 : d / max;

  if (max === min) {
      h = 0;
  } else {
      switch (max) {
          case r: h = (g - b) / d + (g < b ? 6 : 0); break;
          case g: h = (b - r) / d + 2; break;
          case b: h = (r - g) / d + 4; break;
      }
      h /= 6;
  }

  return [h, s, v];
}

function hsvToRgb(hsv) {
  let h = hsv[0];
  let s = hsv[1];
  let v = hsv[2];
  
  let r, g, b;
  const i = Math.floor(h * 6);
  const f = h * 6 - i;
  const p = v * (1 - s);
  const q = v * (1 - f * s);
  const t = v * (1 - (1 - f) * s);

  switch (i % 6) {
      case 0: r = v; g = t; b = p; break;
      case 1: r = q; g = v; b = p; break;
      case 2: r = p; g = v; b = t; break;
      case 3: r = p; g = q; b = v; break;
      case 4: r = t; g = p; b = v; break;
      case 5: r = v; g = p; b = q; break;
  }

  return [
      Math.round(r * 255),
      Math.round(g * 255),
      Math.round(b * 255)
  ];
}



// Color Conversion Utilities
function rgbToHsl(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;

  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  let h, s, l = (max + min) / 2;

  if (max === min) {
      h = s = 0;
  } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

      switch (max) {
          case r: h = (g - b) / d + (g < b ? 6 : 0); break;
          case g: h = (b - r) / d + 2; break;
          case b: h = (r - g) / d + 4; break;
      }
      h /= 6;
  }

  return [h, s, l];
}

function hslToRgb(h, s, l) {
  // Validate and normalize inputs to ensure they're in the right range
  console.log(`hslToRgb input - h: ${h}, s: ${s}, l: ${l}`);
  
  // Normalize h to 0-1 range if needed
  if (h > 1) {
    h = h / 360;
  }
  
  // Normalize s and l to 0-1 range if needed
  if (s > 1) {
    s = s / 100;
  }
  
  if (l > 1) {
    l = l / 100;
  }
  
  // Safety checks
  h = Math.max(0, Math.min(1, h));
  s = Math.max(0, Math.min(1, s));
  l = Math.max(0, Math.min(1, l));
  
  console.log(`normalized - h: ${h}, s: ${s}, l: ${l}`);
  
  let r, g, b;

  if (s === 0) {
    r = g = b = l; // achromatic
  } else {
    const hue2rgb = (p, q, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };

    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;

    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }
  
  const rgb = [
    Math.round(r * 255),
    Math.round(g * 255),
    Math.round(b * 255)
  ];
  
  console.log(`Output RGB: ${rgb[0]}, ${rgb[1]}, ${rgb[2]}`);
  
  return rgb;
}


const harmonySeeds = {
  'Monochromatic': Date.now(),
  'Analogous': Date.now() + 100,
  'Complementary': Date.now() + 200,
  'Split Complementary': Date.now() + 300,
  'Triadic': Date.now() + 400,
  'Tetradic': Date.now() + 500,
  'Square': Date.now() + 600
};

function seededRandom(seed) {
  const a = 1664525;
  const c = 1013904223;
  const m = Math.pow(2, 32);
  let z = seed;
  
  return function() {
      z = (a * z + c) % m;
      return z / m;
  };
}


// Helper function to add subtle variations to colors
function addVariation(value, amount, min = 0, max = 1) {
  const variation = (Math.random() - 0.5) * 2 * amount;
  return Math.max(min, Math.min(max, value + variation));
}


document.addEventListener('DOMContentLoaded', function() {
  const harmonyButton = document.getElementById('harmonyButton');
  const harmonyMenu = document.getElementById('harmonyMenu');
  let selectedHarmony = '';

  // Toggle menu on button click
  harmonyButton.addEventListener('click', function(e) {
      e.stopPropagation();
      harmonyMenu.style.display = harmonyMenu.style.display === 'none' ? 'none' : 'none';
  });

  // Handle menu item selection
  document.querySelectorAll('.menu-item').forEach(item => {
      item.addEventListener('click', function(e) {
          e.stopPropagation();
          selectedHarmony = this.dataset.harmony;
          
          // Remove active class from all items
          document.querySelectorAll('.menu-item').forEach(i => i.classList.remove('active'));
          // Add active class to selected item
          this.classList.add('active');
          
          // Close menu
          harmonyMenu.style.display = 'none';
          
          // Process harmony
          const totalLayers = document.querySelectorAll('[id^="layer_canvas_"]').length;
          const firstCanvas = document.getElementById('layer_canvas_1');
          if (firstCanvas) {
              const ctx = firstCanvas.getContext('2d');
              processHarmony(ctx, totalLayers, firstCanvas, 0, selectedHarmony);
          }
      });
  });

  // Close menu when clicking outside
  document.addEventListener('click', function(e) {
      if (!harmonyButton.contains(e.target) && !harmonyMenu.contains(e.target)) {
          harmonyMenu.style.display = 'none';
      }
  });

  // Prevent menu from closing when clicking inside it
  harmonyMenu.addEventListener('click', function(e) {
      e.stopPropagation();
  });
});



class ImageAdjuster {
  constructor() {
        this.adjustments = {
            combined: {
                hue: 0,
                saturation: 0,
                brightness: 0,
                temperature: 0
            }
        };
        this.showIndividualLayers = false;
        this.setupEventListeners();
        this.originalImageData = {}; // Change to object to store data for each layer
    }

    setupEventListeners() {
        const toggleButton = document.getElementById('adjustmentToggle');
        const adjustmentPanel = document.getElementById('adjustmentPanel');

        toggleButton.addEventListener('click', () => {
            const isHidden = adjustmentPanel.style.display === 'none';
            adjustmentPanel.style.display = isHidden ? 'block' : 'none';
            if (isHidden) {
                this.createAdjustmentSliders();
            }
        });
    }

    createAdjustmentSliders() {
        const container = document.querySelector('.sliders-container');
        container.innerHTML = '';

        // Add toggle button for individual layers
        const toggleLayersBtn = document.createElement('button');
        toggleLayersBtn.textContent = this.showIndividualLayers ? 'Show Combined Layer' : 'Show Individual Layers';
        toggleLayersBtn.className = 'toggle-layers-btn';
        toggleLayersBtn.style.cssText = `
            margin-bottom: 15px;
            padding: 8px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
        `;
        toggleLayersBtn.addEventListener('click', () => {
            this.showIndividualLayers = !this.showIndividualLayers;
            this.createAdjustmentSliders();
        });
        container.appendChild(toggleLayersBtn);

        if (!this.showIndividualLayers) {
            // Create combined layer controls
            const combinedDiv = document.createElement('div');
            combinedDiv.className = 'layer-adjustments';
            combinedDiv.innerHTML = `
                <h4>All Layers</h4>
                <div class="slider-group">
                    <label>Hue</label>
                    <input type="range" min="-180" max="180" value="${this.adjustments.combined.hue}" 
                           data-layer="combined" data-adjustment="hue">
                </div>
                <div class="slider-group">
                    <label>Saturation</label>
                    <input type="range" min="-100" max="100" value="${this.adjustments.combined.saturation}" 
                           data-layer="combined" data-adjustment="saturation">
                </div>
                <div class="slider-group">
                    <label>Brightness</label>
                    <input type="range" min="-100" max="100" value="${this.adjustments.combined.brightness}" 
                           data-layer="combined" data-adjustment="brightness">
                </div>
                <div class="slider-group">
                    <label>Temperature</label>
                    <input type="range" min="-100" max="100" value="${this.adjustments.combined.temperature}" 
                           data-layer="combined" data-adjustment="temperature">
                </div>
            `;
            container.appendChild(combinedDiv);

            this.setupSliderListeners(combinedDiv);
        } else {
            // Create individual layer controls
            const layerCanvases = document.querySelectorAll('[id^="layer_canvas_"]');
            
            layerCanvases.forEach(layerCanvas => {
                const layer = layerCanvas.id.split('_')[2];
                
                // Initialize layer adjustments if they don't exist
                if (!this.adjustments[layer]) {
                    this.adjustments[layer] = {
                        hue: 0,
                        saturation: 0,
                        brightness: 0,
                        temperature: 0
                    };
                }

                const layerDiv = document.createElement('div');
                layerDiv.className = 'layer-adjustments';
                layerDiv.innerHTML = `
                    <h4>Layer ${layer}</h4>
                    <div class="slider-group">
                        <label>Hue</label>
                        <input type="range" min="-180" max="180" value="${this.adjustments[layer].hue}" 
                               data-layer="${layer}" data-adjustment="hue">
                    </div>
                    <div class="slider-group">
                        <label>Saturation</label>
                        <input type="range" min="-100" max="100" value="${this.adjustments[layer].saturation}" 
                               data-layer="${layer}" data-adjustment="saturation">
                    </div>
                    <div class="slider-group">
                        <label>Brightness</label>
                        <input type="range" min="-100" max="100" value="${this.adjustments[layer].brightness}" 
                               data-layer="${layer}" data-adjustment="brightness">
                    </div>
                    <div class="slider-group">
                        <label>Temperature</label>
                        <input type="range" min="-100" max="100" value="${this.adjustments[layer].temperature}" 
                               data-layer="${layer}" data-adjustment="temperature">
                    </div>
                `;

                container.appendChild(layerDiv);
                this.setupSliderListeners(layerDiv);
            });
        }
    }

    setupSliderListeners(containerDiv) {
        containerDiv.querySelectorAll('input[type="range"]').forEach(slider => {
            slider.addEventListener('input', (e) => {
                const layer = e.target.dataset.layer;
                const adjustment = e.target.dataset.adjustment;
                
                // Initialize layer adjustments if they don't exist
                if (!this.adjustments[layer]) {
                    this.adjustments[layer] = {
                        hue: 0,
                        saturation: 0,
                        brightness: 0,
                        temperature: 0
                    };
                }

                this.adjustments[layer][adjustment] = parseInt(e.target.value);
                
                if (layer === 'combined') {
                    // Apply to all layers
                    const layerCanvases = document.querySelectorAll('[id^="layer_canvas_"]');
                    layerCanvases.forEach(canvas => {
                        const layerNum = canvas.id.split('_')[2];
                        // Initialize layer adjustments if they don't exist
                        if (!this.adjustments[layerNum]) {
                            this.adjustments[layerNum] = {
                                hue: 0,
                                saturation: 0,
                                brightness: 0,
                                temperature: 0
                            };
                        }
                        this.adjustments[layerNum][adjustment] = parseInt(e.target.value);
                        this.applyAdjustments(layerNum);
                    });
                } else {
                    this.applyAdjustments(layer);
                }
            });
        });
    }

    applyAdjustments(layer) {
    const layerCanvas = document.getElementById(`layer_canvas_${layer}`);
    if (!layerCanvas) return;

    if (!this.adjustments[layer]) {
        this.adjustments[layer] = {
            hue: 0,
            saturation: 0,
            brightness: 0,
            temperature: 0
        };
    }

    const ctx = layerCanvas.getContext('2d');
    const imageData = ctx.getImageData(0, 0, layerCanvas.width, layerCanvas.height);
    const data = imageData.data;

    // Store original image data if not already stored for this layer
    if (!this.originalImageData[layer]) {
        this.originalImageData[layer] = new Uint8ClampedArray(data);
    }

    for (let i = 0; i < data.length; i += 4) {
        // Start from original values for this layer
        let r = this.originalImageData[layer][i];
        let g = this.originalImageData[layer][i + 1];
        let b = this.originalImageData[layer][i + 2];

            // Apply temperature adjustment
            const temp = this.adjustments[layer].temperature;
            if (temp !== 0) {
                const adjustment = temp / 100;
                if (adjustment > 0) {
                    // Warming: increase red, decrease blue
                    r = Math.min(255, r + (adjustment * 30));
                    b = Math.max(0, b - (adjustment * 30));
                } else {
                    // Cooling: decrease red, increase blue
                    r = Math.max(0, r - (Math.abs(adjustment) * 30));
                    b = Math.min(255, b + (Math.abs(adjustment) * 30));
                }
            }

            // Convert to HSL for other adjustments
            let [h, s, l] = this.rgbToHsl(r, g, b);

            // Apply other adjustments
            h = (h + this.adjustments[layer].hue) % 360;
            if (h < 0) h += 360;
            s = Math.max(0, Math.min(100, s + this.adjustments[layer].saturation));
            l = Math.max(0, Math.min(100, l + this.adjustments[layer].brightness));

            // Convert back to RGB
            [r, g, b] = this.hslToRgb(h, s, l);

            // Set final values
            data[i] = Math.round(Math.max(0, Math.min(255, r)));
            data[i + 1] = Math.round(Math.max(0, Math.min(255, g)));
            data[i + 2] = Math.round(Math.max(0, Math.min(255, b)));
            // Alpha channel remains unchanged
        }

        ctx.putImageData(imageData, 0, 0);
    }


    rgbToHsl(r, g, b) {
        r /= 255;
        g /= 255;
        b /= 255;

        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;

        if (max === min) {
            h = s = 0;
        } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }

        return [h * 360, s * 100, l * 100];
    }

    hslToRgb(h, s, l) {
        h /= 360;
        s /= 100;
        l /= 100;

        let r, g, b;

        if (s === 0) {
            r = g = b = l;
        } else {
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            };

            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;

            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
        }

        return [r * 255, g * 255, b * 255];
    }
}


let distinctColorsArray = [];
let distinctColorsArrayColorPallet = [];

// Initialize the adjuster
const imageAdjuster = new ImageAdjuster();

function editLayer(layerIndex) {
  // Save current canvas state before showing modal
  const canvas = document.getElementById(`layer_canvas_${layerIndex}`);
  if (canvas) {
    const currentState = canvas.toDataURL();
    canvas.setAttribute('data-current-state', currentState);
  }

  $('#colorPickerModal').modal('show');
  updateLayersWithNewColorCount(layerIndex);
}

function resetLayer(layerIndex) {
  // Reset layer to original state using the correct method name
  if (layerStates && layerStates.resetToOriginal) {
    layerStates.resetToOriginal(layerIndex);
  } else {
    console.error('layerStates.resetToOriginal method not available');
  }
}

function showLayerInfoButton(layerIndex) {
  // Save current canvas state before showing modal
  const canvas = document.getElementById(`layer_canvas_${layerIndex + 1}`);
  if (canvas) {
    const currentState = canvas.toDataURL();
    canvas.setAttribute('data-current-state', currentState);
  }

  $('#colorPickerModal').modal('show');
  updateLayersWithNewColorCount(layerIndex + 1);
}

function showLayerInfo() {
  contextMenu.style.display = 'none';
  $('#colorPickerModal').modal('show');
  const layerIndex = contextMenu.dataset.layerIndex;
  updateLayersWithNewColorCount(layerIndex);
}

document.addEventListener('DOMContentLoaded', function() {
  const layerColors = {};
  const loadingScreen = document.getElementById('loading-screen');
  const totalLayers = {{ layers|length }};
  let loadedImagesCount = 0;
  const loader = document.getElementById('loading-screen');

  // Remove context menu functionality since we're using buttons now
  document.addEventListener('click', function(event) {
    if (contextMenu.style.display === 'block' && !contextMenu.contains(event.target)) {
      contextMenu.style.display = 'none';
    }
  });

  function checkIfAllImagesLoaded() {
    if (loadedImagesCount === totalLayers) {
      loadingScreen.style.display = 'none';
      createColorButtons();
    }
  }

  function isColorInArray(color, array) {
    return array.some(existingColor =>
      existingColor[0] === color[0] &&
      existingColor[1] === color[1] &&
      existingColor[2] === color[2]
    );
  }

  let distinctColorsArray = [];
  let singleLayerDistinctColorsArray = [];
  let distinctColorsArrayColorPallet = [];

  {% for layer in layers %}
  let img{{ forloop.counter }} = new Image();
  img{{ forloop.counter }}.src = "{{ layer.path }}";
  let canvas{{ forloop.counter }} = document.getElementById('layer_canvas_{{ forloop.counter }}');
  let ctx{{ forloop.counter }} = canvas{{ forloop.counter }}.getContext('2d', { willReadFrequently: true });
  let latestImageData{{ forloop.counter }} = null;

  img{{ forloop.counter }}.onload = function() {
    canvas{{ forloop.counter }}.width = img{{ forloop.counter }}.width;
    canvas{{ forloop.counter }}.height = img{{ forloop.counter }}.height;
    ctx{{ forloop.counter }}.drawImage(img{{ forloop.counter }}, 0, 0);
    layerStates.saveOriginalState({{ forloop.counter }});

    const imageData{{ forloop.counter }} = ctx{{ forloop.counter }}.getImageData(0, 0, canvas{{ forloop.counter }}.width, canvas{{ forloop.counter }}.height);

    let colorCount = 0;
    let distinctColorTolarance = 0;
    
    if(totalLayers === 1) {
      distinctColorTolarance = 100;
      colorCount = 20;
    } else if(totalLayers > 5) {
      distinctColorTolarance = 180;
      colorCount = 7;
    } else {
      distinctColorTolarance = 190;
      colorCount = 7;
    }
    
    const analysis = analyzeImageLayer(ctx{{ forloop.counter }});
    let { avgLightness, hueTolerance, lightnessTolerance } = analysis;
    hueTolerance = hueTolerance*100;
    if(lightnessTolerance<0.5) lightnessTolerance=0.7;
    
    let distinctColors{{ forloop.counter }} = getDistinctColors(imageData{{ forloop.counter }}, 30, 50);
    console.log(distinctColors{{ forloop.counter }})

    distinctColors{{ forloop.counter }}.forEach((color, index) => {
      if (!isColorInArray(color, distinctColorsArray)) {
        distinctColorsArrayColorPallet.push(color);
        distinctColorsArray.push(color);
      }
    });

    // Increment the loaded image counter and check if all images are loaded
    loadedImagesCount++;
    checkIfAllImagesLoaded();
  };

  img{{ forloop.counter }}.onerror = function() {
    loadedImagesCount++;
    checkIfAllImagesLoaded();
  };

  loader.style.display = 'block';
  
  setTimeout(() => {
    const buttons = document.querySelectorAll('#image-color-pickers button');
    const rgbColors = generateUniqueRGBColorArray(distinctColorsArrayColorPallet.length+1);
    layerColors[{{ forloop.counter }}] = {
      targetColors: distinctColorsArrayColorPallet,
      newColors: rgbColors
    };
    localStorage.setItem('distinctColorsArrayColorPallet', JSON.stringify(distinctColorsArrayColorPallet));
    const layerIndex = {{ forloop.counter }};
    const totalLayers = {{ layers|length }};
    
    if (totalLayers === 1) {
      for (let i = 0; i < 25; i++) {
        displayColorPalette(i, distinctColorsArrayColorPallet, 'trending', distinctColorsArrayColorPallet.length+1, totalLayers);
        displayColorPalette(i, distinctColorsArrayColorPallet, 'ss', distinctColorsArrayColorPallet.length+1, totalLayers);
        displayColorPalette(i, distinctColorsArrayColorPallet, 'aw', distinctColorsArrayColorPallet.length+1, totalLayers);
      }
    } else {
      displayColorPalette(layerIndex, rgbColors, 'trending', distinctColorsArrayColorPallet.length+1, totalLayers);
      displayColorPalette(layerIndex, rgbColors, 'ss', distinctColorsArrayColorPallet.length+1, totalLayers);
      displayColorPalette(layerIndex, rgbColors, 'aw', distinctColorsArrayColorPallet.length+1, totalLayers);
    }

    const layerCanvas = document.getElementById(`layer_canvas_${layerIndex}`);
    const layerCtx = layerCanvas.getContext('2d', { willReadFrequently: true });
  }, 1000);
  {% endfor %}
});

// Rest of your existing functions remain the same...
function getDominantColor(imageData) {
  const data = imageData.data;
  const colorCounts = {};
  const allColors = new Map();
  let totalPixels = 0;

  for (let i = 0; i < data.length; i += 4) {
    const r = data[i];
    const g = data[i + 1];
    const b = data[i + 2];
    const a = data[i + 3];

    if (a === 0) continue;
    if ((r === 0 && g === 0 && b === 0) || (r === 255 && g === 255 && b === 255)) continue;

    const [h, s, l] = rgbToHsl(r, g, b);

    if (s < 0.05) continue;

    const colorName = getDominantColorName([r, g, b]);
    const existingColor = allColors.get(colorName);

    if (existingColor) {
      existingColor.pixelCount++;
    } else {
      allColors.set(colorName, { rgb: [r, g, b], colorName, pixelCount: 1 });
    }

    totalPixels++;
  }

  let maxCount = 0;
  let dominantColor = null;

  for (const [colorName, colorInfo] of allColors.entries()) {
    if (colorInfo.pixelCount > maxCount) {
      maxCount = colorInfo.pixelCount;
      dominantColor = colorInfo;
    }
  }

  if (dominantColor) {
    const nonDominantColors = [];
    for (const [colorName, colorInfo] of allColors.entries()) {
      if (colorName !== dominantColor.colorName) {
        const pixelPercentage = (colorInfo.pixelCount / totalPixels) * 100;
        nonDominantColors.push({ ...colorInfo, pixelPercentage });
      }
    }

    return {
      referenceColor: dominantColor.rgb,
      dominantHue: rgbToHsl(...dominantColor.rgb)[0],
      tolerance: {
        hue: 45 / 360,
        saturation: 0.4,
        lightness: 0.45
      },
      isSingleShade: false,
      nonDominantColors,
      dominantColorName: dominantColor.colorName
    };
  }

  return null;
}

// Add this shuffle function at the top level
function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}

function shuffleSinglePalette(layerIndex) {
  const paletteContainer = document.getElementById(`colorPalette_${layerIndex}`);
  if (!paletteContainer) return;

  // Toggle the state for this palette
  window.paletteToggleState[layerIndex] = !window.paletteToggleState[layerIndex];

  if (window.paletteToggleState[layerIndex]) {
      // If toggled on, generate and apply new colors
      const swatches = Array.from(paletteContainer.querySelectorAll('.color-swatch'));
      if (swatches.length === 0) return;

      const colors = swatches.map(swatch => {
          const style = window.getComputedStyle(swatch);
          const bgcolor = style.backgroundColor;
          return bgcolor.match(/\d+/g).map(Number);
      });

      // Shuffle colors
      const shuffledColors = shuffleArray([...colors]);

      // Apply shuffled colors
      swatches.forEach((swatch, index) => {
          swatch.style.backgroundColor = `rgb(${shuffledColors[index].join(',')})`;
      });

      // Store the shuffled colors
      window.trendingPaletteColors = window.trendingPaletteColors || {};
      window.trendingPaletteColors[layerIndex] = shuffledColors;
  } else {
      // If toggled off, revert to original colors
      const originalColors = window.originalPaletteColors[layerIndex];
      if (originalColors) {
          displayColorPalette(layerIndex, originalColors);
      }
  }
}



// Add this function to your code
function shufflePalette(paletteIndex, collection = 'trending') {
    // Get the stored full palette
    const fullPalette = window[`${collection}PaletteColors`] && 
                        window[`${collection}PaletteColors`][paletteIndex];
    
    if (!fullPalette || fullPalette.length === 0) {
        console.error(`No palette found to shuffle for ${collection}[${paletteIndex}]`);
        return;
    }
    
    // Function to convert RGB to HSL
    function rgbToHsl(r, g, b) {
        r /= 255; g /= 255; b /= 255;
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;

        if (max === min) {
            h = s = 0;
        } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            
            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }

        return [h * 360, s * 100, l * 100];
    }

    // Function to convert HSL to RGB
    function hslToRgb(h, s, l) {
        h /= 360; s /= 100; l /= 100;
        let r, g, b;

        if (s === 0) {
            r = g = b = l;
        } else {
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            };

            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;

            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
        }

        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }
    
    // Apply a new random transformation to THIS SPECIFIC palette
    const hueShift = Math.floor(Math.random() * 360);
    const satFactor = 0.7 + (Math.random() * 0.6);
    const lightFactor = 0.8 + (Math.random() * 0.4);
    
    // Create a new transformed palette
    const newPalette = fullPalette.map(color => {
        try {
            const [h, s, l] = rgbToHsl(...color);
            
            // Apply transformations
            const newHue = (h + hueShift) % 360;
            const newSat = Math.min(100, s * satFactor);
            const newLight = Math.min(95, Math.max(5, l * lightFactor));
            
            return hslToRgb(newHue, newSat, newLight);
        } catch (e) {
            console.warn("Error transforming color:", e);
            return [128, 128, 128]; // Gray fallback
        }
    });
    
    // Update only THIS palette in storage
    window[`${collection}PaletteColors`][paletteIndex] = newPalette;
    
    // Apply collection-specific adjustments
    let displayPalette = [...newPalette];
    try {
        if (collection === 'ss') {
            displayPalette = displayPalette.map(color => {
                const [h, s, l] = rgbToHsl(...color);
                return hslToRgb(h, Math.min(100, s * 1.2), Math.min(100, l * 1.1));
            });
        } else if (collection === 'aw') {
            displayPalette = displayPalette.map(color => {
                const [h, s, l] = rgbToHsl(...color);
                return hslToRgb(h, s * 0.9, l * 0.85);
            });
        }
    } catch (e) {
        console.warn("Error applying collection adjustments:", e);
        displayPalette = [...newPalette];
    }
    
    // Update the UI for this specific palette only
    const paletteContainer = document.getElementById(`${collection}_colorPalette_${paletteIndex}`);
    if (!paletteContainer) {
        console.error(`Palette container not found: ${collection}_colorPalette_${paletteIndex}`);
        return;
    }
    
    // Prepare display colors - ONLY for this specific palette
    function prepareDisplayColors(colors, displayCount = 6) {
        if (!colors || colors.length === 0) return [];
        
        // Always include the first color
        let displayColors = [colors[0]];
        
        if (colors.length > displayCount) {
            // Select remaining display colors evenly distributed
            const step = (colors.length - 1) / (displayCount - 1);
            for (let i = 1; i < displayCount; i++) {
                const idx = Math.min(Math.floor(1 + (i - 1) * step), colors.length - 1);
                displayColors.push(colors[idx]);
            }
        } else if (colors.length < displayCount) {
            // Add remaining colors
            for (let i = 1; i < colors.length; i++) {
                displayColors.push(colors[i]);
            }
            
            // If still not enough, duplicate some colors
            while (displayColors.length < displayCount) {
                const idx = displayColors.length % colors.length;
                displayColors.push([...colors[idx]]);
            }
        } else {
            // We have exactly the right number of colors
            displayColors = [...colors];
        }
        
        return displayColors;
    }
    
    const displayColors = prepareDisplayColors(displayPalette);
    
    // Clear the container
    paletteContainer.innerHTML = '';
    
    // Function to convert RGB to HEX
    function rgbToHex(r, g, b) {
        return '#' + [r, g, b].map(x => {
            const hex = x.toString(16);
            return hex.length === 1 ? '0' + hex : hex;
        }).join('');
    }
    
    // Function to get color name
    function getColorName(rgb) {
        try {
            const [r, g, b] = rgb;
            
            // Convert RGB to HSV for better color categorization
            const rNorm = r / 255;
            const gNorm = g / 255;
            const bNorm = b / 255;
            const max = Math.max(rNorm, gNorm, bNorm);
            const min = Math.min(rNorm, gNorm, bNorm);
            const diff = max - min;
            
            // Calculate Hue
            let h = 0;
            if (max !== min) {
                if (max === rNorm) {
                    h = (60 * ((gNorm - bNorm) / diff) + 360) % 360;
                } else if (max === gNorm) {
                    h = (60 * ((bNorm - rNorm) / diff) + 120) % 360;
                } else {
                    h = (60 * ((rNorm - gNorm) / diff) + 240) % 360;
                }
            }
            
            // Calculate Value (brightness)
            const v = max;
            
            // Determine hue category
            let hueName;
            if (h < 15 || h >= 345) hueName = "Red";
            else if (h >= 15 && h < 45) hueName = "Orange";
            else if (h >= 45 && h < 75) hueName = "Yellow";
            else if (h >= 75 && h < 165) hueName = "Green";
            else if (h >= 165 && h < 195) hueName = "Cyan";
            else if (h >= 195 && h < 255) hueName = "Blue";
            else if (h >= 255 && h < 285) hueName = "Purple";
            else if (h >= 285 && h < 345) hueName = "Pink";
            
            // Simplified shade prefix
            let shadePrefix = "";
            if (v < 0.4) shadePrefix = "Dark";
            else if (v > 0.7) shadePrefix = "Light";
            
            return shadePrefix ? `${shadePrefix} ${hueName}` : hueName;
        } catch (e) {
            console.warn("Error determining color name:", e);
            return "Unknown";
        }
    }
    
    // Create container for the palette
    const clickableContainer = document.createElement('div');
    clickableContainer.classList.add('palette-clickable-container');
    paletteContainer.appendChild(clickableContainer);
    
    // Add data attributes
    clickableContainer.dataset.paletteIndex = paletteIndex;
    clickableContainer.dataset.collection = collection;
    
    // Add click handler
    clickableContainer.addEventListener('click', function() {
        try {
            const pIndex = parseInt(this.dataset.paletteIndex, 10);
            const collName = this.dataset.collection;
            
            // Get the FULL palette from storage
            const fullPalette = window[`${collName}PaletteColors`] && 
                                window[`${collName}PaletteColors`][pIndex];
            
            if (!fullPalette || fullPalette.length === 0) {
                console.error(`No full palette found for ${collName}[${pIndex}]`);
                return;
            }
            console.log(`Clicked on palette `);
            // Call processPallet with the FULL palette
            if (typeof window.processPallet === 'function') {
                window.processPallet(null, 1, null, 0, null, fullPalette, pIndex);
            }
        } catch (e) {
            console.error("Error in palette click handler:", e);
        }
    });
    
    // Display the colors
    displayColors.forEach((color, idx) => {
        const swatch = document.createElement('div');
        swatch.classList.add('color-swatch');
        swatch.style.backgroundColor = `rgb(${color.join(',')})`;
        
        // Updated tooltip with HEX value
        const hexValue = rgbToHex(color[0], color[1], color[2]);
        swatch.title = `${getColorName(color)}: ${hexValue}`;
        
        if (collection === 'ss') {
            swatch.classList.add('ss-swatch');
        } else if (collection === 'aw') {
            swatch.classList.add('aw-swatch');
        }
        
        clickableContainer.appendChild(swatch);
    });
    
    // Add "Show All" button
    const showAllButton = document.createElement('div');
    showAllButton.classList.add('show-all-colors-btn');
    showAllButton.innerHTML = '+';
    showAllButton.title = 'Show all colors in palette';
    clickableContainer.appendChild(showAllButton);
    
    // Add event listener to show all colors in a modal
    showAllButton.addEventListener('click', function(e) {
        e.stopPropagation(); // Prevent triggering the parent container's click
        
        const fullPalette = window[`${collection}PaletteColors`][paletteIndex];
        if (!fullPalette || fullPalette.length === 0) {
            console.error('No full palette found to display');
            return;
        }
        
        showFullPaletteModal(fullPalette, collection, paletteIndex);
    });
}


function handleShuffleColors() {
  console.log("Starting color shuffle process");
  
  // Show loader
  showLoader('Shuffling colors...');
  
  // Use setTimeout to ensure the loader is rendered before processing starts
  setTimeout(() => {
    try {
      const imageColorPickerContainer = document.getElementById('image-color-pickers');
      if (!imageColorPickerContainer) {
        console.error("Color picker container not found");
        hideLoader();
        return;
      }
      
      const colorButtons = Array.from(imageColorPickerContainer.getElementsByClassName('pcr-button'));
      console.log(`Found ${colorButtons.length} color buttons total`);
      
      if (colorButtons.length === 0) {
        console.log("No color buttons found");
        hideLoader();
        return;
      }

      // Get all color data with their locked status
      const allColorData = colorButtons.map((button, originalIndex) => {
        const style = window.getComputedStyle(button);
        const bgcolor = style.backgroundColor;
        const layerIndexAttr = button.dataset.layerIndex;
        const layerIndex = layerIndexAttr ? parseInt(layerIndexAttr) : originalIndex;
        const colorArray = bgcolor.match(/\d+/g).map(Number);
        const isLocked = button.dataset.locked === 'true';
        
        console.log(`Button ${originalIndex}: Layer ${layerIndex}, Color: ${colorArray.join(',')}, Locked: ${isLocked}`);
        
        return {
          color: colorArray,
          layerIndex: layerIndex,
          element: button,
          isLocked: isLocked,
          originalIndex: originalIndex
        };
      });
      
      // Get only unlocked colors for shuffling
      const unlockedColors = allColorData.filter(data => !data.isLocked);
      console.log(`Found ${unlockedColors.length} unlocked colors to shuffle`);
      
      if (unlockedColors.length === 0) {
        console.log('All colors are locked, nothing to shuffle');
        hideLoader();
        return;
      }
      
      if (unlockedColors.length === 1 && colorButtons.length === 1) {
        // Single unlocked color case - generate a new color variation
        handleSingleColorVariation(unlockedColors[0]);
        return;
      }
      
      // Check if we're dealing with a single layer (multiple color buttons for one canvas)
      const canvasElements = document.querySelectorAll('canvas[id^="layer_canvas_"]');
      const isSingleLayer = canvasElements.length === 1;
      
      if (isSingleLayer) {
        // Handle single layer with multiple color regions
        handleSingleLayerColorShuffle(allColorData, unlockedColors);
      } else {
        // Handle multiple layers (original logic)
        handleMultiLayerColorShuffle(allColorData, unlockedColors);
      }
        
    } catch (error) {
      console.error("Error in handleShuffleColors:", error);
      hideLoader();
    }
  }, 50); // Small delay to ensure the loader UI renders
}

// New function to handle single layer with multiple color regions
function handleSingleLayerColorShuffle(allColorData, unlockedColors) {
  console.log("Processing single layer with multiple color regions");
  
  // Get the canvas
  const canvas = document.querySelector('canvas[id^="layer_canvas_"]');
  if (!canvas) {
    console.error("Canvas not found");
    hideLoader();
    return;
  }
  
  try {
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    
    // Save current state
    const actualLayerIndex = 1; // Single layer case always uses layer 1
    if (layerStates && typeof layerStates.saveEditedState === 'function') {
      layerStates.saveEditedState(actualLayerIndex);
    }
    
    // Create color mapping for transformation
    // Map from original colors to new colors
    const colorMap = new Map();
    
    // Get only the unlocked color values
    const unlockedColorValues = unlockedColors.map(data => data.color);
    
    // Shuffle only the unlocked colors
    const shuffledUnlockedColors = shuffleArray([...unlockedColorValues]);
    
    // Create mapping for unlocked colors
    unlockedColors.forEach((data, index) => {
      const originalColor = data.color;
      const newColor = shuffledUnlockedColors[index];
      
      // RGB string for map key
      const originalColorKey = originalColor.join(',');
      
      colorMap.set(originalColorKey, newColor);
      
      // Update button appearance
      data.element.style.backgroundColor = `rgb(${newColor.join(',')})`;
      
      console.log(`Mapping color ${originalColorKey} to ${newColor.join(',')}`);
    });
    
    // Process the image data, applying the color mapping with tolerance
    const tolerance = 15; // Color matching tolerance
    
    for (let i = 0; i < data.length; i += 4) {
      const r = data[i];
      const g = data[i + 1];
      const b = data[i + 2];
      
      // Skip transparent pixels
      if (data[i + 3] === 0) continue;
      
      // Find if this color matches any of our unlocked colors within tolerance
      let matched = false;
      
      for (const [origColorStr, newColor] of colorMap.entries()) {
        const origColor = origColorStr.split(',').map(Number);
        
        // Check if within tolerance range
        if (
          Math.abs(r - origColor[0]) <= tolerance &&
          Math.abs(g - origColor[1]) <= tolerance &&
          Math.abs(b - origColor[2]) <= tolerance
        ) {
          // Calculate how much to adjust this specific pixel
          const rDiff = newColor[0] - origColor[0];
          const gDiff = newColor[1] - origColor[1];
          const bDiff = newColor[2] - origColor[2];
          
          // Apply the same relative change to maintain color variations
          data[i] = Math.max(0, Math.min(255, r + rDiff));
          data[i + 1] = Math.max(0, Math.min(255, g + gDiff));
          data[i + 2] = Math.max(0, Math.min(255, b + bDiff));
          
          matched = true;
          break;
        }
      }
      
      // If no match found, this pixel's color remains unchanged (effectively locked)
    }
    
    // Put the modified image data back to the canvas
    ctx.putImageData(imageData, 0, 0);
    
  } catch (error) {
    console.error("Error in single layer color shuffle:", error);
  } finally {
    // Always hide the loader when finished
    hideLoader();
  }
}

// Function to handle multiple layers color shuffle (original logic)
function handleMultiLayerColorShuffle(allColorData, unlockedColors) {
  // Get only the color values from unlocked items
  const colorValues = unlockedColors.map(data => data.color);
  
  // Shuffle the color values
  const shuffledColorValues = shuffleArray([...colorValues]);
  console.log("Shuffled colors:", shuffledColorValues);
  
  // Store original colors for processing
  const originalColorsMap = new Map();
  
  // Save all layer states before making changes
  if (layerStates && typeof layerStates.saveEditedState === 'function') {
    allColorData.forEach(data => {
      const actualLayerIndex = data.layerIndex + 1;  // Adjust for canvas ID format
      layerStates.saveEditedState(actualLayerIndex);
      originalColorsMap.set(data.layerIndex, data.color);
    });
  }
  
  // Apply shuffled colors to unlocked buttons and process canvases
  const processPromises = [];
  
  unlockedColors.forEach((data, shuffleIndex) => {
    const newColor = shuffledColorValues[shuffleIndex];
    const button = data.element;
    const layerIndex = data.layerIndex;
    const actualLayerIndex = layerIndex + 1;  // Adjust for canvas ID format
    const originalColor = originalColorsMap.get(layerIndex);
    
    console.log(`Applying shuffled color ${newColor.join(',')} to layer ${actualLayerIndex} (was ${originalColor.join(',')})`);
    
    // Update button color
    button.style.backgroundColor = `rgb(${newColor.join(',')})`;
    
    const canvas = document.getElementById(`layer_canvas_${actualLayerIndex}`);
    if (!canvas) {
      console.warn(`Canvas for layer ${actualLayerIndex} not found`);
      return;
    }
    
    // Process the layer with the new color
    const processPromise = new Promise((resolve) => {
      if (layerStates && typeof layerStates.hasEditedState === 'function' && 
          layerStates.hasEditedState(actualLayerIndex)) {
        const img = new Image();
        img.onload = async () => {
          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(img, 0, 0);
          await processLayerAsync(ctx, originalColor, newColor);
          resolve();
        };
        img.src = layerStates.getEditedState(actualLayerIndex);
      } else {
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        resolve(processLayerAsync(ctx, originalColor, newColor));
      }
    });
    
    processPromises.push(processPromise);
  });

  Promise.all(processPromises)
    .then(() => {
      console.log('All unlocked layers processed successfully');
      hideLoader();
    })
    .catch(error => {
      console.error('Error during color processing:', error);
      hideLoader();
    });
}
// Handle the special case of a single color
function handleSingleColorVariation(colorData) {
  console.log("Processing single color variation");
  
  const button = colorData.element;
  const layerIndex = colorData.layerIndex + 1; // Adjust for canvas ID format
  const originalColor = colorData.color;
  
  const canvas = document.getElementById(`layer_canvas_${layerIndex}`);
  if (!canvas) {
    console.error(`Canvas for layer ${layerIndex} not found`);
    hideLoader();
    return;
  }
  
  // Save current state
  layerStates.saveEditedState(layerIndex);
  
  // Generate variations of the color
  const variations = generateColorVariations(originalColor);
  const shuffledVariations = shuffleArray(variations);
  const newColor = shuffledVariations[0]; // Use the first variation
  
  console.log(`Changing color from ${originalColor.join(',')} to ${newColor.join(',')}`);
  
  // Update button color
  button.style.backgroundColor = `rgb(${newColor.join(',')})`;
  
  // Process the layer with new color
  if (layerStates.hasEditedState(layerIndex)) {
    const img = new Image();
    img.onload = async () => {
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0);
      await processLayerAsync(ctx, originalColor, newColor);
      hideLoader();
    };
    img.src = layerStates.getEditedState(layerIndex);
  } else {
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    processLayerAsync(ctx, originalColor, newColor)
      .then(() => hideLoader())
      .catch(error => {
        console.error("Error processing single color:", error);
        hideLoader();
      });
  }
}

// Helper functions for loader
function showLoader(message = 'Loading...') {
  // Check if the loader already exists
  let loader = document.getElementById('color-shuffle-loader');
  
  if (!loader) {
    // Create loader element
    loader = document.createElement('div');
    loader.id = 'color-shuffle-loader';
    loader.classList.add('color-shuffle-loader');
    
    // Style the loader
    loader.style.position = 'fixed';
    loader.style.top = '0';
    loader.style.left = '0';
    loader.style.width = '100%';
    loader.style.height = '100%';
    loader.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
    loader.style.display = 'flex';
    loader.style.justifyContent = 'center';
    loader.style.alignItems = 'center';
    loader.style.zIndex = '9999';
    
    // Create spinner and message
    const content = document.createElement('div');
    content.style.backgroundColor = 'white';
    content.style.padding = '20px';
    content.style.borderRadius = '8px';
    content.style.textAlign = 'center';
    
    const spinner = document.createElement('div');
    spinner.classList.add('spinner');
    spinner.style.width = '40px';
    spinner.style.height = '40px';
    spinner.style.margin = '0 auto 15px';
    spinner.style.border = '5px solid #f3f3f3';
    spinner.style.borderTop = '5px solid #3498db';
    spinner.style.borderRadius = '50%';
    spinner.style.animation = 'spin 1s linear infinite';
    
    const messageElem = document.createElement('div');
    messageElem.textContent = message;
    
    // Add spinner and message to content
    content.appendChild(spinner);
    content.appendChild(messageElem);
    
    // Add content to loader
    loader.appendChild(content);
    
    // Add animation style
    const style = document.createElement('style');
    style.textContent = `
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
    `;
    document.head.appendChild(style);
    
    // Add to DOM
    document.body.appendChild(loader);
  } else {
    // Update existing loader message
    const messageElem = loader.querySelector('div > div:not(.spinner)');
    if (messageElem) {
      messageElem.textContent = message;
    }
    
    // Make sure it's visible
    loader.style.display = 'flex';
  }
}

function hideLoader() {
  const loader = document.getElementById('color-shuffle-loader');
  if (loader) {
    loader.style.display = 'none';
  }
}
// Helper function to generate color variations
function generateColorVariations(baseColor) {
  const variations = [];
  
  // Add the original color
  variations.push([...baseColor]);
  
  // Generate some variations by adjusting hue
  for (let i = 1; i <= 3; i++) {
      const hslColor = rgbToHsl(baseColor[0], baseColor[1], baseColor[2]);
      hslColor[0] = (hslColor[0] + (i * 30)) % 360; // Rotate hue by 30 degrees
      const rgbColor = hslToRgb(hslColor[0], hslColor[1], hslColor[2]);
      variations.push(rgbColor);
  }
  
  return variations;
}

// Add a utility function to check if colors are significantly different
function areColorsDifferent(color1, color2, threshold = 5) {
    return Math.abs(color1[0] - color2[0]) > threshold ||
           Math.abs(color1[1] - color2[1]) > threshold ||
           Math.abs(color1[2] - color2[2]) > threshold;
}

// Modify your createColorButtons function to add layer index to buttons

function createColorButtons() {
  const imageColorAnalyzer = new ImageColorAnalyzer();
  const imageColorPickerContainer = document.getElementById('image-color-pickers');
  imageColorPickerContainer.innerHTML = '';
  
  const canvasElements = document.querySelectorAll('canvas[id^="layer_canvas_"]');
  const isSingleLayer = canvasElements.length === 1;

  if (isSingleLayer) {
      // Handle single layer case - create buttons for all distinct colors
      const canvas = canvasElements[0];
      const ctx = canvas.getContext('2d');
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const distinctColors = getDistinctColors(imageData, 30, 50); // Lower tolerance, more colors

      distinctColors.forEach((color, index) => {
          // Create wrapper div for button and lock
          const wrapper = document.createElement('div');
          wrapper.className = 'color-button-wrapper';
          
          // Create color button
          const button = document.createElement('button');
          button.className = 'pcr-button color-picker';
          button.style.backgroundColor = `rgb(${color.join(',')})`;
          button.dataset.layerIndex = 0;
          button.dataset.locked = 'false';
          
          // Create lock overlay
          const lockOverlay = document.createElement('div');
          lockOverlay.className = 'lock-overlay';
          lockOverlay.innerHTML = `
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-unlock" viewBox="0 0 16 16">
                  <path d="M11 1a2 2 0 0 0-2 2v4a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h5V3a3 3 0 0 1 6 0v4a.5.5 0 0 1-1 0V3a2 2 0 0 0-2-2zM3 8a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1H3z"/>
              </svg>`;

          // Add lock overlay click handler
          lockOverlay.addEventListener('click', (e) => {
              e.stopPropagation();
              const isLocked = button.dataset.locked === 'true';
              button.dataset.locked = !isLocked;
              lockOverlay.innerHTML = !isLocked ? 
                  `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-lock" viewBox="0 0 16 16">
                      <path d="M8 1a2 2 0 0 1 2 2v4H6V3a2 2 0 0 1 2-2zm3 6V3a3 3 0 0 0-6 0v4a2 2 0 0 0-2 2v5a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2zM5 8h6a1 1 0 0 1 1 1v5a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V9a1 1 0 0 1 1-1z"/>
                  </svg>` :
                  `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-unlock" viewBox="0 0 16 16">
                      <path d="M11 1a2 2 0 0 0-2 2v4a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h5V3a3 3 0 0 1 6 0v4a.5.5 0 0 1-1 0V3a2 2 0 0 0-2-2zM3 8a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1H3z"/>
                  </svg>`;
          });

          wrapper.appendChild(button);
          wrapper.appendChild(lockOverlay);
          imageColorPickerContainer.appendChild(wrapper);
          button.dataset.layerIndex = index;
          
          button.addEventListener('click', () => {
            
              showLayerInfoButton(index);
          });
      });
  } else {
      // Original multiple layer logic
      canvasElements.forEach((canvas, index) => {
          const img = new Image();

          img.onload = () => {
            const canvas = document.getElementById(`layer_canvas_${layerIndex}`);
            const ctx = canvas.getContext('2d');
            console.log('im fucking triggered')
        
            // Save the current state of the canvas
            const currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        
            // Check if the canvas is already populated
            const isEmpty = currentImageData.data.every(value => value === 0);
        
            // Only reset the canvas if it's empty
            if (isEmpty) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);
            } else {
                // Restore the previous state if the canvas is not empty
                ctx.putImageData(currentImageData, 0, 0);
            }

              imageColorAnalyzer.analyzeImageColors(img)
                  .then(colorAnalysis => {
                      if (colorAnalysis) {
                          const dominantColor = colorAnalysis.dominantColor;

                          // Create wrapper div for button and lock
                          const wrapper = document.createElement('div');
                          wrapper.className = 'color-button-wrapper';
                          
                          // Create color button
                          const button = document.createElement('button');
                          button.className = 'pcr-button color-picker';
                          button.style.backgroundColor = `rgb(${dominantColor.join(',')})`;
                          button.dataset.layerIndex = index;
                          button.dataset.locked = 'false';
                          
                          // Create lock overlay
                          const lockOverlay = document.createElement('div');
                          lockOverlay.className = 'lock-overlay';
                          lockOverlay.innerHTML = `
                              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-unlock" viewBox="0 0 16 16">
                                  <path d="M11 1a2 2 0 0 0-2 2v4a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h5V3a3 3 0 0 1 6 0v4a.5.5 0 0 1-1 0V3a2 2 0 0 0-2-2zM3 8a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1H3z"/>
                              </svg>`;

                          // Add lock overlay click handler
                          lockOverlay.addEventListener('click', (e) => {
                              e.stopPropagation();
                              const isLocked = button.dataset.locked === 'true';
                              button.dataset.locked = !isLocked;
                              lockOverlay.innerHTML = !isLocked ? 
                                  `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-lock" viewBox="0 0 16 16">
                                      <path d="M8 1a2 2 0 0 1 2 2v4H6V3a2 2 0 0 1 2-2zm3 6V3a3 3 0 0 0-6 0v4a2 2 0 0 0-2 2v5a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2zM5 8h6a1 1 0 0 1 1 1v5a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V9a1 1 0 0 1 1-1z"/>
                                  </svg>` :
                                  `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-unlock" viewBox="0 0 16 16">
                                      <path d="M11 1a2 2 0 0 0-2 2v4a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h5V3a3 3 0 0 1 6 0v4a.5.5 0 0 1-1 0V3a2 2 0 0 0-2-2zM3 8a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1H3z"/>
                                  </svg>`;
                          });

                          wrapper.appendChild(button);
                          wrapper.appendChild(lockOverlay);
                          imageColorPickerContainer.appendChild(wrapper);
                          
                          button.addEventListener('click', () => {
                              showLayerInfoButton(index);
                          });
                      }
                  })
                  .catch(error => {
                      console.error(`Error analyzing colors for layer ${index}:`, error);
                  });
          };

          img.src = canvas.toDataURL('image/png');
      });
  }
}
// Add event listener for shuffle button
document.querySelector('.btn-success2').addEventListener('click', handleShuffleColors);
document.addEventListener('DOMContentLoaded', loadFavorites);
// Add this to your existing DOMContentLoaded event listener
document.addEventListener('DOMContentLoaded', function() {
    const layerColors = {};
    const totalLayers = {{ layers|length }};
    let loadedImagesCount = 0;

    function checkIfAllImagesLoaded() {
        if (loadedImagesCount === totalLayers) {
            const loadingScreen = document.getElementById('loading-screen');
            loadingScreen.style.display = 'none';

            // Generate unique RGB color palettes for the trending palettes
            const trendingPalettes = generateUniqueRGBColorPalettes(totalLayers, totalLayers);

      
        }
    }

    {% for layer in layers %}
    let img{{ forloop.counter }} = new Image();
    img{{ forloop.counter }}.src = "{{ layer.path }}";
    let canvas{{ forloop.counter }} = document.getElementById('layer_canvas_{{ forloop.counter }}');
    let ctx{{ forloop.counter }} = canvas{{ forloop.counter }}.getContext('2d', { willReadFrequently: true });
    img{{ forloop.counter }}.onload = function() {
        canvas{{ forloop.counter }}.width = img{{ forloop.counter }}.width;
        canvas{{ forloop.counter }}.height = img{{ forloop.counter }}.height;
        ctx{{ forloop.counter }}.drawImage(img{{ forloop.counter }}, 0, 0);
        loadedImagesCount++;
        checkIfAllImagesLoaded();
    };
    img{{ forloop.counter }}.onerror = function() {
        loadedImagesCount++;
        checkIfAllImagesLoaded();
    };
    {% endfor %}
});

function generateUniqueRGBColorPalettes(count, totalLayers) {
    const palettes = [];

    for (let i = 0; i < count; i++) {
        const colors = generateUniqueRGBColorArray(totalLayers);
        palettes.push(colors);
    }

    return palettes;
}

function showFormatSelectionDialog() {
    return new Promise((resolve, reject) => {
        // Create modal overlay
        const overlay = document.createElement('div');
        overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 10000;
            display: flex;
            justify-content: center;
            align-items: center;
        `;

        // Create modal content
        const modal = document.createElement('div');
        modal.style.cssText = `
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            text-align: center;
            min-width: 320px;
            max-width: 420px;
        `;

        modal.innerHTML = `
            <h3 style="margin-bottom: 20px; color: #333;">Select Export Format</h3>
            <div style="margin-bottom: 25px; text-align: left; padding: 0 10px;">
                <label style="display: flex; align-items: center; margin: 12px 0; cursor: pointer; padding: 12px; border: 2px solid #ddd; border-radius: 5px; transition: all 0.3s;">
                    <input type="radio" name="exportFormat" value="tiff" checked style="margin: 0; width: 16px; height: 16px; flex-shrink: 0;">
                    <div style="margin-left: 12px;">
                        <strong>TIFF</strong> - High quality, supports layers
                    </div>
                </label>
                <label style="display: flex; align-items: center; margin: 12px 0; cursor: pointer; padding: 12px; border: 2px solid #ddd; border-radius: 5px; transition: all 0.3s;">
                    <input type="radio" name="exportFormat" value="png" style="margin: 0; width: 16px; height: 16px; flex-shrink: 0;">
                    <div style="margin-left: 12px;">
                        <strong>PNG</strong> - Good quality, supports transparency
                    </div>
                </label>
                <label style="display: flex; align-items: center; margin: 12px 0; cursor: pointer; padding: 12px; border: 2px solid #ddd; border-radius: 5px; transition: all 0.3s;">
                    <input type="radio" name="exportFormat" value="jpg" style="margin: 0; width: 16px; height: 16px; flex-shrink: 0;">
                    <div style="margin-left: 12px;">
                        <strong>JPG</strong> - Smaller file size, good for photos
                    </div>
                </label>
            </div>
            <div style="text-align: center;">
                <button id="exportConfirm" style="background: #28a745; color: white; border: none; padding: 10px 20px; margin: 5px; border-radius: 5px; cursor: pointer;">Export</button>
                <button id="exportCancel" style="background: #6c757d; color: white; border: none; padding: 10px 20px; margin: 5px; border-radius: 5px; cursor: pointer;">Cancel</button>
            </div>
        `;

        overlay.appendChild(modal);
        document.body.appendChild(overlay);

        // Add hover effects
        const labels = modal.querySelectorAll('label');
        labels.forEach(label => {
            label.addEventListener('mouseenter', () => {
                label.style.borderColor = '#007bff';
                label.style.backgroundColor = '#f8f9fa';
            });
            label.addEventListener('mouseleave', () => {
                if (!label.querySelector('input').checked) {
                    label.style.borderColor = '#ddd';
                    label.style.backgroundColor = 'white';
                }
            });
            label.addEventListener('click', () => {
                labels.forEach(l => {
                    l.style.borderColor = '#ddd';
                    l.style.backgroundColor = 'white';
                });
                label.style.borderColor = '#007bff';
                label.style.backgroundColor = '#e3f2fd';
            });
        });

        // Set initial selected style
        const selectedLabel = modal.querySelector('input[checked]').closest('label');
        selectedLabel.style.borderColor = '#007bff';
        selectedLabel.style.backgroundColor = '#e3f2fd';

        // Handle buttons
        modal.querySelector('#exportConfirm').addEventListener('click', () => {
            const selectedFormat = modal.querySelector('input[name="exportFormat"]:checked').value;
            document.body.removeChild(overlay);
            resolve(selectedFormat);
        });

        modal.querySelector('#exportCancel').addEventListener('click', () => {
            document.body.removeChild(overlay);
            reject(new Error('Export cancelled'));
        });

        // Close on overlay click
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) {
                document.body.removeChild(overlay);
                reject(new Error('Export cancelled'));
            }
        });
    });
}

function exportFile(format = 'tiff') {
    return new Promise((resolve, reject) => {
        const loadingScreen = document.getElementById('loading-screen');
        loadingScreen.style.display = 'block';
        
        const formData = new FormData();
        const layers = [];
        
        // Get all layer canvases in correct order
        const layerCanvases = Array.from(document.querySelectorAll('[id^="layer_canvas_"]'))
            .sort((a, b) => {
                const indexA = parseInt(a.id.split('_').pop());
                const indexB = parseInt(b.id.split('_').pop());
                return indexA - indexB;
            });
        
        // Collect all layer data matching the read format
        layerCanvases.forEach((canvas) => {
            // Get the actual positions from the canvas or its wrapper
            const wrapper = canvas.closest('.layer-wrapper') || canvas.parentElement;
            const position_top = parseInt(wrapper.style.top) || 0;
            const position_left = parseInt(wrapper.style.left) || 0;
            
            // Get original dimensions from data attributes
            const original_width = parseInt(canvas.getAttribute('data-original-width') || 0);
            const original_height = parseInt(canvas.getAttribute('data-original-height') || 0);

            const layerData = {
                name: canvas.getAttribute('data-layer-name') || canvas.id,
                position_top: position_top,
                position_left: position_left,
                width: canvas.width,
                height: canvas.height,
                original_width: original_width,
                original_height: original_height,
                imageData: canvas.toDataURL('image/png', 1.0)
            };
            
            console.log(`Exporting Layer: ${layerData.name}, Position: (${layerData.position_left}, ${layerData.position_top}), Size: ${layerData.width}x${layerData.height}, Original Size: ${layerData.original_width}x${layerData.original_height}`);
            layers.push(layerData);
        });
        
        formData.append('layers_data', JSON.stringify(layers));
        formData.append('export_format', format);
        
        // Send data to server
        fetch('export_file/', {
            method: 'POST',
            headers: {
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: formData
        })
        .then(response => {
            if (!response.ok) {
                return response.text().then(text => {
                    try {
                        const json = JSON.parse(text);
                        throw new Error(json.error || 'Export failed');
                    } catch (e) {
                        throw new Error('Export failed: ' + text);
                    }
                });
            }
            return response.blob();
        })
        .then(blob => {
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            
            // Set appropriate file extension based on format
            const extensions = {
                'tiff': 'tif',
                'png': 'png',
                'jpg': 'jpg'
            };
            
            a.download = `exported.${extensions[format] || 'tif'}`;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            a.remove();
            resolve();
        })
        .catch(error => {
            console.error('Export failed:', error);
            reject(error);
        })
        .finally(() => {
            loadingScreen.style.display = 'none';
        });
    });
}

// Updated event listener setup
document.addEventListener('DOMContentLoaded', function() {
    const exportButton = document.querySelector('.btn.btn-success4') || document.getElementById('exportTiffButton');
    
    if (exportButton) {
        exportButton.addEventListener('click', function() {
            // Show format selection dialog first
            showFormatSelectionDialog()
                .then(selectedFormat => {
                    console.log(`Selected format: ${selectedFormat}`);
                    return exportFile(selectedFormat);
                })
                .then(() => {
                    console.log('Export completed successfully');
                })
                .catch(error => {
                    if (error.message !== 'Export cancelled') {
                        console.error('Export failed:', error);
                        alert('Export failed: ' + error.message);
                    }
                });
        });
    }
});

// Helper function to get CSRF token
function getCookie(name) {
  let cookieValue = null;
  if (document.cookie && document.cookie !== '') {
      const cookies = document.cookie.split(';');
      for (let i = 0; i < cookies.length; i++) {
          const cookie = cookies[i].trim();
          if (cookie.substring(0, name.length + 1) === (name + '=')) {
              cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
              break;
          }
      }
  }
  return cookieValue;
}


// Load favorites when the page loads


      {% comment %} fav sections ends  {% endcomment %}
      
      function changeHueWithHueAndLightnessTolerance(ctx, targetColor, newColor, hueTolerance, lightnessTolerance) {
  console.info('Processing Layer with target color:', targetColor, 'and new color:', newColor);
  const canvasWidth = ctx.canvas.width;
  const canvasHeight = ctx.canvas.height;
  const imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
  const data = imageData.data;

  // Convert target and new colors to HSL
  const targetHsl = rgbToHsl(...targetColor);
  const newHsl = rgbToHsl(...newColor);

  // Normalize hue tolerance to fraction (since hue is between 0 and 1 in HSL)
  const hueToleranceFraction = hueTolerance / 360; // Strict hue tolerance
  const lightnessTolerance1 = Math.max(0.05, lightnessTolerance); // Minimum 5% lightness tolerance
  const minSaturation = 0.1; // Minimum saturation threshold

  for (let i = 0; i < data.length; i += 4) {
    const currentColor = [data[i], data[i + 1], data[i + 2]];
    const currentHsl = rgbToHsl(...currentColor);

    // Skip desaturated colors
    if (currentHsl[1] < minSaturation) continue;

    // Calculate hue and lightness differences
    let hueDiff = Math.abs(currentHsl[0] - targetHsl[0]);
    if (hueDiff > 0.5) hueDiff = 1 - hueDiff; // Wrap-around for hue differences
    const lightnessDiff = Math.abs(currentHsl[2] - targetHsl[2]);

    // Check if the pixel's hue and lightness are within tolerance range
    if (hueDiff <= hueToleranceFraction && lightnessDiff <= lightnessTolerance1) {
      const blendedRgb = hslToRgb(newHsl[0], currentHsl[1], currentHsl[2]);

      // Scale RGB values to 0-255 and assign to data array
      data[i] = Math.round(blendedRgb[0] * 255);
      data[i + 1] = Math.round(blendedRgb[1] * 255);
      data[i + 2] = Math.round(blendedRgb[2] * 255);
    }
  }

  ctx.putImageData(imageData, 0, 0);
}

    </script>
  </body>
</html>
